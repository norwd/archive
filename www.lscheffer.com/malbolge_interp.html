<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Reference Malbolge Interpreter</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
</head>
  <body>
 This is the original Malbolge interpreter<br>
<pre><br>/* Interpreter for Malbolge.                                          */<br>/* '98 Ben Olmstead.                                                  */<br>/*                                                                    */<br>/* Malbolge is the name of Dante's Eighth circle of Hell.  This       */<br>/* interpreter isn't even Copylefted; I hereby place it in the public */<br>/* domain.  Have fun...                                               */<br>/*                                                                    */<br>/* Note: in keeping with the idea that programming in Malbolge is     */<br>/* meant to be hell, there is no debugger.                            */<br>/*                                                                    */<br>/* By the way, this code assumes that short is 16 bits.  I haven't    */<br>/* seen any case where it isn't, but it might happen.  If short is    */<br>/* longer than 16 bits, it will still work, though it will take up    */<br>/* considerably more memory.                                          */<br>/*                                                                    */<br>/* If you are compiling with a 16-bit Intel compiler, you will need   */<br>/* &gt;64K data arrays; this means using the HUGE memory model on most   */<br>/* compilers, but MS C, as of 8.00, possibly earlier as well, allows  */<br>/* you to specify a custom memory-model; the best model to choose in  */<br>/* this case is /Ashd (near code, huge data), I think.                */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;malloc.h&gt;<br>#include &lt;string.h&gt;<br><br>#ifdef __GNUC__<br>static inline<br>#endif<br>void exec( unsigned short *mem );<br><br>#ifdef __GNUC__<br>static inline<br>#endif<br>unsigned short op( unsigned short x, unsigned short y );<br><br>const char xlat1[] =<br>  "+b(29e*j1VMEKLyC})8&amp;m#~W&gt;qxdRp0wkrUo[D7,XTcA\"lI"<br>  ".v%{gJh4G\\-=O@5`_3i&lt;?Z';FNQuY]szf$!BS/|t:Pn6^Ha";<br><br>const char xlat2[] =<br>  "5z]&amp;gqtyfr$(we4{WP)H-Zn,[%\\3dL+Q;&gt;U!pJS72FhOA1C"<br>  "B6v^=I_0/8|jsb9m&lt;.TVac`uY*MK'X~xDl}REokN:#?G\"i@";<br><br>int main( int argc, char **argv )<br>{<br>  FILE *f;<br>  unsigned short i = 0, j;<br>  int x;<br>  unsigned short *mem;<br>  if ( argc != 2 )<br>  {<br>    fputs( "invalid command line\n", stderr );<br>    return ( 1 );<br>  }<br>  if ( ( f = fopen( argv[1], "r" ) ) == NULL )<br>  {<br>    fputs( "can't open file\n", stderr );<br>    return ( 1 );<br>  }<br>#ifdef _MSC_VER<br>  mem = (unsigned short *)_halloc( 59049, sizeof(unsigned short) );<br>#else<br>  mem = (unsigned short *)malloc( sizeof(unsigned short) * 59049 );<br>#endif<br>  if ( mem == NULL )<br>  {<br>    fclose( f );<br>    fputs( "can't allocate memory\n", stderr );<br>    return ( 1 );<br>  }<br>  while ( ( x = getc( f ) ) != EOF )<br>  {<br>    if ( isspace( x ) ) continue;<br>    if ( x &lt; 127 &amp;&amp; x &gt; 32 )<br>    {<br>      if ( strchr( "ji*p&lt;/vo", xlat1[( x - 33 + i ) % 94] ) == NULL )<br>      {<br>        fputs( "invalid character in source file\n", stderr );<br>        free( mem );<br>        fclose( f );<br>        return ( 1 );<br>      }<br>    }<br>    if ( i == 59049 )<br>    {<br>      fputs( "input file too long\n", stderr );<br>      free( mem );<br>      fclose( f );<br>      return ( 1 );<br>    }<br>    mem[i++] = x;<br>  }<br>  fclose( f );<br>  while ( i &lt; 59049 ) mem[i] = op( mem[i - 1], mem[i - 2] ), i++;<br>  exec( mem );<br>  free( mem );<br>  return ( 0 );<br>}<br><br>#ifdef __GNUC__<br>static inline<br>#endif<br>void exec( unsigned short *mem )<br>{<br>  unsigned short a = 0, c = 0, d = 0;<br>  int x;<br>  for (;;)<br>  {<br>    if ( mem[c] &lt; 33 || mem[c] &gt; 126 ) continue;<br>    switch ( xlat1[( mem[c] - 33 + c ) % 94] )<br>    {<br>      case 'j': d = mem[d]; break;<br>      case 'i': c = mem[d]; break;<br>      case '*': a = mem[d] = mem[d] / 3 + mem[d] % 3 * 19683; break;<br>      case 'p': a = mem[d] = op( a, mem[d] ); break;<br>      case '&lt;':<br>#if '\n' != 10<br>        if ( x == 10 ) putc( '\n', stdout ); else<br>#endif<br>        putc( a, stdout );<br>        break;<br>      case '/':<br>        x = getc( stdin );<br>#if '\n' != 10<br>        if ( x == '\n' ) a = 10; else<br>#endif<br>        if ( x == EOF ) a = 59048; else a = x;<br>        break;<br>      case 'v': return;<br>    }<br>    mem[c] = xlat2[mem[c] - 33];<br>    if ( c == 59048 ) c = 0; else c++;<br>    if ( d == 59048 ) d = 0; else d++;<br>  }<br>}<br><br>#ifdef __GNUC__<br>static inline<br>#endif<br>unsigned short op( unsigned short x, unsigned short y )<br>{<br>  unsigned short i = 0, j;<br>  static const unsigned short p9[5] =<br>    { 1, 9, 81, 729, 6561 };<br>  static const unsigned short o[9][9] =<br>    {<br>      { 4, 3, 3, 1, 0, 0, 1, 0, 0 },<br>      { 4, 3, 5, 1, 0, 2, 1, 0, 2 },<br>      { 5, 5, 4, 2, 2, 1, 2, 2, 1 },<br>      { 4, 3, 3, 1, 0, 0, 7, 6, 6 },<br>      { 4, 3, 5, 1, 0, 2, 7, 6, 8 },<br>      { 5, 5, 4, 2, 2, 1, 8, 8, 7 },<br>      { 7, 6, 6, 7, 6, 6, 4, 3, 3 },<br>      { 7, 6, 8, 7, 6, 8, 4, 3, 5 },<br>      { 8, 8, 7, 8, 8, 7, 5, 5, 4 },<br>    };<br>  for ( j = 0; j &lt; 5; j++ )<br>    i += o[y / p9[j] % 9][x / p9[j] % 9] * p9[j];<br>  return ( i );<br>}<br><br></pre>
 <br>
 <br>
 <br>
</body>
</html>
