<script type="text/javascript">
  var disqus_identifier = "doomIphone";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="iPhone 3D engine, Doom classic, code review"/>
		<meta name="Description" content="Doom Iphone code review"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>Doom Iphone source code review</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       February 1st, 2010</div>
   <h1>Doom Iphone code review</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="doomiPhoneEngine.jpg"" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         
	
                I took some time away from programming something I hope will become a really good shmup and read the source code of Doom for iPhone. I was very interested in finding out how a pixel oriented engine made the transition to openGL. Here are my notes, as usual I got a bit carried away with the drawings.<br/>
<br/>
<a href="index.php#Downloads">Downloads</a><br/>
<a href="index.php#Overall">Overall design</a><br/>
<a href="index.php#RendererDoom">Renderer: How Doom was working</a><br/>
<a href="index.php#RendererDoomGL">Renderer: How DoomGL is working</a><br/>
<a href="index.php#CSArch">Network system</a><br/>
<a href="index.php#Sound">Sound system</a><br/>
<a href="index.php#Comments">Comments</a><br/>
<a href="index.php#RecommendedReadings">Recommended readings</a><br/>
<br/>
<br/>
<u>Note:</u> There is plenty of cool stuff to learn from John Carmack's <a href="iPhone&#32;Doom&#32;Classic&#32;Progress&#32;Report.htm">Progress Report</a> and <a href="Doom&#32;Classic.htm">Release Note</a>.
<br/><br/>
And if this article stress you too much, check out a copy of <a href="http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=312575632&mt=8">Fluid 2</a> my relaxing application for iPhone.<br/>
<br/>
<u>Feb 8th, 2010 :</u> Slashdotted pretty hard, need to buy more bandwidth :/ !<br/>
<u>Feb 9th, 2010 :</u> Can't keep up with 5000 daily visitors, switching videos to YouTube for now (at least they are 480) :/ !<br/>
<u>Oct 29th, 2010 :</u> Seems John Carmack <a href="proof.php">liked</a> this review too.<br/>

<div style="clear:both;"></div>
            </p>
            <br/>
<a name="Downloads"></a>
<h3>Downloads</h3>

	Source code and binaries are available here:<br/>
			<br/>
			<p id="paperbox">	
				<a href="https://github.com/id-Software/DOOM-iOS"><img src="../images/xcode-icon.png"/></a>&nbsp;<a href="http://itunes.apple.com/WebObjects/MZStore.woa/wa/browserRedirect?url=itms%253A%252F%252Fitunes.apple.com%252FWebObjects%252FMZStore.woa%252Fwa%252FviewSoftware%253Fid%253D336347946%2526mt%253D8"><img src="../fluide/avail_on_app_store.png" /></a>&nbsp;<br/>
			</p>
<br/>



<a name="Overall"></a>
<h3>Overall design</h3>

<p id="paperbox">	
An iPhone application never really controls the device, it is only granted runtime (and it is understandable, an iPhone/iTouch need to be able to receive calls or play music). Hence most applications run in two threads, none of them are controlled by your code:				
<ul>
	<li>The openGL thread running in the GPU, where draw commands are buffered until rasterization is triggered.</li>
	<li>The main thread running on the CPU and owned by a <code>NSRunLoop</code> object.</li>
</ul>
<p>

At startup, the application's environment is initialized and <code>NSRunLoop</code> calls <code>applicationDidFinishLaunching</code>. This is where you get to run something, for 5 seconds, after what the function is interrupted. During this time period, you can register your code to receive notification of touch screen events via function pointers.<br/>
<br/>
In order to refresh the screen on a regular interval, we need to create new events via an <code>NSTimer</code> object that will be binded to <code>NSRunLoop</code>. <code>NSTimer</code> defines marks in time, <code>NSRunLoop</code> will check "regularly" if a mark had been passed and will call your function pointer. Most developer setup <code>NSTimer</code> to call a custom method: <code>hostFrame</code> at a "wished" frequency of 30 Hz.

</p>
<br/>
	<p>

	<img  style="margin-left: auto; margin-right: auto ; display: block; box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/NormalGame2.jpg"/>

<br/>
<br/>
There is plenty of problem with such a design:<br/>
<br/>
<ul>
<li>Because a NSRunLoop object can be busy, refreshing accuracy is only 100ms :( !</li>
<li>"Marks" are set in advance, this means that if the <code>hostGameFrame</code> method overRun the NSTimer marks, next trigger won't be as soon as possible but on the next scheduled mark ( See "Timer Sources" in Apple's documentation on <a href="http://developer.apple.com/iPhone/library/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">NSRunLoop</a>).</li>
</ul><br/>
Quote:
<pre class="long">


	You can configure timers to generate events only once or repeatedly. A repeating timer reschedules
	itself automatically based on the scheduled firing time, not the actual firing time. For example,
	if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled
	firing time will always fall on the original 5 second time intervals, even if the actual firing
	time gets delayed.


</pre>
<br/><br/>

	<img style="margin-left: auto; margin-right: auto ; display: block; box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/NSTimerOverRun.jpg"/>

<br/><br/>
	If this happen the CPU ends up being idle until the next NSTimer time mark is reached but more important: A frame is skipped.<br/>
<br/>
	Even one single frame taking too long to process can have disastrous impact on the framerate:<br/><br/>

	<img style="margin-left: auto; margin-right: auto ; display: block; box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/NSTimerOverLap.jpg"/>

<br/>
<br/>
	</p>


<p>
	Doom for iPhone tries never to miss a NSTimer mark by running in three threads:
</p>
<ul>
	<li>Main Thread (very short body, highest priority, never misses a mark and trigger Game Thread to host a frame via semaphore).</li>
	<li>Game Thread.</li>
	<li>OpenGL Thread.</li>
</ul>
<p>
Critical sections of the code (mainly user inputs) are protected via an Unix mutex. The rendering loop run as fast as it can but is starved via a semaphore on <code>sem_wait</code>. <code>iPhoneAsyncTic</code> increase the counter <code>sem_post</code>.<br/><br/>
</p>

<img style="margin-left: auto; margin-right: auto ; display: block; box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/Doom3ThreadDesign.jpg"/>
<br/>
<br/>
	<p>
		This design actually share a lot of similarities with the technique called "Triple buffering" which goal is to totally decouple the GPU from the display's refresh rate. Here the goal is to decouple the CPU from the NSTimer ticks:<br/>
<ul>
	<li>Shorten the runtime of the mainThread to never miss an NSTimer mark.</li>
	<li>The CPU is never idle, the high priority mainThread will interrupt the GameThread from time to time but that's it.</li>
</ul>
<br/>

	<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/NSTimerOverRunMultiThreaded.jpg"/>

<br/>
<br/>
<p>
Note: The rendering context is grabed by the Game Thread at startup <code>[EAGLContext setCurrentContext:context]</code> without usage of a <code>EAGLSharegroup</code>, effectively sharing the context accross two threads: It's a bad thing but it seems to be working fine anyway.<br/>
<br/>
I was surprised not to find any usage of <code>CADisplayLink</code>, an object allowing to link a method call with a screen refresh that showed HUGE performance (at least according to my <a href"/dEngine/index.php">experimentations</a>. But it is available on 3.0 firmware only so this design will allow more people to play the game, which makes a lot of sense commercially speaking.
</p>







<a name="RendererDoom"></a>
<h3>Renderer: How Doom was working.</h3>

<p >	
	
	Entry was so large it is now a full article: <a href="doomClassicRenderer.php">Here</a>
	
</p>


<a name="RendererDoomGL"></a>
<h3>Renderer: How Doom iPhone is working.</h3>

<p id="paperbox">	
Just like Wolfenstein 3D, Doom was rendering a screenframe pixel per pixel. The only way to do this on iPhone with an acceptable framerate would be to use <code>CoreSurface/CoreSurface.h</code> framework. But it is unfortunatly restricted and using it would prevent distribution on the AppStore.<br/><br/>
The only solution is to use OpenGL but this comes with a few challenges:<br/>
<ul>
<li>Doom was faking 3D with a 2D map. OpenGL needs real 3D vertices.</li>
<li>More than 3D vertices, OpenGL needs data to be sent as triangles (among other things because they are easy to rasterize). But Doom sectors were made of arbitrary forms.</li>
<li>Doom 1993 perspective was also faked, it was actually closer to an orthogonal projection than a perspective projection.</li>
<li>Doom was using VGA palette indexing to perform special effect (red for damage, silver for invulnerable...).</li>
</ul>
<br/>
<p>
Early attempts to port Doom to OpenGL built new WAD (Doom archive format). They exploited the WAD format capability to store pretty much anything (the original Doom WAD contained graphics, sounds, map, via different <code>lumps</code> types.) to create a new type of entry and store the 3D data organized as triangles. This is not the approach in Doom on iPhone, the world is "unified" in 3D primitives at the beginning of each level.<br/>
</p>
<br/>
<h3>Building the third dimension</h3>
<p id="paperbox">

If you know Doom engine of if you read the previous paragraph, you remember there is three types:
<ul>
<li>For the walls (made of lines called SEGS) it is fairly "easy" because all walls are vertical: Use the sector's heights to generate the third dimension, two triangles then form a rectangle wall.</li>
<li>Floor and Ceiling are much harder as sectors were not convex (only subsectors were). Each sector in the level is preprocessed via Silicon Graphic's libtess ( read more <a href="http://www.flipcode.com/archives/Polygon_Tessellation_In_OpenGL.shtml">here</a> ) on a per sector basis.</li>
<li>Things are not preprocessed but rendered as sprite impostors generated on the fly.</li>
</ul>

<br/>

<br/>
Only the flat tesselation is a bit hard to get, here is the processing of the main room sector in E1M1 (the space with a blue floor in the very beginning of Doom).<br/>
<br/>

<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/tesselation.jpg"/>

<br/>
<br/>
Note in the animation the way the set is drawn as a "fan" (although it is done via the <code>GL_TRIANGLES</code> primitive ).
<br/>
<br/>
<table style="width:100%;"><tr><td align="center">




<video width="800" height="548" preload="none" poster="../fd_proxy/doomIphone/doomiPhonePreview.jpg" controls>
  <source src="../fd_proxy/doomIphone/doomiPhonePreview-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>

</td></tr></table>
<br/>
<u>Note:</u> This video does not account for the deferred rendition process of the PowerVR chips. Fillrate consumption and overdraw are actually minimal.<br/>
<br/>
<br/>
<u>Trivia :</u> 
3D unification is done in <code>gld_PreprocessLevel</code> and is quite nice to read. Unfortunatly some maps had errors and workaround had to be hardcoded. Here in <code>gld_PreprocessSectors</code> with E3M8:<br/>
<br/>
<pre class="long">

	// JDC: E3M8 has a map error that has a couple lines that should
	// be part of sector 1 instead orphaned off in sector 2.  I could
	// let the non-closed sector carving routine handle this, but it
	// would result in some pixel cracks.  Instead, I merge the lines
	// to where they should have been.
	// This is probably not the right solution, because there are
	// probably a bunch of other cases in the >100 Id maps.

	extern int gameepisode, gamemap;

	if ( gameepisode == 3 && gamemap == 8 ) 
	{

		void IR_MergeSectors( int fromSector, int intoSector );
		IR_MergeSectors( 2, 1 );

	}

</pre>
</p>
<br/>
<br/>



<br/>
<a name="RendererDoomGL"></a>
<h3>The big picture</h3>

<p>	
Once the world is 3D consistent,  each frame is rendered via an hybrid CPU/GPU process:<br/>

<ul>
<li>Generate and upload OpenGL's <code>GL_PROJECTION</code> and <code> GL_MODELVIEW</code> matrices.</li>
<li>Perform extra view transformation and read back GL_MODELVIEW matrix from the GPU so pre-calculations can be performed.</li>
<li>Use the BSP to walk the world near to far. Nothing is rendered at this point, only visibility edicts are generated and stored in <code>gld_drawinfo</code>.
<ul>
<li>For each wall, use the matrix that was read back to precalulate the X screen space coordinate where OpenGL will render the wall and maintain an occlusion array <code>occlusion[MAX_SCREENWIDTH+2]</code>, nothing is rendered at this point.</li>
<li>If a subSector is visible, mark its parent sector as "to be rendered"</li>
<li>If a sector contains a thing, generate an impostor to render it.</li>
</ul>
<li>For the three groups of items, perform a quicksort based on the textureId.</li>
<li>Render all walls, sectors and things. One batch per texture.</li>
<li>Switch OpenGL to 2D and perform post effect to fake palette effects if necessary and draw player sprites etc..</li>
</ul>
<br/>
<br/>
<p>
All of this takes place in <code> IR_RenderPlayerView</code>.<br/>
<pre class="long">


	void IR_RenderPlayerView (player_t* player) 
	{
		[..]

		// clean occlusion array
		memset( occlusion, 0, sizeof( occlusion ) );

		// Reset the fake palette.
		gld_SetPalette(-1);

		// To make it easier to accurately mimic the GL model to screen transformation,
		// this is set up so that the projection transformation is also done in the
		// modelview matrix, leaving the projection matrix as an identity.  This means
		// that things done in eye space, like lighting and fog, won't work, but
		// we don't need them.
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();	
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		infinitePerspective(64.0f, 320.0f/200.0f, 5.0f/100.0f);

		IR_RenderBSPNode( numnodes-1 );
	
		NewDrawScene(player);

		// Perform fake palette effect
		gld_EndDrawScene();	

	}


</pre>
<p>
<br/>
<u>Trivia :</u> 
<br/>
<ul>
<li>Palette: Because Doom classic was using a VGA indexed palette to perform some special effects, this feature had to be replicated via a post effect in <code> gld_EndDrawScene</code>.</li>
<li>Scene processing and drawing are now two distinct phases (<code>IR_RenderBSPNode</code> and <code> NewDrawScene </code>), the way things started to be done in Quake.</li>
<li>Matrices are handled in an unusual fashion:
<ul>
	<li>Matrices are built, uploaded to OpenGL, manipulated via the drivers and then read back from OpenGL. The usual way is to build the final matrix and upload it.</li>
	<li>The perspective projection is stored in GL_MODELVIEW, leaving GL_PROJECTION has identity matrix.</li>
</ul>
 
<li>The BSP structure allows to walks the world near to far. But just before drawing, triangles are sorted via quicksort on the textureID. This allows to reduce the number of texture switch and reduce the number of drawing calls (by increasing the batch size).</li>
</ul>
<br/>
<br/>

<u>Next:</u> Video illustrating the drawing order: distance is not relevant anymore, triangles are drawn in batches of same texture. this is possible because Alpha testing is activated.<br/>
<br/>
<table style="width:100%;"><tr><td align="center">


<video width="800" height="548" preload="none" poster="../fd_proxy/doomIphone/doomIphonefirstRoom.jpg" controls>
  <source src="../fd_proxy/doomIphone/doomIphonefirstRoom-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>
</td></tr></table>
<br/>
<br/>
<br/>
Contrary to Doom93, partly transparent walls are not drawn at the end with the "things" because of the GPU's ability to use Alpha testing and Depth testing. The same POV was used as a video in the Classic Doom article. Again the priority of texture ID over distance is obvious.<br/>
<br/>

<table style="width:100%;"><tr><td align="center">

<video width="800" height="548" preload="none" poster="../fd_proxy/doomIphone/doomIphonetransparency.jpg" controls>
  <source src="../fd_proxy/doomIphone/doomIphonetransparency-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>
</td></tr></table>
<br/>
<br/>
<u>Trivia :</u><br/>
<br/>
Using Aplha testing on a tile-based deferred renderer (TBDR) such as the iPhones is highly inefficient because it introduces uncertainty in the GPU pipeline. But it seems it gets the job for Doom, so why not ?
</p>






<a name="CSArch"></a>
<h3>Networking</h3>

<p id="paperbox">	
Not much to add to John Carmack's <a href="Doom&#32;Classic.htm">Release Note</a>. Doom's original IPX system was first converted to UDP broadcast but packet drop was bad over WIFI (among other things). There is now a server to combine commands from clients and send updates to each devices.               
</p>


<a name="Sound"></a>
<h3>Sound system</h3>
<p id="paperbox">
The music system is now using Core Audio Services with MP3 decompressed on dedicated hardware (as opposed to the OGG format decompressed on CPU with Wolfenstein Iphone). Sound effects are WAV, processed via OpenAL on the CPU.
</p>


<a name="Comments"></a>
<h3>Comments</h3>
<p id="paperbox">	
Doom iPhone codebase is really really nice to read thanks to a lot of comments from JDC. Sections of the code that had to be rewritten (<code>iphone_*.c</code>) are HEAVILY documented.<br/>
<br/>

<p>
Example from <code>iphone_render.c</code> (there is almost more comments than code):<br/>
<pre class="long">


	// If a segment in this subsector is not fully occluded, mark
	// the line that it is a part of as needing to be drawn.  Because
	// we are using a depth buffer, we can draw complete line segments
	// instead of just segments.

	for ( int i = 0 ; i < sub->numlines ; i++ ) {
		seg_t *seg = &segs[sub->firstline+i];
		
		line_t *line = seg->linedef;

		// Determine if it will completely occlude farther objects.
		// Given that changing sector heights is much less common than
		// traversing lines during every render, it would be marginally better if
		// lines had an "occluder" flag on them that was updated as sectors
		// moved, but it hardly matters.

		boolean	occluder;
		if ( seg->backsector == NULL || 
			seg->backsector->floorheight >= seg->backsector->ceilingheight ||
			seg->backsector->floorheight >= seg->frontsector->ceilingheight ||
			seg->backsector->ceilingheight <= seg->frontsector->floorheight ) 
		{
			// this segment can't be seen past, so fill in the occlusion table
			occluder = true;

		} else {
			// If the line has already been made visible and we don't need to
			// update the occlusion buffer, we don't need to do anything else here.
			// This happens when a line is split into multiple segs, and also
			// when the line is reached from the backsector.  In the backsector
			// case, it would be back-face culled, but this test throws it out
			// without having to transform and clip the ends.

			if ( line->validcount == validcount ) {
				continue;
			}
			
			// check to see if the seg won't draw any walls at all
			
			// we won't fill in the occlusion table for this
			occluder = false;
		}
	}


</pre>
</p>
            </p>
<h3> Faking VGA palette</h3>

<p>
Doom 93 was taking advantage of VGA's DAC color table (colors indexed on a palette) to change all colors on the screen when picking an item (brighter), taking damage (red) or while invulnerable (silver).<br/>
<br/>
But OpenGL doesn't work with palettes (actually you have access to <code>GL_OES_compressed_paletted_texture</code> on iPhone 3GS but the plateform is still marginal and even worse: Colors are expanded (converted to RGBA) making their use counter-productive! The effect is replicated via a three stages process:<br/>
<br/>
<ul>
<li>If any effect during <code>D_Display</code> want to change the palette, it just modifies the global variable <code>palette</code> (damage palette=10,newItem palette=8) .</li>
<li>The palette change is detected in PRBoom's <code>V_SetPalette</code> and calls <code>gld_SetPalette</code> to set the color of the QUAD to blend over.</li>
<li>Finally, <code> gld_EndDrawScene</code> check if a blend is required and performs it by drawing a semi-transparent QUAD on top of the entire screen. </li>
</ul>
<br/>
<p>
<u>Note:</u> If a shift toward the same color can be achieved via "normal" blending (<code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code>), invulnerability is a bit tricker to fake: <code>glBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO)</code> is used instead to perform a negate.<br/><br/> The effect on iPhone (on the right) is similar but not as nice as what could be done with a palette (on the left).<br/>
<br/>
<table><tr><td align="center">
	<img src="../fd_proxy/doomIphone/invClassic.jpg"/>
</td>
<td>
	<img src="../fd_proxy/doomIphone/invOpenGL.jpg"/>
</td>
</tr>
</table>
</p>



</p>
<br/>

<h3>Spinning wheel</h3>
<p >
Something new compared to the PC version is the spinnning wheel, prompting you to wait at the beginning of each level:<br/>
<br/>
<table><tr><td align="center">
<img src="../fd_proxy/doomIphone/spinningWheel.jpg"/>
</td>
</tr>
</table>
<br/><br/>
This happens while textures are uploaded to OpenGL and can be significant (up to 2s). This is done after the first frame has been drawn so player has something to look at. Precaching reduce frame skipping later in the level when new textures become visible, it is done in <code>gld_Precache()</code>.
</p>

<h3>Profiling.</h3>

<p>	
Attached Instruments to Doom (running on iPhone, not XCode simulator) provided some cool datas regarding the cost of every operations:<br/>
<br/>
<table><tr><td align="center">
<img src="../fd_proxy/doomIphone/doomIphoneProfiling.jpg"/>
</td>
</tr>
</table>
<br/>
<ul>
	<li><code>Main Thread</code> as seen previously the brain of the application. Mainly here to catch NSTimer marks.</li>
	<li><code>Game Thread</code> actually performing the work.</li>
	<li><code>AURemoteIO Thread</code> Core Audio's unit, interface with the iPhone's HAL. Read plenty of cool things <a href="http://developer.apple.com/iphone/library/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html">here</a>.</li>
	<li><code>RunWeb Thread</code> usually active only when embedding a browser in the app. No idea why it's here.</li>
</ul>
<p>
<br/>
As expected most of the time allocated to the process is spent in <code>GameThread</code>, preparing the next frame via <code>iPhoneFrame()</code>. Note the sound system is not consuming CPU as it is processed on a dedicated chip (only sound effects are passed on the CPU).
<br/><br/>
Focusing on <code>iPhoneFrame</code> method:<br/>
<br/>
<table><tr><td align="center">
<img src="../fd_proxy/doomIphone/doomIphoneProfiling2.jpg"/>
</td>
</tr>
</table>
<br/>
<br/>
This was a 120s session, this explain why texture uploading (<code>gld_Precache</code>) cost is so huge.
<br/>
<br/>
Focusing on <code>iPhoneDrawScreen</code> method:<br/>
<br/>
<table><tr><td align="center">
<img src="../fd_proxy/doomIphone/doomIphoneProfiling3.jpg"/>
</td>
</tr>
</table>
<br/>
<br/>A lot of time is spent in <code>SwapBuffersAndTouches</code>, this method clear the user input and instruct OpenGL to flip the framebuffer:<br/>After more tracing it seems the mutex is not slowing down the touches swapping ( 2/3 micros on average) while swapping the framebuffer via <code>[context presentRenderbuffer:GL_RENDERBUFFER_OES]</code> run around 1-2 ms with jumps to 12000 to 24000 ms. iPhones are supposed to use triple buffering so I was unable to put an explanation on this :/ !
<br/>
</p>
<h3>Doom 2</h3>
<p >
Does this new engine work well with Doom2 WAD archive ? Yes, absolutely. Just put <code>doom2.wad</code> in the <code>base</code> directory, remove <code>doom.wad</code>, deploy and play !!
<br/><br/>

<img style="margin-left: auto; margin-right: auto ; display: block; " src="../fd_proxy/doomIphone/doom2Iphone.jpg"/>

<br/>
<br/>
Double Shotgun
<br/>
<br/>

<img style="margin-left: auto; margin-right: auto ; display: block; " src="../fd_proxy/doomIphone/doom2Iphone3.jpg"/>

<br/><br/>
Even the new monsters (here a "mancubus") are working fine:<br/>
<br/>

<img style="margin-left: auto; margin-right: auto ; display: block; " src="../fd_proxy/doomIphone/doom2Iphone4.jpg"/>

<br/><br/>
I was expecting the new monsters to crash the engine but I realized Doom iPhone is based on PRBoom, itself based on UltimateDoom. All the monsters behavior function pointer are valid.
</p>
<br/>
<a name="Compiling"></a>
<h3>Compiling on 3.0 firmware and above.</h3>

<p>	
Attemp to compile with iPhone SDK 3.0 but gcc raised an unusual error: <code>crosses initialization of</code><br/>
<br/>
<pre class="long">

	322	OSStatus BackgroundTrackMgr::SetupQueue(BG_FileInfo *inFileInfo) {
	323	UInt32 size = 0;
	324	OSStatus result = AudioQueueNewOutput(&inFileInfo->mFileFormat, QueueCallback, this, CFRunLoopGetMain() 
	325	
	326	AssertNoError("Error creating queue", end);
	327	// channel layout
	328	OSStatus err = AudioFileGetPropertyInfo(inFileInfo->mAFID, kAudioFilePropertyChannelLayout, &size,NULL);
	329	if (err == noErr && size > 0) {
	330		AudioChannelLayout *acl = (AudioChannelLayout *)malloc(size);
	331		result = AudioFileGetProperty(inFileInfo->mAFID, kAudioFilePropertyChannelLayout, &size, acl);
	332		AssertNoError("Error getting channel layout from file", end);
	333		result = AudioQueueSetProperty(mQueue, kAudioQueueProperty_ChannelLayout, acl, size);
	334		free(acl);
	335		AssertNoError("Error setting channel layout on queue", end);
	336	}
	337
	338	// volume
	339	result = SetVolume(mVolume);
	340	
	341	end:
	342	return result;
	343	}

</pre>
<br/>

<pre class="long">


	/Users/[..]/iphone/BackgroundMusic.cpp:341: error: jump to label 'end'
	/Users/[..]/iphone/BackgroundMusic.cpp:326: error:   from here
	/Users/[..]/BackgroundMusic.cpp:328: error:   crosses initialization of 'OSStatus err'


</pre>
<br/>
Jumping into the scope of an automatic variable may bypass constructor calls and is hence forbidden. Solution was to replace the MACRO with its corresponding define and remove the goto.
<br/>

</p>
<br/>
<a name="RecommendedReadings"></a>
<h3>Recommended readings</h3>
<p >
<a href="http://www.amazon.com/Jim-Blinns-Corner-Graphics-Pipeline/dp/1558603875/ref=sr_1_1?ie=UTF8&s=books&qid=1264631877&sr=8-1">A trip Down The PipeLine</a> : Oldie But Goodie (and a pure gem that helped me to understand homegenous coordinates system and perspective projection).<br/>
<br/>

<img src="../images/tripdownpipeline.jpg">	

</p>


<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

