<script type="text/javascript">
  var disqus_identifier = "doomIphone";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Doom engine, code review, BSP, visplanes, profiler"/>
		<meta name="Description" content="Doom engine ,code review, BSP, visplanes, profiler"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>Doom Engine source code review</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       January 13th, 2010</div>
   <h1>Doom engine code review</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="doomClassic.jpg"" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         
	Before studying the iPhone version, it was important for me to understand how Doom engine WAS performing rendition back in 1993. After all the OpenGL port must reuse the same data from the WAD archive. Here are my notes about Doom 1993 renderer, maybe it will help someone to dive in.<br/>

<br/>

<u>January 13th, 2010 :</u> Reddit annihilated my bandwidth (4 hours after publication). Back online.<br/>
<u>February 8th, 2010 :</u> Slashdotted, moving videos to YouTube.com. I can't keep up with 5000 visitors a day.<br/>
<u>July 23th, 2011 :</u> Two videos surfaced about doom development: <a href="http://www.youtube.com/watch?v=Q65xJfVkiaI">A Visit to id Software</a> and <a href="http://www.gdcvault.com/play/1014627/Classic-Game-Postmortem">Doom: Post-Mortem 2011</a>.<br/>
</p>
            <br/>






<h3>From designer screen to player screen</h3>

<p >	
Maps were designed in 2D by a level designer using Doom editor (DoomED). LINEDEFS were describing closed sectors (SECTORS in the source code), the third dimension (height) was defined on a per sector basis. The first level of Doom E1M1 looks like this:<br/>
<br/>
<br/>
<table width="100%">
<tr>
<td align="center">
<img style="margin-left: auto; margin-right: auto ; display: block;" src="../fd_proxy/doomIphone/E1M1YouAreHere.jpg"/><br/>
</td>
</tr>
</table>
<br/>
<br/>
When the map was finished, it was sliced via Binary Space Partitioning. Recursively a LINEDEF was chosen and its plan extended as splitting plan. LINEDEF were hence cut into segments (SEGS) until only convex SubSectors (SSECTOR in the code) remained.<br/>
<br/>
<u>Trivia:</u> Both DoomED and iBSP were programmed using....Objective-C on a NextStep workstation. Fifteen years later, the same language, running on almost the same operating system are running the game in the palm of our hand! I did a bit of web archeology and managed to find the original source code of idbsp, it's worth taking a look:<br/>
<br/>
<br/> 


<a href="idbsp.zip"><img style="margin-left: auto; margin-right: auto ; display: block;" src="zipArchive.png"/></a><br/>
<br/>


<br/><br/>
Following is an example of the first map being recursively split:<br/><br/>
<u>Recursion level 1</u><br/>
<br/>

<div style="text-align:center;width:100%;">
<img style="margin-left: auto; margin-right: auto ; display: inline; margin-right:20px;" src="../fd_proxy/doomIphone/E1M1node1split.jpg"/>
<img style="margin-left: auto; margin-right: auto ; display: inline;" src="../fd_proxy/doomIphone/E1M1node1splitBox.jpg"/>
</div>

<br/>
In blue a wall is selected and extended as splitting plan (red). Splitter were selected in order to balance the BSP tree but also to limit the number of SEGS generated. The green bounding boxes are used later to discard entire chunks of map.<br/><br/>
<u>Recursion level 2 (only right subspace)</u><br/>
<br/>

<div style="text-align:center;">
	<img style="margin-left: auto; margin-right: auto ; display: inline; margin-right:20px;" src="../fd_proxy/doomIphone/E1M1node2Split.jpg"/>
	<img style="margin-left: auto; margin-right: auto ; display: inline;" src="../fd_proxy/doomIphone/E1M1node2SplitBBox.jpg"/>
</div>
<br/>
In the end, SECTORS were spliced into convex sub-sectors (called SSECTORS) and LINEDEFS were sliced into segments (called SEGS):<br/>
<br/>
<br/>

<img style="margin-left: auto; margin-right: auto ; display: block;" src="../fd_proxy/doomIphone/E1M1subSectors.jpg"/>

<br/>
</p>




<h3>The big picture of runtime</h3>
<p>
Here is what the main rendering method (<code>R_RenderPlayerView</code>) looks like:<br/>
</p>
<br/>
<pre  class="long">


	void R_RenderPlayerView (player_t* player)
	{	
		[..]

		R_RenderBSPNode (numnodes-1);
        
		R_DrawPlanes ();
    
		R_DrawMasked ();

	}


</pre>
<p>
<br/>
Four things happen:<br/>
</p>
<ul>
<li><code>R_RenderBSPNode</code> : All subSectors in the map are sorted using the BSP tree. Big chunks are discarded via bounding box (green in the previous drawing). </li>
<li><code>R_RenderBSPNode</code> : Visible SEGS are projected on screen via a lookup table and clipped via an occlusion array. Walls are drawn as column of pixels. The size of a column is determined by the distance from the player POV, the Y position of a column via the height relative to the played. The base and the top of the walls generate visplanes, a structure used to render the floor and ceiling (called flats).</li>
<li><code>R_DrawPlanes</code> : Visplanes are converted from column of pixels to lines of pixels and rendered to screen.</li>
<li><code>R_DrawMasked</code> : The "things" (enemies, objects and transparent walls) are rendered.</li>
</ul>
<br/>
</p>



<h3>Binary Space Partition sorting</h3>
<p>
Two examples with E1M1 (Doom first map) and a BSP looking as follow:<br/>
<br/>
<table>
<tr>
<td>
<pre  class="long">


  //Coordinate system origin in lower left corner

  // Plane equation ax + by + c = 0 with 
  // unit normal vector = (a,b)

	
  // Root plane (splitting map between zone A and B): 
  
  normal = (-1,0)	c = 3500	
	
  
  
  // A plane (splitting zone A between zone A1 and A2): 

  normal = (1,0)	c = -2500
	
  
  
  // B plane (splitting zone B between zone B1 and B2): 
  
  normal = (-0.24,0.94)	  c = -650
	
  
  // Injecting any point coordinate (x,y) in a 
  // plane equation gives the distance from that plane.
	
	
</pre>
</td>
<td>
<img src="../fd_proxy/doomIphone/visBSP.jpg"/>
</td>
</tr>
</table>
<br/>
BSP walking always start at the root node, sorting both subspaces. Recursion follows on both node children.
<br/>
<br/>
<u>Example 1 :</u> Player (green dot) watching through the window from point p=(2300,1900):<br/>
<br/>
<div style="text-align:center;">
<td><img style="margin-left: auto; margin-right: auto ; display: inline; margin-right:20px;" src="../fd_proxy/doomIphone/E1M1_window.jpg"/></td>
<td><img style="margin-left: auto; margin-right: auto ; display: inline;" src="../fd_proxy/doomIphone/E1M1AllSplitsExample1.jpg"/></td>
</div>

<br/>
<pre  class="long">

  // Player position = ( 2300, 1900 )

  // R_RenderBSPNode run against AB splitter (-x + 3500 = 0):
  
     -2300 + 3500 = 1200 
  
     Result is positive: Closest subspace is in the FRONT of the splitting plane. (A is closer than B).
  
  
  
  
  
  // R_RenderBSPNode now run recursively against the two child of the root node: A1/A2 splitter and B1/B2 splitter. 
  
  // R_RenderBSPNode run against A1/A2 splitter (x - 2500 = 0):
  
     2300 - 2500 = -200
  
     Result is negative so the closest subspace is in the BACK of the splitting plane. (A1 is closer than A2).
  
  
  // R_RenderBSPNode run against B1/B2 splitter (-0.24x +0.97y - 650 = 0):
  
     -0.24 * 2300 + 0.97 * 1900- 650 = 641
  
     Result is positive so the closest subspace is in the FRONT of the splitting plane. (B1 is closer than B2).
  
 
  
   
     Result: Sorted zones, from near to far:
 
     { A1, A2, B1, B2 }
  
</pre>

<p>
<u>Example 2 :</u> Player (green dot) watching from the secret balcony a point p=(5040, 2400 ):<br/>
<br/>


<div style="text-align:center;">
<td><img style="margin-left: auto; margin-right: auto ; display: inline;  margin-right:20px;" src="../fd_proxy/doomIphone/E1M1_overview.jpg"/></td>
<td><img style="margin-left: auto; margin-right: auto ; display: inline;" src="../fd_proxy/doomIphone/E1M1AllSplitsExample2.jpg"/></td>
</div>
<br/>
<pre  class="long">

  // Player position = ( 5040, 2400 )

  // R_RenderBSPNode run against AB splitter (-x + 3500 = 0):
  
      -5040 + 3500 = -1540 
  
      Result is negative: Closest subspace is in the BACK of the splitting plane. (B is closer than A).
  
  
  
  
  
  // R_RenderBSPNode now recursively run against the two child of the root node: A1/A2 splitter and B1/B2 splitter. 
   
  // R_RenderBSPNode run against B1/B2 splitter (-0.24x +0.97y - 650 = 0):
  
     -0.24 * 5040 + 0.97 * 2400 - 650 = 468
  
     Result is positive so the closest subspace is in the FRONT of the splitting plane. (B1 is closer than B2).
  
 
  // R_RenderBSPNode run against A1/A2 splitter (x - 2500 = 0):
  
    5040 - 2500 = 2540
  
    Result is positive so the closest subspace is in the FRONT of the splitting plane. (A2 is closer than A1).
   
  	
  	
    Result: Sorted zones, from near to far:
 
    { B1, B2, A2, A1 }
  
</pre>
<p>
BSP allowed SEGS sorting from anywhere in the map at a consistent speed, regardless of the player's location. At the cost of one cross-product per plane. Entire part of the map were also discarded via bounding box testing.<br/><br/>
<u>Note :</u> It is not immediately apparent but BSP sorting all SEGS around the player, even the ones he/she is not looking at, frustrum culling is essential when using BSP.
<br/>
</p>





<h3>Walls</h3>

<p>
With the BSP sorting walls (SEGS) near to far, the closest 256 walls were rendered. Every SEGS's two vertices were converted to two angles (relative to the player's position).<br/><br/>
<u>Note :</u> In 1993, only the very high-end 486DX machines had a FPU (floating point unit) hence Doom engine was doing all angles calculation via Binary Angular Measurement (BAMs), relying on <code>int</code> only, <code>float</code> is rarely used. For the same reason, sub integer precision is achieved via <code>fixed_t</code> a 16.16 binary fixed point (more about this <a href="http://gameprogrammer.com/4-fixed.html">here</a> and <a href="http://netwinder.osuosl.org/pub/netwinder/docs/nw/fix1FAQ.html">here</a>).<br/>
<br/>
Once converted to angle  screen space X coordinate are retrieved via a lookup table (<code>viewangletox</code>). Because BAMs were <code>int</code>, angles were first scaled down from 32 bits to 13 bits via a 19bits right shift in order to fit the 8k lookup table. <br/>
	The wall is then clipped against an occlusion array (<code>solidsegs</code>, some articles about Doom engine mention a linked list but it does not look like it). After clipping, space remaining was interpolated and drawn as column of pixels: The height and Y coordinate of the column of pixel were based respectively on the SEGS's sector height and its distance from player POV.<br/>
<br/>
<u>Note about surface culling:</u> Backface culling was done via <code> angle2-angle1 > 180 </code>. Only walls within the Field of View were actually rendered.
<br/>
<br/>
<img src="../fd_proxy/doomIphone/projectionExplained.jpg"/>
<br/>
<br/>

<u>Note :</u> Not all walls were made of an unique texture, walls could have a lower texture, a upper texture and a middle texture ( that could be transparent or semi-transparent). This was handy to simulate windows as it can be seen in the next video: the "window" is actually a sector with higher floor and no middle texture.<br/>
<br/>
<table style="width:100%;"><tr><td align="center">
<video width="800" height="600" preload="none" poster="../fd_proxy/doomIphone/Previewwindow.jpg" controls>
  <source src="../fd_proxy/doomIphone/window.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>

</td></tr></table>
<br/>
<u>Trivia :</u> Because walls were rendered as vertical columns, wall textures were stored in memory rotated 90 degrees to the left. 
This trick allowed to take full advantage of the CPU precaching capability: To read a wall texel from the RAM also prepopulated the CPU cache with eight adjacent texels on each side.
Hence the subsequent read was already in the RAM cache and a substantial read latency reduction was achieved. You can read "The Art of Assembly Language programming" (3.2.4 Cache Memory) 
for more information about precaching and memory alignment.<br/>
</p>

<h3>Flats (Ceiling and Floor) or the infamous visplanes</h3>
<p>
While drawing column of walls, top and bottom screen space coordinates were used to generate "visplanes": An area in screen space (not necessarily continuous horizontally). Here is a visplane_t as declared in Doom engine.<br/>
<br/>
<pre  class="long">


	//
	// Now what is a visplane, anyway?
	// 


	typedef struct
	{
		fixed_t		height;
		int		picnum;
		int		lightlevel;

		int		minx;
		int		maxx;
  
		byte		top[SCREENWIDTH];
		byte		bottom[SCREENWIDTH];
	
	} visplane_t;



</pre>
<p>
The first part of the structure hold information about the "material", (<code>height picnum lightlevel</code>). The four last members defines the screenspace zone covered.<br/>
<br/>
If two subSectors shared the same material (height, texture and illumination level) Doom engine tried to merge them together but because of the <code>visplane_t</code> structure limitation it was not always possible.<br/>
<br/>


For the entire width of the screen, a visplane can store the location of a column of pixel (because visplanes are deduced from the walls projection on screen, they are created as column of pixels). <code></code>
<br/><br/>
Here are the starting screen's three main visplanes:<br/>
<br/>
<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/visplanesOutline.jpg"/><br/><br/>
The green one is particularly interesting as it illustrates <code>visplane_t</code> ability to store discontinued areas (but only horizontally). As long as the column is continuous, visplane can store it. This limitation shows in the engine: some subSectors can be merged and be rendered via only one visplane but if something come between vertically they cannot be merged.<br/><br/> Here is a screenshot illustrating visplane fragmentation and the video associated.<br/>
<br/>

<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;" src="../fd_proxy/doomIphone/visplanesOutline2.jpg"/><br/>
<br/>


<table style="width:100%;"><tr><td align="center">
<video width="800" height="600" preload="none" poster="../fd_proxy/doomIphone/Previewvisplanes.jpg" controls>
  <source src="../fd_proxy/doomIphone/visplanes.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>


</td></tr></table>
<br/><br/>
<u>Trivia :</u> Visplanes hardcoded limit (<code>MAXVISPLANES</code>  128) was a plague for modders as the game would crash and go back to DOS. Two issues could arise:<br/>
<ul>
<li><code>"R_FindPlane: no more visplanes"</code> : The total number of different visplanes materials (height, texture and illumination level) is over 128.</li>
<li><code>R_DrawPlanes: visplane overflow (%i)</code> : Visplanes fragmentation is important and number of visplanes is over 128.</li>
</ul>

<p>
Why limit to 128 ? Two stages in the renderer pipepline requested to search in the list of visplanes (via <code>R_FindPlane</code>), this was done via linear search and it was probably too expensive beyond 128. Lee Killough later lifted this limitation, replacing linear seach with a chained hash table implementation.<br/>
</p>


<h3>Things and transparent walls.</h3>
<p>
When all solid/" middle texture transparent" walls and ceiling/floors surfaces were rendered, only remained the "things", regrouping enemies, barrel, ammos and semi-transparent walls. Those are rendered far to near but are not projected into screen space using the wall's lookup table, it's all done with 16.16 binary fixed point calculations.<br/><br/>

<table style="width:100%;"><tr><td align="center">
	<video width="800" height="600" preload="none" poster="../fd_proxy/doomIphone/Previewtransparency.jpg" controls>
  <source src="../fd_proxy/doomIphone/transparency.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>

</td></tr></table>
<br/><br/>
<u>Note :</u> This video illustrate some of the worse case scenario where some pixels are written three times.<br/>
</p>

<h3>Profiling</h3>
<p>
Loading "Chocolate Doom" in Mac OS X's Instrument allowed to do some profiling:<br/> <br/>It seems the port is pretty fidele to Vanilla Doom: Most time is spent drawing walls (<code>R_DrawColumn</code>), ceiling/floor(<code>R_DrawSpan</code>) and things (<code>R_DrawMaskedColumn</code> ). Besides drawing I noticed the high cost of wall interpolation (<code>R_RenderSegLoop</code>) and visplane conversion from columns to lines of pixels (<code>R_MakeSpans</code>). Finally comes monsters IA (<code>R_MobjThinker</code>) and BSP traversal (<code>R_RenderBSPNode</code>)<br/><br/>
<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;"src="doomProfiling.png"/>
<br/>
<br/>
With an inverted call tree, we can see that most of the work is indeed done in the BSP traversal, wall rendition and visplanes generation: <code>R_RenderBSPNode</code> (second column is for percentage of time).<br/>
<br/>
<img style="margin-left: auto; margin-right: auto ; display: block;box-shadow: rgb(119, 119, 119) 3px 3px 3px;"src="doomProfiling2.png"/><br/>
</p>





<h3>All together</h3>
<p>
Finally, a video of the legendary first screen generation where you can see in order:
<ul>
	<li>Walls, near to far, as column of pixels</li>
	<li>Flats, near to far, as lines  of pixels.</li>
	<li>Things, far to near.</li>
</ul>
<p>

<table style="width:100%;"><tr><td align="center">
		<video width="800" height="600" preload="none" poster="../fd_proxy/doomIphone/PreviewE1M1.jpg" controls>
  <source src="../fd_proxy/doomIphone/E1M1.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>



</td></tr></table>
<br/>

</p>


<h3>Trivia</h3>
<p id="paperbox">
	<ul>
		<li>
	Since Doom was developed on a NeXTSTEP system using a flat virtual memory model, id Software decided against
	using <a href="http://en.wikipedia.org/wiki/Expanded_Memory_Specification">EMS</a> 
	or <a href="http://en.wikipedia.org/wiki/Extended_Memory_Specification">XMS</a> like most games of the time.
	Instead they used DOS/4G: a memory extender that allowed a software to access protected mode RAM on a real mode operating systen (DOS).<br/>
	<br/>
    The NexT workstation was so powerful that it was able to run the editor, the game and a debugger. When the game was stable enough
    the code was sent of the network to a PC where it was compiled for DOS/x86 by a Watcom compiler.
    
    Thanks to DOS/4G the code ran with the same memory model on PC and NeXT.<br/>
    </li>
    <li>
    A nice video that is a good complement to the book "Masters of Doom":<br/>
    <br/>
        <div style="width:100%;display:block;text-align:center; margin-left: auto; margin-right: auto;" >
    		<iframe  width="560" height="315" src="https://www.youtube.com/embed/RDAzJLBB6pE" frameborder="0" allowfullscreen></iframe>
    	</div>
    </li>
    <li>Many details from John Romero on <a href="http://rome.ro/2006/12/apple-next-merger-birthday.html">rome.ro</a> and <a href="http://planetromero.com/2009/01/doom-history-1994">planetromero.com</a>.</li>
</ul>
<br/>
</p>
	





<h3>Recommended readings</h3>
<p id="paperbox">
<ul>
	<li><a href="ftp://ftp.idsoftware.com/idstuff/doom/linux/">Original source code</a>, released in 1997 is OK to read but: Very little to no comments, won't compile, miss sound subsystem source code (due to a licensing problem).</li>
	<li><a href="http://www.chocolate-doom.org/wiki/index.php/Chocolate_Doom">Chocolate Doom</a>: HELL YEA ! This port is gorgeous, based on SDL it will compile with brio on pretty much any platform, it's the port I hacked to generate these videos.</li>
	<li>Michael ABRASH's programming black book. Wonderful to understand BSPs and a great source of inspiration, this guy can even make you love assembly.</li>
	<li><a href="http://www.amazon.com/Masters-Doom-Created-Transformed-Culture/dp/0812972155">Masters of Doom</a> : The story of id Software with many details on the making of Doom</li>
</ul>
</p>


<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

