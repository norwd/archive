<script type="text/javascript">
  var disqus_identifier = "shadowmapping";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="shadow map, shadowmapping, openGL, GLUT, c++, GLSL, Shaders"/>
		<meta name="Description" content="ShadowMapping tutorial"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>ShadowMapping with GLUT and GLSL</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       February 14th, 2009</div>
   <h1>ShadowMapping with GLSL</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="shadowMapping.png" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         



	
				When I got started learning openGL Shading Language, the "Orange Book" was a great resource, but I thought it lacked code samples. 
				Here is a modest cross platform implementation of shadow mapping.<br/>
				<br/>
				My goal was to provide something easy to compile, on Windows, MacOS and Linux. That's why the entire source is one .c file (+2 shaders) 
				coded in ANSI C. Crossplatform window management is performed via GLUT. I did not use GLEW to ensure Microsoft Windows portability, again 
				this is for ease of compilation.<br/>
				<br/>
				<b><u>EDIT June, 2013:</u></b> Some of the material in this article were published in <a href="http://www.amazon.ca/Computer-Graphics-Principles-Practice-Edition/dp/0321399528/ref=dp_ob_title_bk">Computer Graphics: Principles and Practice (3rd Edition)</a> :) !
				
			<div style="clear:both;"></div>
			</p>
			<h3>Source
			</h3>
				<ul>
				<li><a href="main.c">main.c</a>
				<li><a href="VertexShader.c">VertexShader.glsl</a>
				<li><a href="FragmentShader.c">FragmentShader.glsl</a>
				</ul>
				<p>
				<a href="shadowmapping.zip">Zipped pack</a><br/>
				<br/>
				<u>Win32 and macOS X Binaries:</u><br/>
				<br/>
				<a href="ShadowMappingBinary.zip"><img src="../images/Windows.png"/></a><br/>
				<u>Note:</u> Due to a Macos X bug with GLUT (relative path is lost an set to "/" when the app starts), I cannot 
				distribute the binary. Running the sample in XCode is fine.
				<br/>
				<br/>
				<u>Note 2:</u> Kris de Greve ported the code to C# mono. Source code <a href="Kris&#32;De&#32;Greve.shadowtest.rar">here</a> 
				<br/>
			</p>
			
			
			<br/>
			<h3>Code explanation
			</h3>
			<p id="paperbox">
				This is the rawest form of shadow mapping:<br/>	
				
				<ul>
					<li> Rendering is done offscreen via FBO. There is no fallback using <code>glCopyTexSubImage2D</code> as I assumed that 
					any GPU with support for GLSL would also support FBOs.</li>
					<li> There is no "hidden" mechanisms in the shader. Function used for lookup is <code>texture2D</code> and the W divide 
					is done manually. I will write an other sample using <code>shadow2DProj</code>, built-in GLSL functions.</li>	
					<li> The light matrix is passed via the TEXTURE7 matrix. It's not best practice to re-use variables but it made the code 
					shorter and IMHO less scary for a beginner to read. </li>			
				</ul>
			</p>
			
			




			<h3>FBO creation
			</h3>
			<p id="paperbox">
				The shadowmap is rendered offscreen via an openGL Framebuffer Object (FBO). Only depth value are saved during rendition, there
				 is no color texture bound to the FBO and color writes are disabled via <code>glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE)</code>.
			</p>
			<br/>
			
				<pre  class="long">
				
				
	// Hold id of the framebuffer for light POV rendering
	GLuint fboId;

	// Z values will be rendered to this texture when using fboId framebuffer
	GLuint depthTextureId;
					
	void generateShadowFBO()
	{
	  int shadowMapWidth = RENDER_WIDTH * SHADOW_MAP_RATIO;
	  int shadowMapHeight = RENDER_HEIGHT * SHADOW_MAP_RATIO;
	
	  GLenum FBOstatus;

	  // Try to use a texture depth component
	  glGenTextures(1, &depthTextureId);
	  glBindTexture(GL_TEXTURE_2D, depthTextureId);

	  // GL_LINEAR does not make sense for depth texture. However, next tutorial shows usage of GL_LINEAR and PCF
	  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	  // Remove artifact on the edges of the shadowmap
	  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );
	  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP );

	  // No need to force GL_DEPTH_COMPONENT24, drivers usually give you the max precision if available
	  glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapWidth, shadowMapHeight, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, 0);
	  glBindTexture(GL_TEXTURE_2D, 0);

	  // create a framebuffer object
	  glGenFramebuffersEXT(1, &fboId);
	  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);

	  // Instruct openGL that we won't bind a color texture with the currently bound FBO
	  glDrawBuffer(GL_NONE);
	  glReadBuffer(GL_NONE);
 
	  // attach the texture to FBO depth attachment point
	  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,GL_TEXTURE_2D, depthTextureId, 0);

	  // check FBO status
	  FBOstatus = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
	  if(FBOstatus != GL_FRAMEBUFFER_COMPLETE_EXT)
		  printf("GL_FRAMEBUFFER_COMPLETE_EXT failed, CANNOT use FBO\n");

	  // switch back to window-system-provided framebuffer
	  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	}				
	
	
				</pre>
					<p>
					</p>

			<h3>Light POV transformation
			</h3>
			
			<p id="paperbox">
				I've read a lot of tutorial where people concatenate the "reverse camera transform". I don't see the utility
				 of this and I prefer to load directly the bias*projection*modelview matrix in the <code>GL_TEXTURE7</code> matrix.
			</p>
			
				<pre  class="long">
				
				
	void setTextureMatrix(void)
	{
		static double modelView[16];
		static double projection[16];
		
		// Moving from unit cube [-1,1] to [0,1]  
		const GLdouble bias[16] = {	
			0.5, 0.0, 0.0, 0.0, 
			0.0, 0.5, 0.0, 0.0,
			0.0, 0.0, 0.5, 0.0,
		0.5, 0.5, 0.5, 1.0};
		
		// Grab modelview and transformation matrices
		glGetDoublev(GL_MODELVIEW_MATRIX, modelView);
		glGetDoublev(GL_PROJECTION_MATRIX, projection);
		
		
		glMatrixMode(GL_TEXTURE);
		glActiveTextureARB(GL_TEXTURE7);
		
		glLoadIdentity();	
		glLoadMatrixd(bias);
		
		// concatating all matrices into one.
		glMultMatrixd (projection);
		glMultMatrixd (modelView);
		
		// Go back to normal matrix mode
		glMatrixMode(GL_MODELVIEW);
	}			
	
				</pre>
			<p>
			</p>

			<h3>Vertex Shader
			</h3>
			<p id="paperbox">
				No rocket science here, we transform the vertex with the camera matrices, the same vertex with the light POV matrix and we get the fragment color
			</p>
			<br/>
			
<pre  class="long">


	// Used for shadow lookup
	varying vec4 ShadowCoord;
	
	void main()
	{
		ShadowCoord= gl_TextureMatrix[7] * gl_Vertex;
	  
		gl_Position = ftransform();
	
		gl_FrontColor = gl_Color;
	}


</pre>			
			
        
        	<br/>
			<h3>Fragment Shader</h3>
			<br/>
			<p id="paperbox">
				The <code>shadow</code> variable hold the shadowed test result. As you see, the goal is to compare the z value (in light POV)
				 of the vertex rendered, with what was rendered to the shadowmap.<br/>
			</p>
			
				<pre  class="long">
				
				
	uniform sampler2D ShadowMap;

	varying vec4 ShadowCoord;

	void main()
	{	
		vec4 shadowCoordinateWdivide = ShadowCoord / ShadowCoord.w ;
		
		// Used to lower moirÃ© pattern and self-shadowing
		shadowCoordinateWdivide.z += 0.0005;
		
		
		float distanceFromLight = texture2D(ShadowMap,shadowCoordinateWdivide.st).z;
		
		
	 	float shadow = 1.0;
	 	if (ShadowCoord.w > 0.0)
	 		shadow = distanceFromLight < shadowCoordinateWdivide.z ? 0.5 : 1.0 ;
	  	
		
		gl_FragColor =	 shadow * gl_Color;
	  
	}
				
				</pre>
			<p>
			</p>
			
			
			<h3>Avoid self-shadowing and Moir&eacute; pattern</h3>
			
			<p id="paperbox">
				Self-shadowing occurs because of the depth buffer limited precision. This is also know as Z-fighting. This only
				 affect polygons facing the light because it's what was rendered to the shadowmap.<br/>
				<br/>
				<img src="selfshadowingInitialProblem.png"/><br/>
				<br/>
				<br/>
				Even if you use the maximum precision available (<code>GL_DEPTH_COMPONENT24</code>) this is not an issue that can be solved efficiently with raw power: 
				No level of precision can totally get ride of self-shadowing.<br/>
				<br/>
				A good technique to reduce it is to cull front facing polygons during the shadowmap rendition step, using <code>glCullFace(GL_FRONT)</code><br/>
				and switch back to <code>glCullFace(GL_BACK)</code> during the second step. Here is the result:<br/><br/>
				<br/>
				<img src="selfshadowing.png"/><br/>
				<br/>
				As you can see this technique only move the self-shadowing issue to the polygon not facing the light, but it's much less noticeable<br/>
				Adding a small bias during sampling <code>shadowCoordinateWdivide.z += 0.0005</code> remove the selfshadowing from the backfaces as well.<br/>
				<br/>
				<br/>
				<br/>
				<img src="selfshadowingCorrected.png"/><br/>
				<br/>
			</p>
			
						<br/>
			<h3>The importance of shadowmap resolution</h3>
			<br/>
			<p id="paperbox">
				
				Whatever resolution you use, depending on the position of the light, you will experiment aliasing issue with your shadow.<br/>
				For this issue, raw processing power can help a little : You can crank up the resolution to which you render the shadowmap.<br/>
				<br/>
				160x120 shadowmap:<br/>
				<br/>
				<img src="resolution160x120.png"/><br/>
				<br/>
				640x480 shadowmap:<br/>
				<br/>
				<img src="resolution640x480.png"/><br/>
				<br/>
				1280x960 shadowmap:<br/>
				<br/>
				<img src="resolution1280x960.png"/><br/>
				<br/>	
				<br/>
				Set the texture filtering to <code>GL_LINEAR</code> won't help much. The best way, it to use Percentage Closer Filtering (PCF). 
				This algorithm will provides us with a tiny penumbra, one step toward shadows,  this shadow method is covered in my next article.<br/>
			</p>
			
			<br/>
			
			<br/>
			<h3>Avoid artifacts behind and on the sides of the light</h3>
			
			<p id="paperbox">
				When using shadowmapping, you get some projection artifacts when you try to retrieve shadow information out of the light frustrum. 
				On the sides of the frustrum and behind it.<br/>
				<br/>
				<br/>
				<u>On the side:</u><br/>
				<br/>
				As you can see on the upper left, the cube's shadows are projected again, because we fetched shadowmap information beyond the [0,1]
				 limit of a texture.<br/>
				<br/>
				<img src="artefactSide.png"/><br/>
				<br/>
				The way to solve this one is to specify what openGL should sample in such case. This can be done with the following lines:<br/>
				<code>glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP )</code> and <code>glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP )</code>.<br/> 
				<br/>
				<br/>
				<u>Behind the camera:</u><br/>
				<br/>
				But there is still one artefact, visible in the upper right:<br/>
				<br/>
				<img src="artefactSideCorrected.png"/><br/>
				<br/>
					This is when we try to sample value behind the light's view frustrum. This is solved via the shader line:<br/>
					<code>if (ShadowCoord.w > 0.0) </code>.<br/>
				<br/>
				<img src="artefactBackCorrected.png"/><br/>
				<br/>	
				<br/>
				
				<br/>
				
			</p>
			

			<h3>The Windows XP/Vista special</h3>
			
			<p id="paperbox">
				Unfortunatly, Microsoft decided not to support openGL extension beyond v1.1 . As a result, we need to retrieve the location of the functions
				 needed for FBO and GLSL when the program start up.
				This is definitely an ugly piece of code and I recommend to use GLEW instead, it is done manually here in order to provide a single compilable file.
				
				
								<pre  class="long">


    #ifdef _WIN32
		
	PFNGLACTIVETEXTUREARBPROC glActiveTextureARB;

	// FrameBuffer (FBO) gen, bin and texturebind
	PFNGLGENFRAMEBUFFERSEXTPROC glGenFramebuffersEXT ;
	PFNGLBINDFRAMEBUFFEREXTPROC glBindFramebufferEXT ;
	PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glFramebufferTexture2DEXT ;
	PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glCheckFramebufferStatusEXT ;
	

	void getOpenGLFunctionPointers(void)
	{
	  glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)wglGetProcAddress("glActiveTextureARB");
	  glGenFramebuffersEXT		= (PFNGLGENFRAMEBUFFERSEXTPROC)		wglGetProcAddress("glGenFramebuffersEXT");
	  glBindFramebufferEXT		= (PFNGLBINDFRAMEBUFFEREXTPROC)		wglGetProcAddress("glBindFramebufferEXT");
	  glFramebufferTexture2DEXT	= (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)wglGetProcAddress("glFramebufferTexture2DEXT");
	  glCheckFramebufferStatusEXT	= (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)wglGetProcAddress("glCheckFramebufferStatusEXT");
	}

    #endif

				</pre>
				
			
			<br/>
			<h3>Recommended books</h3>
			
				<p id="paperbox">
					Here are two books I recommend if you want to learn more about shadowMapping:<br/>
					<br/>
					<a href="http://www.amazon.ca/Real-Time-Rendering-Akenine-Moller/dp/1568814240/ref=sr_1_1?ie=UTF8&s=books&qid=1233937854&sr=1-1" ><img src="../books/realTime.jpg" style="margin-right:15px;box-shadow: rgb(119, 119, 119) 3px 3px 3px;"/></a>
				
					<a href="http://www.amazon.ca/GPU-Gems-Programming-Techniques-Real-Time/dp/0321228324/ref=sr_1_3?ie=UTF8&qid=1233938603&sr=1-3" ><img src="../books/gpugems1.jpg" style="margin-right:15px;box-shadow: rgb(119, 119, 119) 3px 3px 3px;"/></a>
				
	<a href="http://www.amazon.com/Real-Time-Shadows-Elmar-Eisemann/dp/1568814380/ref=sr_1_1?ie=UTF8&qid=1391105083&sr=8-1&keywords=real+time+shadow" ><img src="../books/trs.png" style="margin-right:15px;box-shadow: rgb(119, 119, 119) 3px 3px 3px;"/></a>

				</p>

<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

