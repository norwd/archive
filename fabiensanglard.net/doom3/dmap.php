<script type="text/javascript">
  var disqus_identifier = "doom3" ;
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Doom3 Source Code Review, id tech4"/>
		<meta name="Description" content="Doom3 Source Code Review"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
	
 	
		
		<title>Doom3 Source Code Review: Dmap preprocessing</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       June 8, 2012</div>
   <h1>Doom3 Source Code Review: Dmap (Part 2 of 6) <a href="renderer.php">>></a></h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="icons/doom3_icon_desaturated.png" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         
<style> 
table.credits{
    
background: #fff;
font: 12px 'DejaVu Sans';
    box-shadow: rgb(119, 119, 119) 3px 3px 3px;
margin: 0px 0px 0px 15px;
    
}
table.credits { width:97%; a:link:color:rgb(0, 136, 204);}
table.credits thead { background:transparent; }

table.credits th { white-space:nowrap; }
table.credits thead th { border-left:1px solid #ccc;  border-top:1px solid #ccc; padding:9px 9px 3px; color:#999; }
	table.credits tbody th,
	table.credits tbody td { border-top:1px solid #ccc; padding:6px 9px; }
        table.credits tbody th { padding:7px 0 7px 0; text-align:center; color:#999; }
            table.credits tbody th b { color:#333; font-weight:normal; }
                table.credits tbody td { border-left:1px solid #ccc; }
                    
                    table.credits tbody .session { background:#d4e6fa url(session_bgblue.png) repeat-x 0 0; }
                        table.credits tbody .session.alt { background:#e9ecf0 url(session_bggray.png) repeat-x 0 0; }
                            table.credits tbody .session h2 { font-size:1em; margin-bottom:0; color:rgb(0, 136, 204); }
                            table.credits tbody .session .hud-content { display:none; }
                            
                            td.right
                            {
                                border-right:1px solid #ccc;
                            }
                            
                            
                            
                            blockquote.style1 
                            {
                                
                            padding: 8px;
                                
                            width: 80%;
                                
                                background-color: #eeeeee;
                            border: 1px solid #dddddd;
                                
                                
                            margin: 5px;
                                background-image: url(../quake2/images/openquote1.gif);
                                background-position: top left;
                                background-repeat: no-repeat;
                                text-indent: 23px;
                                
                            }
                            
                            blockquote.style1 span 
                            {
                            display: block;
                                font-style:italic;
                                background-image: url(../quake2/images/closequote1.gif);
                                background-repeat: no-repeat;
                                background-position: bottom right;
                                text-align: justify;
                            }
                            
                            
                            
                            
                            
                            </style> 
                        
			
                            Like every id Software engine the maps generated by the design team were heavily preprocessed by a tool in order to increase performances at runtime.<br/>
                            <br/>
                            For idTech4 the tool is named <code>dmap</code> and its goal is to read a soup of polyhedron from a <code>.map</code> file, identify areas connected by inter-area-portals and save those in a <code>.proc</code> file.<br/>
    <br/>
                            
The goal is to power the runtime portal system of <code>doom3.exe</code>. There is an amazing paper from 1992 by Seth Teller: <a href="http://people.csail.mit.edu/seth/pubs/">"Visibility Computations in Densely Occluded Polyhedral environment"</a> : It describes well how idTech4 works with many explanatory drawings.
                            </p>
<div style="clear:both;"></div>                                            
			

	
			
	<h2>The editor</h2>		
	<p id="paperbox">	
    Designers produce level maps via CSG (Constructive Solid Geometry): They use polyhedrons that usually have 6 faces and place them on the map.<br/>
    Those blocks are called brushes and the following drawing shows 8 brushes used (I use the same map to explain each step in <code>dmap</code>).<br/>
    <br/>
    A designer may have a good idea of what is "inside" (on the left) but <code>dmap</code> receives a brushes soup where nothing is inside and nothing is outside (on the right).<br/><br/>
    
    <table>
       <tr>
        <td style="text-align:center;">Designer view</td>
        <td style="text-align:center;"><code>Dmap</code> view as brushes are read from the <code>.map</code> file.</td>
       </tr>
       <tr>
        <td>
	<img style="width:466px; height: 319px ; display:inline;  margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_editor_view.png"/>
        </td>
        <td>
    <img style="width:466px; height: 319px ; display:inline;  " src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_dmap_view.png"/>
        </td>
      </tr>
    </table>
    <br/>
    <br/>
    <img style="width:360px; height: 211px ; display:inline; float:left ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_brush.png"/>
    A brush is not defined via faces but by its planes. It may seem very inefficient to give planes instead of faces but it is very helpful later when checking if two faces are on the same plane. There is no inside or outside since the planes are not oriented "consistently". The planes orientation can point outside or inside the volume indifferently.</br>
    <br/>
    
    <div style="clear:both;"></div>
	</p>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <h2>Code overview</h2>		
	<p id="paperbox">	
    Dmap source code is very well commented, just look at the amount of green: There is more comments than code !
    <pre class="long">
                                                                      
                                                                      
     <span style="color:blue;">bool</span> ProcessModel( uEntity_t *e, <span style="color:blue;">bool</span> floodFill ) {
     
     bspface_t        *faces;
     
     <span style="color:green;">// build a bsp tree using all of the sides</span>
     <span style="color:green;">// of all of the structural brushes</span>
     faces = MakeStructuralBspFaceList ( e->primitives );
     e->tree = FaceBSP( faces );
     
     <span style="color:green;">// create portals at every leaf intersection</span>
     <span style="color:green;">// to allow flood filling</span>
     MakeTreePortals( e->tree );
     
     <span style="color:green;">// classify the leafs as opaque or areaportal</span>
     FilterBrushesIntoTree( e );
     
     <span style="color:green;">// see if the bsp is completely enclosed</span>
     <span style="color:blue;">if</span> ( floodFill && !dmapGlobals.noFlood ) {
       <span style="color:blue;">if</span> ( FloodEntities( e->tree ) ) {
         <span style="color:green;">// set the outside leafs to opaque</span>
         FillOutside( e );
       } else {
         common->Printf ( <span style="color:red;">"**********************\n"</span> );
         common->Warning( <span style="color:red;">"******* leaked *******"</span> );
         common->Printf ( <span style="color:red;">"**********************\n"</span> );
         LeakFile( e->tree );
         <span style="color:green;">// bail out here.  If someone really wants to</span>
         <span style="color:green;">// process a map that leaks, they should use</span>
         <span style="color:green;">// -noFlood</span>
         return false;
       }
     }
     
     <span style="color:green;">// get minimum convex hulls for each visible side</span>
     <span style="color:green;">// this must be done before creating area portals,</span>
     <span style="color:green;">// because the visible hull is used as the portal</span>
     ClipSidesByTree( e );
     
     <span style="color:green;">// determine areas before clipping tris into the</span>
     <span style="color:green;">// tree, so tris will never cross area boundaries</span>
     FloodAreas( e );
     
     <span style="color:green;">// we now have a BSP tree with solid and non-solid leafs marked with areas</span>
     <span style="color:green;">// all primitives will now be clipped into this, throwing away</span>
     <span style="color:green;">// fragments in the solid areas</span>
     PutPrimitivesInAreas( e );
     
     <span style="color:green;">// now build shadow volumes for the lights and split</span>
     <span style="color:green;">// the optimize lists by the light beam trees</span>
     <span style="color:green;">// so there won't be unneeded overdraw in the static</span>
     <span style="color:green;">// case</span>
     Prelight( e );
     
     <span style="color:green;">// optimizing is a superset of fixing tjunctions</span>
     <span style="color:blue;">if</span> ( !dmapGlobals.noOptimize ) {
        OptimizeEntity( e );
     } <span style="color:blue;">else  if</span> ( !dmapGlobals.noTJunc ) {
        FixEntityTjunctions( e );
     }
     
     <span style="color:green;">// now fix t junctions across areas</span>
     FixGlobalTjunctions( e );
     
     <span style="color:blue;">return true</span>;
     }
                                                                      
                                                                      
</pre>




<br/>


</p>

                            
                            <h2>0. Loading the level geometry</h2>		
                            <p id="paperbox">
                            A <code>.map</code> file is a list of entities. The level is the first entity in the file and has  a "worldspawn" class. An entity contains a list of primitives that are almost always brushes. The remaining entities are lights, monsters, player spawning location, weapons etc ...<br/>
<pre class="long">

   Version 2
                            
    <span style="color:green;">// entity 0</span>
    {
        <span style="color:red;">"classname" "worldspawn"</span>
        <span style="color:green;">// primitive 0</span>
        {
            brushDef3
            {
                ( <span style="color:blue;">0 0 -1 -272</span> ) ( (<span style="color:blue;"> 0.0078125 0 -8.5</span> ) (<span style="color:blue;"> 0 0.03125 -16</span> ) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
                ( <span style="color:blue;">0 0 1 -56 </span>  ) ( (<span style="color:blue;"> 0.0078125 0 -8.5</span> ) (<span style="color:blue;"> 0 0.03125 16 </span> ) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
                ( <span style="color:blue;">0 -1 0 -3776</span>) ( (<span style="color:blue;"> 0.0078125 0 4  </span>  ) (<span style="color:blue;"> 0 0.03125 0 </span>  ) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
                ( <span style="color:blue;">-1 0 0 192</span>  ) ( (<span style="color:blue;"> 0.0078125 0 8.5</span>  ) (<span style="color:blue;"> 0 0.03125 0 </span>  ) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
                ( <span style="color:blue;">0 1 0 3712</span>  ) ( (<span style="color:blue;"> 0.006944  0 4.7</span>  ) (<span style="color:blue;"> 0 0.034   1.90</span>) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
                ( <span style="color:blue;">1 0 0 -560</span>  ) ( (<span style="color:blue;"> 0.0078125 0 -4 </span>  ) (<span style="color:blue;"> 0 0.03125 0 </span>  ) ) <span style="color:red;">"textures/base_wall/stelabwafer1"</span><span style="color:blue;"> 0 0 0</span>
            }
        }
        <span style="color:green;">// primitive 1</span>
        {
           brushDef3
        }
        <span style="color:green;">// primitive 2</span>
        {
            brushDef3
        }        
    }    
    .
    .
    .
   <span style="color:green;">// entity 37</span>
   {
        <span style="color:red;">"classname" "light"
        "name" "light_51585"
        "origin" "48 1972 -52"
        "texture" "lights/round_sin"
        "_color" "0.55 0.06 0.01"
        "light_radius" "32 32 32"
        "light_center" "1 3 -1"</span>
   }
                        
                            

</pre>
      <p>                      
                            Each brush is described as a set of planes. The sides of a brush are called faces (also called windings) and each is obtained 
                            by clipping a plane with every other planes in the brush.<br/>
                            <br/>
     <u><b>Note :</b></u> During the loading phase a really neat and fast "Plane Hashing System" is used: <code>idPlaneSet</code> built on top of a 
     <code>idHashIndex</code> it is really worth taking a look at it.
                            </p>
                            
                            

<h2>1. MakeStructuralBspFaceList & FaceBSP</h2>
<p id="paperbox">
                            The first step is to slice the map via Binary Space Partition. Every single non transparent faces in the map wil be used as splitting plane.<br/>
                            <br/>
                            The heuristic to select a splitter is:<br/>
                            <br/>
                            <b>1 :</b> If the map is more than 5000 units: Slice using an Axis Aligned Plane in the middle of the space. In the following drawing a 6000x6000 space is sliced three times.</br>
                            <img style="width:732px; height: 313px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_bsp_heuristic.png"/>
                            <br/>
                                <b>2 :</b> When there is no more parts bigger than 5000 units: Use the faces marked as "portal" (they have material <code>textures/editor/visportal</code>). In the following drawing the portal brushes are in blue.<br/>
                            
                            <img style="width:937px; height: 441px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/bsp_building.png"/><br/>

                            <b>3 :</b> Finally use the remaining faces. Select the face that is collinear to the most other planes AND split the less faces ; Also try to favor axial splitters. The splitting planes are marked in red.<br/>
                            
                            <img style="width:984px; height: 362px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_bsp_building.png"/>
                            
                            <img style="width:984px; height: 362px ; margin-right: 20px;" src="../lazyb_load/grey.gif" data-original="/fd_proxy/doom3/dmap_bsp_building2.png"/>
                            <br/><br/>
                                The process stops when no more faces are available: The BSP tree leaf all represent a convex subspace:<br/>
                            <br/>
                            <img style="width:970px; height: 351px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_bsp_building3.png"/>
</p>


<br/>
<br/>
<h2>2. MakeTreePortals</h2>
<p id="paperbox">
The map is now divided into convex subspaces but those subspaces have no awareness of each other. The goal of this step is to connect each leaf to its neighbors 
by creating portals automatically. The idea is to start with six portals boundering the map: The connect "outside" to "inside" (the root of the BSP). Then 
for each nodes int the BSP: split each portal in the node, add the splitting plane as portal and recurse.<br/>                            
                             <img style="width:984px; height: 401px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_portal_building.png"/>
                            <br/><br/>
                             <img style="width:568px; height: 560px ; margin-right: 20px; display:block; float:left;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/portal_propagation.png"/>
                             <br/><br/><br/>
                            The original six portals are going to be split and propagated all the way down to the leafs. 
    This is not as trivial as it seems since each time a node is split: Every portals it is connected to must also be split.<br/>
    <br/>In the drawing on the left one portal is connecting two BSP sibling nodes. Upon following the left child its splitting plane cut the portal in two. We can see that the other node portals must also be updated so they don't connect to a sibling anymore but to its "nephews".
    
                            
                            <div style="clear:both;"></div>
                            <br/>
                            <br/>
                            At the end of the process the six original portals have been split in hundreds of portals and new portals have been created on the splitting planes:
                            Each leaf in the BSP has gained awareness of its neighbors via a linked list of portals connecting it to 
    leafs sharing an edge:</br>
                             <img style="width:960px; height: 412px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap_portal_building2.png"/>
</p>

<h2>3. FilterBrushesIntoTree</h2>

<p id="paperbox">
<img style="width:350px; height: 343px ; display:block;  margin-right: 20px; float: left;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/shapesorter.jpeg" class="shadowed"/>   
This step works like a game of Shape Sorter with the BSP being the board and the brushes being the shapes. Each brush is sent down the BSP in order
to discover which leafs are <b>opaque</b>.<br/>
<br/>This work because of a well defined heuristic: If a brush is crossing a splitting plane a little
but not more than EPSILON then it is not split. Instead it is sent all together on the plane side where all the other elements of the brush are. <br/>
<br/>
Now "inside" and "outside" are starting to be visible.
<div style="clear:both;"></div>    
    

    <br/><br/>A leaf hit by a brush is considered opaque (solid) and is hence marked accordingly.<br/>
<img style="width:900px; height: 377px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/post_filter.png"/>


</p>



<h2>4. FloodEntities & FillOutside</h2>

<p id="paperbox">
    
    <br/><br/>
    Using a player spawning entity a floodfill algorithm is triggered from each leaf. It mark leafs reachable by entities.<br/>
    <img style="width:900px; height: 377px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/floodEntities.png"/>
    <br/><br/>
    The final step FillOutside go through each leaf and if it is not reachable mark it as <b>opaque</b>. <br/>
    <img style="width:900px; height: 377px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/post_FillOutside.png"/><br/>
    <br/>
    We now have a level where each subspace is either reachable or opaque: Navigation via leaf portals can now be consistent by checking if the target leaf is opaque or not.
</p>

<br/>
<br/>
<h2>5. ClipSidesByTree</h2>

<p id="paperbox">
        It is now time to discard useless parts of the brushes: Each original brush side is now sent down the BSP. 
        If a side is within an opaque space then it is discarded. 
        Otherwise it is added to the side's <code>visibleHull</code> list.<br/>
        <br/>
        This result in a "skin" of the level, only visible parts are kept.
    <br/><br/>
    <img style="width:537px; height: 377px ; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/dmap/only_skin_remaining.png"/>
    <br/>
    <br/>
    From this point only side's <code>visibleHull</code> are considered for the remaining operations.
</p>


<br/>
<br/>
<h2>6. FloodAreas</h2>

<p id="paperbox">
            Now <code>dmap</code> group leafs together with area IDs: For each leaf a floodfilling algorithm is triggered. It tries to flow everywhere using portals associated to the leaf.<br/>
            <br/>
            This is where the designer work is <u>tremendously important</u>: Areas can be identified only if visportals (the portal brushes mentioned in Step 1) were manually placed on the map. Without them <code>dmap</code> will identify only one area and the entire map will be sent to the GPU each frame.<br/>
    <br/>
The Floodfilling recursive algorithm is stopped only by areaportals and opaque nodes. In the following drawing an automatically generated portal (in red) will allow flood but a designer placed visportal (in blue, also called areaportal ) will stop it, making two areas:<br/>
                
    <img style="width:895px; height: 252px ; display:block; " src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/FloodAreas/FloodAreas.png"/><br/>

    <img style="width:895px; height: 252px ; display:block;  " src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/FloodAreas/FloodAreas2.png"/><br/>
<br/>
    At the end of the process each non opaque leaf belongs to an area and the inter-area-portals (in blue) have been identified.
    <img style="width:895px; height: 252px ; display:block; " src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/FloodAreas/FloodAreas3.png"/><br/>


</p>









<br/>
<br/>
<h2>7. PutPrimitivesInAreas</h2>

<p id="paperbox">
This step combines the areas identified in Step 6 and the visibleHull calculated in Step 5 in an other "Shape Sorter" game: This time the board is the areas and the shapes are the visibleHull.<br/>
    <br/>
An array of areas is allocated and each visibleHull of each brush is sent down the BSP: Surfaces are added to the area array at index areaIDs.<br/>
        <br/>

<br/>
<b><u>Note :</u></b> Pretty clever, this step will also optimize entity spawning. If some entities are marked "func_static" they are instantiated now and associated to an area.
This is a way to "melt" boxes, barrels,chairs into an area (also have its shadow volume pre-generated).


</p>













<br/>
<br/>
<h2>8. Prelight</h2>
<p id="paperbox"> 
For each static light <code>dmap</code> pre-calculate the shadow volumes geometry. Those volumes are later saved in the <code>.proc</code> as it. The only trick is
that shadow volumes are saved with a name <code>"_prelight_light"</code> concatenated to the light ID so the engine can match the light from the <code>.map</code> file and the shadow volume from the <code>.proc</code> file:
<pre class="long"> 


      shadowModel { <span style="color:green;">/* name = */</span> <span style="color:red;">"_prelight_light_2900"</span>

      <span style="color:green;">/* numVerts = */</span> 24 <span style="color:green;">/* noCaps = */</span> 72 <span style="color:green;">/* noFrontCaps = */</span> 84 <span style="color:green;">/* numIndexes = */</span> 96 <span style="color:green;">/* planeBits = */</span> 5
   
     ( -1008 976 183.125 ) ( -1008 976 183.125 ) ( -1013.34375 976 184 ) ( -1013.34375 976 184 ) ( -1010 978 184 ) 
     ( -1008 976 184 ) ( -1013.34375 976 168 ) ( -1013.34375 976 168 ) ( -1008 976 168.875 ) ( -1008 976 168.875 ) 
     ( -1010 978 168 ) ( -1008 976 167.3043518066 ) ( -1008 976 183.125 ) ( -1008 976 183.125 ) ( -1010 978 184 ) 
     ( -1008 976 184 ) ( -1008 981.34375 184 ) ( -1008 981.34375 184 ) ( -1008 981.34375 168 ) ( -1008 981.34375 168 ) 
     ( -1010 978 168 ) ( -1008 976 167.3043518066 ) ( -1008 976 168.875 ) ( -1008 976 168.875 ) 
  
     4 0 1 4 1 5 2 4 3 4 5 3 0 2 1 2 3 1 
     8 10 11 8 11 9 6 8 7 8 9 7 10 6 7 10 7 11 
     14 13 12 14 15 13 16 12 13 16 13 17 14 16 15 16 17 15 
     22 21 20 22 23 21 22 18 19 22 19 23 18 20 21 18 21 19 
     1 3 5 7 9 11 13 15 17 19 21 23 4 2 0 10 8 6 
     16 14 12 22 20 18 
     }

  
</pre>
</p>













<br/>
<br/>
<h2>9. FixGlobalTjunctions</h2>

<p id="paperbox"> 
Fixing TJunction is usually important in order to avoid visual artefacts but this is even more important in idTech4:
The geometry is also used to generated the shadow while writing to the stencil buffer. T-Junctions are twice as annoying.
</p>



    <br/>
    <br/>
    <h2>10. Write output</h2>
    <p id="paperbox"> </p>
    In the end all this preprocessing is saved to a <code>.proc</code> file:
    <ul>
       <li>For each area a set of surface faces grouped by material.</li>
       <li>The BSP Tree with areaID for leafs.</li>
       <li>Inter-area-portals winding.</li>
       <li>Shadow Volumes.</li>
    </ul>
    <br/>
    <br/>
    <h2>History</h2>
    
    <p id="paperbox"> 
    Many code segments from <code>dmap</code> feature similarities with <a href="https://github.com/id-Software/Quake-III-Arena/blob/master/q3map/bsp.c#LC67">code found in the preprocessing tools of Quake (<code>qbsp.exe</code>), Quake 2 (<code>q2bsp.exe</code>) or Quake (<code>q3bsp.exe</code>)</a>. That's because the Potentially visible Set was generated via a temporary portal system:<br/>
        <ul>
          <li><code>qbsp.exe</code> read a <code>.map</code> and generated a <code>.prt</code> file that contained connectivity information between leafs in the BSP: Portals (exactly like Step2. MakeTreePortals).</li> 
        <li><code>vis.exe</code> used the <code>.prt</code> as input. For each leaf: </li>
           <ul>
            <li>fillFlood into connected leaf using portals.</li>
            <li>Before flooding into a leaf: Test for visibility by clipping the next portal with the two previous portal anti view frustrum (many people claimed that visibility was done by casting thousands of rays but this is a myth that many still believe nowadays).</li>
           </ul>
        </ul>
        <p>
                A drawing is always better: Let's say <code>qbsp.exe</code> identified 6 leafs connected by portals and now <code>vis.exe</code> is running to generate the PVS. This process will be executed for each leaf but this example focus exclusively on leaf 1.<br/>
                <br/><br/>
                <br/>
                <img style="width:362px; height: 391px ;  float: left; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/qbsp_explained.png"/>
                
                Since a leaf is always visible by itself the initial PVS for leaf 1 is as follow:<br/>
                    <br/>
                    <table style="width:50%;" class="credits" cellspacing="0" cellpadding="0" border="0" >
                    <tr>
                    <td>Leaf ID</td>
                    <td>1</td>
                    <td>2</td>
                    <td>3</td>
                    <td>4</td>
                    <td>5</td>
                    <td>6</td>
                    </tr>
                    <tr>
                    <td>Bit vector (PVS for leaf 1)</td>
                    <td>1</td>
                    <td>?</td>
                    <td>?</td>
                    <td>?</td>
                    <td>?</td>
                    <td>?</td>
                    </tr>
                    </table></br>
                    </br>
                    The floodFilling algorithm starts: The rule is that as long as we don't have two portals in the path, the leaf is considered visible from the starting point. This means we reach leaf3 with the following PVS:<br/>
                    <br/>
                    <br/>
                    <table style="width:50%;" class="credits" cellspacing="0" cellpadding="0" border="0" >
                    <tr>
                    <td>Leaf ID</td>
                    <td>1</td>
                    <td>2</td>
                    <td>3</td>
                    <td>4</td>
                    <td>5</td>
                    <td>6</td>
                    </tr>
                    <tr>
                    <td>Bit vector (PVS for leaf 1)</td>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                    <td>?</td>
                    <td>?</td>
                    <td>?</td>
                    </tr>
                    </table></br>
                    </br>

                    </br>
                    
                    
                    </br>
                    <div style="clear:both;"></div> 
                    
                    
                    
                  
                <div style="clear:both;"></div> 
                    <br/></br>
                    <p>
                <img style="width:362px; height: 391px ;  float: left; margin-right: 20px;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/qbsp_explained_test.png"/>
                    Once in the leaf3 we can actually start checking for visibility:<br/><br/> By taking two points form the portal n-2 and the portal n-1 we can generate clipping planes and test if the next portals are potentially visible.<br/>
                        <br/>
                        In the drawing the can see that portals leading to leaf 4 and 6 will fail the tests while portal toward 5 will succeed. The floorFilling algorithm will then recurse to leaf6.
                    In the end the PVS for leaf 1 will be:<br/>
                        <br/>
                        <br/>
                        <table  style="width:50%;" class="credits" cellspacing="0" cellpadding="0" border="0" >
                        <tr>
                        <td>Leaf ID</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        </tr>
                        <tr>
                        <td>Bit vector (PVS for leaf 1)</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        </tr>
                        </table></br>
                        
                        <div style="clear:both;"></div> <br/>
        <br/>
                        <p>
        In idTech4 the PVS is not generated, instead the portal data is conserved. The visibility of each area is computed at runtime by projecting the portal windings into screen space and clipping them against each others.
        <br/><br/>
        <u><b>Trivia :</b></u> Michael Abrash explained this entire process in 10 seconds and a sharpie in this excellent video from GDC Vault:<br/>
        <br/>
        <video style="display:block; margin-left: auto; margin-right: auto;" width="50%" src="Excerpt_&#32;Quake&#32;Postmortem&#32;-&#32;Optimizing&#32;Level&#32;Viewing.mp4" controls="true" type="video/mp4" poster="abrash_pvs.png"></video>

        </p>





<br/>
<br/>
<h2>Recommended readings</h2>
<p id="paperbox"> 
The great article by Sean Barret: <a href="http://nothings.org/gamedev/thief_rendering.html">The 3D Software Rendering Technology of 1998's Thief: The Dark Project</a> mentions Seth Teller's 1992 thesis work in three parts; "Visibility Computations for Global Illumination Algorithms, " :
A lot can be read about visibility precomputation, virtual light sources, portals, portal sequence, gross/fine culling, general observer and visible supersets.<br/>
<br/>

<a href="http://people.csail.mit.edu/seth/pubs/part1.pdf">
<img style="box-shadow: 3px 3px 7px #777; width:206px; height:245px ; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/Seth_Teller_1992_thesis.png" />
</a>
<a href="http://people.csail.mit.edu/seth/pubs/part2.pdf">
<img style="box-shadow: 3px 3px 7px #777; width:206px; height:245px ; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/Seth_Teller_1992_thesis2.png" />
</a>
<a href="http://people.csail.mit.edu/seth/pubs/part3.pdf">
<img style="box-shadow: 3px 3px 7px #777; width:206px; height:245px ; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/Seth_Teller_1992_thesis3.png" />
</a>
<br/>
<br/>
Michael Abarash Graphic Programming Black Book: The <a href="http://www.phatcode.net/res/224/files/html/ch60/60-02.html">
chapter 60 </a> is pure gold when it comes to explain how to split a segment with a plane.<br/>
<br/>
<img style=" width:196px; height: 245px ;" src="../lazy_load/grey.gif" data-original="../quake2/BlackBookGfxProg.png" /><br/>
<br/>
The proof to the spliting segment formula is in "Computer Graphics: Principles and Practice":<br/>
<br/>
<img style=" width:196px; height: 290px ;box-shadow: 3px 3px 7px #777;" src="../lazy_load/grey.gif" data-original="compGraph.png" /><br/>
<br/>
More about T-Junction fixing in "Mathematics for 3D Game Programming and Computer Praphics":<br/>
<br/>
<img style=" width:196px; height: 247px ;box-shadow: 3px 3px 7px #777;" src="../lazy_load/grey.gif" data-original="cg.png" /><br/>
<br/>
</p>


		
        
        <!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

