<script type="text/javascript">
  var disqus_identifier = "doom3" ;
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Doom3 Source Code Review, id tech4"/>
		<meta name="Description" content="Doom3 Source Code Review"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
	
 	
		
		<title>Doom3 Source Code Review: Renderer</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       June 8, 2012</div>
   <h1>Doom3 Source Code Review: Renderer (Part 3 of 6) <a href="profiling.php">>></a></h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="icons/doom3_icon_desaturated.png" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         		

	

        <script src="js/jquery.rs.slideshow.js"></script>
        <link rel="stylesheet" href="css/style.css" />
idTech4 renderer features three key innovations:
<ul>
<li>"Unified Lighting and Shadows": The level faces and the entities faces go through the same pipeline and shaders.</li>
<li>"Visible Surface Determination": A portal system allows VSD to be performed at runtime: No more PVS.</li>
<li>"Multi-pass Rendering".</li>
</ul>
<Br/>
<p>
By far the most important is that idTech4 is a multi-pass renderer. The contribution of each light in the view is accumulated in the GPU framebuffer via additive blending.
Doom 3 takes full advantage of the fact that color framebuffer registers saturate instead of wrapping around.
<pre class="long">


    CPU register (wrap around) : 
    ============================

      1111 1111
    + 0000 0100
      ---------
    = 0000 0011


    GPU register ( saturate) : 
    ==========================

      1111 1111
    + 0000 0100
    ---------
    = 1111 1111


</pre>
<p>
<br/><br/><br/>
I build a custom <a href="../fd_proxy/doom3/additive_blending/lights.map">level</a> to illustrate additive blending. The following screenshot shows three lights in a room resulting in three passes with the result of each pass accumulated in the framebuffer. Notice the white illumination at the center of the screen where all lights blend together .<br/>
<br/>
<img style="width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/additive_blending/allLights.jpg"/><br/>
<br/>





I modified the engine in order to isolate each light pass, they can be viewed using the left and right arrows:<br/> 
<div class="rss-container">
  <div id="slideshow-0" class="rs-slideshow">
   <div class="slide-container">
    <img src="../fd_proxy/doom3/additive_blending/blue_light.jpg"  title="Pass 1: Blue light" />
    <span class="slide-caption">Pass 1: Blue light</span>
   </div>
   <ol class="slides">

    <li>
<a href="../fd_proxy/doom3/additive_blending/blue_light.jpg" title="Pass 1: Blue light">Pass 1: Blue light</a>
    </li>

    <li>
    <a href="../fd_proxy/doom3/additive_blending/green_light.jpg" title="Pass 2: Green light">Pass 2: Green light</a>
    </li>

    <li>
    <a href="../fd_proxy/doom3/additive_blending/red_light.jpg" title="Pass 3: Red light">Pass 3: Red light</a>
    </li>
   </ol>
   </div>
</div>

<script language="javascript">
$(document).ready(function () {
                  
                  var opts = {
                  controls: {
                  //playPause: {auto: true},
                  previousSlide: {auto: true},
                  nextSlide: {auto: true},
                  index: {auto: true},
                  
                  },
                  interval : 600
                  };
                  $('#slideshow-0').rsfSlideshow(opts);
                  
                  });
</script>
<br/>
<br/>


I modified the engine further in order to see the framebuffer state AFTER each light pass. Use left and right arrow to move in time.
<div class="rss-container">

<div id="slideshow-4" class="rs-slideshow">
<div class="slide-container">
<img src="../fd_proxy/doom3/additive_blending/green_light.jpg" alt="GPU Framebuffer after the first pass." title="GPU Framebuffer after the first pass." />
<span class="slide-caption">GPU Framebuffer after the first pass.</span>
</div>
<ol class="slides">

<li>
<a href="../fd_proxy/doom3/additive_blending/green_light.jpg" 
title="GPU Framebuffer after the first pass.">GPU Framebuffer after the first pass.</a>
</li>

<li>
<a href="../fd_proxy/doom3/additive_blending/green_red_light.jpg" 
title="GPU Framebuffer after the second pass.">GPU Framebuffer after the second pass.</a>
</li>

<li>
<a href="../fd_proxy/doom3/additive_blending/allLights.jpg" 
title="GPU Framebuffer after the third pass." 
data-link-to="http://reallysimpleworks.com">GPU Framebuffer after the third pass.</a>
</li>
</ol>
</div>

</div>


<script language="javascript">
$(document).ready(function () {
                  
                  var opts = {
                  controls: {
                  //playPause: {auto: true},
                  previousSlide: {auto: true},
                  nextSlide: {auto: true},
                  index: {auto: true},
                  
                  },
                  interval : 600
                  };
                  $('#slideshow-4').rsfSlideshow(opts);
                  
                  });
</script>


<br/><br/><br/>
<u><b>Trivia : </b></u> It is possible to take the result of each light pass, blend them manually with photoshop (Linear Dodge to mimic OpenGL additive blending) and reach the  <a href="../fd_proxy/doom3/additive_blending/lights.psd">exact same visual result</a>.
<br/>
<br/>

Additive blending combined to support of shadows and bumpmapping resulted in an engine that can still produce very nice result even by 2012 standards:<br/>
<br/>
<img style="box-shadow: 3px 3px 7px #777; width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" 
src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/doom3_legendary_scene.png"/><br/>
<br/>
<br/>



		
			
		
	
	
	
	
	
	
	
	
	
	
	
	
	<h2>Architecture</h2>
	<p id="paperbox">
	The renderer is not monolithic like previous idTech engines but rather broken down in two parts called Frontend and Backend:
	<ul>
		<li>Frontend:</li>
		<ol>
			<li>Analyze world database and determine what contributes to the view.</li>
            <li>Store the result in an Intermediate Representation (<code>def_view_t</code>) and upload/reuse cache geometry in the GPU's VBO.</li>
			<li>Issue a RC_DRAW_VIEW command.</li>
		</ol>
		<li>Backend:</li>
		<ol>
			<li>The RC_DRAW_VIEW wakes up the backend.</li>
            <li>Use the Intermediate Representation as input and issue commands to the GPU using the VBOs.</li>
		</ol>	
	</ul>
	<Br/><Br/>
    
<img style="width:900px; height: 237px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/fb_design_renderer.png"/><br/>
<br/>
<br/>
<p>
The architecture of the renderer draws a striking similarity with <a href="http://en.wikipedia.org/wiki/LCC_(compiler)">LCC the retargetable compiler</a> that was used to generate the Quake3 Virtual Machine bytecode:
<br/>
<br/>
<img style="width:900px; height: 237px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/fb_design_compiler.png"/><br/>
<br/>
<br/>
<p>
I initially thought the renderer design as influenced by LCC design but the renderer is built in two parts because it was <a href="interviews.php#qrenderer">meant to be multi-thread</a> on SMP systems. The front-end would run on one core and the back-end on an other core. Unfortunately due to instability on certain drivers the extra thread had to be disabled and  both ends run on the same thread.<br/>
<br/>
	
<u><b>Genesis trivia :</b></u> Archelology can be done with code as well: If you look closely at the unrolled code renderer (<a href="renderer.php#frontend_unrolled">frontend</a>,<a href="renderer.php#back_unrolled">backend</a>) you can clearly see that the engine switches from C++ to C (from objects to static methods):<br/>
	<br/>
	This is due to the genesis of the code. idTech4 renderer was written by John Carmack using Quake3 engine (C codebase) before
	he was proficient in C++. The renderer was later integrated to the idtech4 C++ codebase.<br/>
<br/>
How much Quake is there in Doom3 ? Hard to tell but it is funny to see that the main method in the Mac OS X version is:
<br/>
<pre class="long">


   - (void)quakeMain;


</pre>
	</p>	
			
			
			
	
	
	
	
	
		
<br/>
<h2>Frontend/Backend/GPU collaboration</h2>
<p id="paperbox">
Here is a drawing that illustrate the collaboration between the frontend, the backend and the GPU:<br/>
<br/>
<img style="width:830px; height: 436px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/rendere_big_picture.png"/><br/>
<ol>
   <li>The Frontend analyzes the world state and issues two things:
       <ul>
          <li>An <b>intermediate representation</b> containing a list of each light contributing to the view. Each light contains a list of the entity surfaces interacting with it.</li>
          <li>Each light-entity interaction that is going to be used for this frame is also cached in a <b>interaction table</b>. Data is usually uploaded to a GPU VBO.</li>
       </ul>
    <li>The Backend takes the <b>intermediate representation</b> as input. It goes through each lights in the list and makes OpenGL draw calls for each entity that interact with the light. The draw command obviously reference the VBO and textures.</li>
    <li>The GPU receives the OpenGL commands and render to the screen.</li>
</ol>
</p>
	
	
	


	
	
	
	
	

	
	
	
	
	

	
	
	
	
	
	<br/>
	<h2>Doom3 Renderer Frontend</h2>
	<p id="paperbox">
The frontend performs the hard part: Visible Surface Determination (VSD). The goal is to find every light/entity combination affecting the view.
Those combinations are called <b>interactions</b>. Once each interaction have been found the frontend makes sure everything needed by the backend
is uploaded to the GPU Ram (it keeps track of everything via an "interaction table"). The last step is to generate an <b>Intermediate representation</b>
that will be read by the backend so it can generate OpenGL Commands.<br/>
<br/>
In the code this is how it looks:<br/>
<pre class="long" id="frontend_unrolled">
	
	
  - idCommon::Frame
   - idSession::UpdateScreen
     - idSession::Draw
       - idGame::Draw
         - idPlayerView::RenderPlayerView
           - idPlayerView::SingleView
             - idRenderWorld::RenderScene
                - build params
                - ::R_RenderView(params)    <span style="color:green;">//This is the frontend</span>
                  {
                      R_SetViewMatrix
                      R_SetupViewFrustum
                      R_SetupProjection
              
                      <span style="color:green;">//Most of the beef is here.</span>
                      static_cast&lt;idRenderWorldLocal *&gt;(parms->renderWorld)->FindViewLightsAndEntities()
                      {
                          PointInArea              <span style="color:green;">//Walk the BSP and find the current Area</span>
                          FlowViewThroughPortals   <span style="color:green;">//Recursively pass portals to find lights and entities interacting with the view.</span>
                      }
              
                      R_ConstrainViewFrustum     <span style="color:green;">//Improve Z-buffer accuracy by moving far plan as close as the farthest entity.</span>
                      R_AddLightSurfaces         <span style="color:green;">// Find entities that are not in a visible area but still casting a shadow (usually enemies)</span>
                      R_AddModelSurfaces         <span style="color:green;">// Instantiate animated models (for monsters)</span>
                      R_RemoveUnecessaryViewLights
                      R_SortDrawSurfs            <span style="color:green;">// A simple C qsort call. C++ sort would have been faster thanks to inlining.</span>       
                      R_GenerateSubViews
                      R_AddDrawViewCmd 
                  }
              
             
             
</pre> 
<p>
<u><b>Note :</b></u> The switch from C to C++ is obvious here.<br/>
<br/>
<br/>
Iti s alwasy easier to understand with a drawing so here is a level: Thanks for the designer's visplanes the engine sees four areas:<br/>
<img style="width: 620px; height:  357px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/renderer_room.png"/><br/>
<br/>
Upon loading the <code>.proc</code> the engine also loaded the <code>.map</code> containing all the lights and moving entities definitions. 
For each light the engine has built a list of each area impacted:<br/>
<br/>
<div>
<img style="width:618px; height: 365px ; display:inline;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/renderer_room_light.png"/>

<pre class="long" style="margin-top:20px; margin-right:110px;width:25%;float:right;">


   Light 1 :
   =========

        - Area 0
        - Area 1

   Light 2 :
   =========

        - Area 1
        - Area 2
        - Area 3


</pre>
</div>
<div style="clear:both;"></div>
<br/>
<br/>
<br/>
At runtime we now have a player position and monsters casting shadows. For scene correctness, all monsters and shadow must be found.
<br/>
<img style="width:620px; height: 370px ; display:block; margin-left: auto; margin-right: auto;" src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/renderer_room_light_entities.png"/><br/>
<br/>
Here is the process:
<ol>
  <li>Find in which area the player is by walking the BSP tree in <code>PointInArea</code>.</li>
<li><code>FlowViewThroughPortals</code> : Starting from the current area floodfill into other visible area using portal system. 
Reshape the view frustrum each time a portal is passed: This is beautifully explained in the <a href="
http://www.realtimerendering.com/">Realtime rendering</a> book bible:<br/><br/>
<img style="width:690; height: 458; box-shadow: rgb(119, 119, 119) 3px 3px 7px; margin-left: auto; margin-right: auto; display: block; " src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/frustrum_portal_division.png"><br/>
<br/>

. Now we have a list of every lights contributing to the screen and <u>most</u> entities which are stored in the Interaction table:<br/>
<br/>
    <pre class="long">


   Interaction table (Light/Entity) :
   ==================================

       Light 1 - Area    0
       Light 1 - Area    1
       Light 1 - Monster 1

       Light 2 - Area    1
       Light 2 - Monster 1


    </pre>
<p>
The interaction table is still incomplete: The interaction Light2-Monster2 is missing, the shadow cast by Monster2 would be missing.
</li>
  <li><code>R_AddLightSurfaces</code> will find the entity not in the view but casting shadow by going through each light's area list.<br/>
<br/>
<pre class="long">


   Interaction table (Light/Entity) :
   ==================================

       Light 1 - Area    0
       Light 1 - Area    1
       Light 1 - Monster 1

       Light 2 - Area    1
       Light 2 - Monster 1
       Light 2 - Monster 2

</pre>
<p>
</li>
<li><code>R_AddModelSurfaces</code> : All interaction have been found, it is now time to upload the vertices and indices to the GPU's VBO if they are 
not there already. Animated monster geometry is instantiated here as well (model AND shadow volume)</li>
<li>All "intelligent" work has been done. Issue a <code>RC_DRAW_VIEW</code> command via <code>R_AddDrawViewCmd</code> that will trigger the backend to render to the screen.</li>
</ol>
<br/>







	
	
	
	
	
	
	<br/>
	<h2>Doom3 Renderer Backend</h2>
	<p id="paperbox">
The backend is in charge of rendering the Intermediate Representation while accounting for the limitations of the GPU:  
Doom3 supported five GPU rendering path:
<ul>
   <li>R10 (GeForce256)</li>
   <li>R20 (GeForce3)</li>
   <li>R200 (Radeon 8500)</li>
   <li>ARB  (OpenGL 1.X)</li>
   <li>ARB2 (OpenGL 2.0)</li>
</ul>
<p>
As of 2012 only ARB2 is relevant to modern GPUs: Not only standards provide portability they also increase longevity.<br/>
<br/>
Depending on the card capability idtech4 enabled bump-mapping (<a href="../bumpMapping/index.php">A tutorial</a> about using a hellknight I wrote a few years ago) and specular-mapping but all of them try the hardest to <u>save as much fillrate as possible</u> with:
<br/>
<ul>
    <li>OpenGL Scissor test (specific to each light, generated by the frontend</li>
    <li>Filling the Z-buffer as first step.</li>
    <br/>
The backend unrolled code is as follow:<br/>
<br/>
	<pre class="long" id="backend_unrolled">
	
	
      idRenderSystemLocal::EndFrame
       R_IssueRenderCommands
         RB_ExecuteBackEndCommands
           RB_DrawView
            RB_ShowOverdraw
            RB_STD_DrawView
            {
               RB_BeginDrawingView     <span style="color:green;">// clear the z buffer, set the projection matrix, etc</span>
               RB_DetermineLightScale
               
               RB_STD_FillDepthBuffer  <span style="color:green;">// fill the depth buffer and clear color buffer to black.</span>
               
                <span style="color:green;">// Go through each light and draw a pass, accumulating result in the framebuffer</span>
               _DrawInteractions  
               {
                   5 GPU specific path
                   
                   switch (renderer)
                   {
                      R10  (GeForce256)
                      R20  (geForce3)
                      R200 (Radeon 8500)
                      ARB  (OpenGL 1.X)
                      ARB2 (OpenGL 2.0)
                }
                
                <span style="color:green;">// disable stencil shadow test</span>
                qglStencilFunc( GL_ALWAYS, 128, 255 );

                RB_STD_LightScale
                
                <span style="color:green;">//draw any non-light dependent shading passes (screen,neon, etc...)</span>
                <span style="color:blue;">int</span>  processed = RB_STD_DrawShaderPasses( drawSurfs, numDrawSurfs )   
                
                <span style="color:green;">// fob and blend lights</span>
                RB_STD_FogAllLights();

                <span style="color:green;">// now draw any post-processing effects using _currentRender</span>
                if ( processed < numDrawSurfs ) 
                   RB_STD_DrawShaderPasses( drawSurfs+processed, numDrawSurfs-processed );
	
	                        
             }                
	</pre>
                
<p>

In order to follow the backend steps, I took a famous screen from Doom3 level And I froze the engine at every steps in the rendition : <br/>
<br/>
<img style="box-shadow: 3px 3px 7px #777; width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" 
src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/compo/doom_Scene13.jpg"/><br/>
<br/>
<br/>




                Since Doom3 uses bumpmapping and specular mapping on top of the diffuse texture, to render a surface can take up to 
                3 textures lookup. Since a pixel can potentially be impacted by 5-7 lights it is not crazy to assume 21 textures lookup per
                             pixels..not even accounting for overdraw. The first step of the backend is to reach 0 overdraw: Disable every shaders, write only to the depth buffer and render all geometry:
                <br/>
                <br/>
                <img style="box-shadow: 3px 3px 7px #777; width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" 
                src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/compo/doom_Scene_Z_Buffer.jpg"/>
                <br/>
                <p>The depth buffer is now filled. From now on depth write is disabled and depth test is enabled.<br/>
                <br/>
                <br/>
                Render first to the z-buffer may seem counter-productive at first but it is actually extremely valuable to save fillrate:
                <ul>
                <li>Prevent from running expensive shaders on non-visible surfaces.</li>
                <li>Prevent from rendering non visible shadows to the stencil buffer.</li>
                <li>Since surfaces are rendered in no particular order (back to front or front to back) there would be a lot of overdraw. This step totally remove overdraw.</li>
                </ul>
                <p>
                Note that the color buffer is cleared to black: Doom3 world is naturally pitch black since there is no "ambient" light: In order to be visible a surface/polygon must interact.
                with a light. This explains why Doom3 was so dark !
                <br/>
                <br/>
                After this the engine is going to perform 11 passes (one for each light).
                
                
 
                
                
                
                
                
                
                
                
                
                I broke down the rendering process . The next slideshow shows each individual light pass:  you can move in time with the left and right arrow.
<div class="rss-container">

<div id="slideshow-2" class="rs-slideshow">
<div class="slide-container">
<img src="../fd_proxy/doom3/breakdown/shot00016.jpg" alt="The first image in a slideshow demo." title="After Light Pass 1" />
<span class="slide-caption">After Light Pass 1</span>
</div>
<ol class="slides">

<li>
<a href="../fd_proxy/doom3/breakdown/shot00001.jpg" 
title="Light 1 contribution.">Light 1 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00003.jpg" 
title="Light 2 contribution.">Light 2 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00004.jpg" 
title="Light 3 contribution.">Light 3 contribution.</a>
</li>
<li>
<a href="../fd_proxy/doom3/breakdown/shot00005.jpg" 
title="Light 4 contribution.">Light 4 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00006.jpg" 
title="Light 5 contribution."> Light 5 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00007.jpg" 
title="Light 6 contribution.">Light 6 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00008.jpg" 
title="Light 7 contribution.">Light 7 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00009.jpg" 
title="Light 8 contribution.">Light 8 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00010.jpg" 
title="Light 9 contribution.">Light 9 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00015.jpg" 
title="Light 10 contribution.">Light 10 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00016.jpg" 
title="Light 11 contribution.">Light 11 contribution.</a>
</li>

<li>
<a href="../fd_proxy/doom3/breakdown/shot00022.jpg" 
title="Final Pass: Ambient lights Pass">Final Pass: Ambient lights Pass</a>
</li>

</ol>
</div>

</div>

<script language="javascript">
$(document).ready(function () {
                  
                  var opts = {
                  controls: {
                  //playPause: {auto: true},
                  previousSlide: {auto: true},
                  nextSlide: {auto: true},
                  index: {auto: true},
                  
                  },
                  interval : 600
                  };
                  $('#slideshow-2').rsfSlideshow(opts);
                  
                  });
</script>

</br>
</br>
<p>
Now the details of what happens in the GPU framebuffer:<br/>
<br/>
<div class="rss-container">
                
                <div id="slideshow-3" class="rs-slideshow">
                <div class="slide-container">
                <img src="../fd_proxy/doom3/compo/doom_Scene01.jpg" alt="The first image in a slideshow demo." title="This is the first slide" />
                <span class="slide-caption">After Light 1 Pass.</span>
                </div>
                <ol class="slides">
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene01.jpg" 
                title="After Light 1 Pass.">This is the first slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene02.jpg" 
                title="After Light 2 Pass.">This is the first slide</a>
                </li>
                
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene03.jpg" 
                title="After Light 3 Pass.">This is the second slide</a>
                </li>
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene04.jpg" 
                title="After Light 4 Pass.">This is the third slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene05.jpg" 
                title="After Light 5 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene06.jpg" 
                title="After Light 6 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene07.jpg" 
                title="After Light 7 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene08.jpg" 
                title="After Light 8 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene09.jpg" 
                title="After Light 9 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene10.jpg" 
                title="After Light 10 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene11.jpg" 
                title="After Light 11 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene12.jpg" 
                title="After Light 11 Pass.">This is the fourth slide</a>
                </li>
                
                <li>
                <a href="../fd_proxy/doom3/compo/doom_Scene13.jpg" 
                title="After Ambient Surfaces Pass.">This is the fourth slide</a>
                </li>
                
                </ol>
                </div>
                
                </div>
                
                <script language="javascript">
                $(document).ready(function () {
                                  
                                  var opts = {
                                  controls: {
                                  //playPause: {auto: true},
                                  previousSlide: {auto: true},
                                  nextSlide: {auto: true},
                                  index: {auto: true}
                                  
                                  },
                                  interval : 600
                                  };
                                  $('#slideshow-3').rsfSlideshow(opts);
                                  
                                  });
                </script>

	</p>		
	
                
               
                
                
                
    <u>Stencil buffer and Scissors test:</u><br/>
    <br/>
    Before each light pass, if a shadow is cast by the light then the stencil test has to be enable. I won't elaborate on the depth-fail/depth pass controversy and the infamous move of Creative Labs. The source code released features the depth pass algorithm which is slower since it requires building better shadow volume.
    Some people have managed to put the depth fail algorithm back in the source but be aware that this is only legal in Europe !<br/>
    <br/>
    <br/>
    In order to save fillrate the frontend generate a screen space rectangle to be used as scissor test by OpenGL. This avoid running shader
    on pixels where the surface would have been pitch black anyway due to distance from the light.<br/>
    <br/>
                             The stencil buffer just before light pass 8. Any non-black area will be lit while the other will prevent writing to the framebuffer: The mask principle sis clearly visible<br/>
    <br/>
    <img style="box-shadow: 3px 3px 7px #777; width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" 
                src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/DOOM3-Context3-Static-StencilBuffer.png"/><br/>
     
     <br/>The stencil buffer just before light pass 7. The scissor set to save fillrate is clearly visible.<br/>
     <br/>                       
     <img style="box-shadow: 3px 3px 7px #777; width:900px; height: 675px ; display:block; margin-left: auto; margin-right: auto;" 
                src="../lazy_load/grey.gif" data-original="/fd_proxy/doom3/renderer/DOOM3-Context3-Static-StencilBuffer2.png"/><br/>                       
	</p>
	
	
	
	
	
	
	
                <br/>
                <h2>Interactive surfaces</h2>
                <p id="paperbox">
                The last step in rendition is <code>RB_STD_DrawShaderPasses</code>: It render all surfaces that don't need light. Among them
                are the screen and the amazing interactive GUI surfaces that is one of the part of the engine John Carmack was the most proud off. I don't think this part of the engine ever got the respect it deserve. Back in 2004 the introduction cinematic used to be a video that would play fullscreen. After the video played the level would load and the engine would kick in... but not in Doom III:<br/>
                <br/>
                <video style="width:100%; height:auto;" controls>
  <source src="d.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
                <p>
                <u>Steps :</u>
                <ul>
                   <li>Level load.</li>
                   <li>Cinematic starts playing.</li>
                   <li>At 5mn5s the camera moves away.</li>
                   <li>The video we just saw was a SCREEN IN THE GAME ENGINE !</li>
                </ul>
                <p>
                I remember when I saw this for the first time I thought it was a trick. I thought the video player would cut and the designer had a texture on the screen and a camera position that would match the last frame of the video. I was wrong: idTech4 can actually play videos in a GUI interactive surface elements. For this it reused RoQ: The technology that Graeme Devine brought with him when he joined id Software.<br/>
                    <br/>
                    
                <b><u>Trivia :</u></b>
                    The RoQ used for the intro was impressive for 2005 and it was an audacious move to have it in a screen within the game:
                    <ul>
                       <li>It is 30 frames per seconds.</li>
                       <li>Each frame is 512x512: Quite a high resolution at the time</li>
                       <li>Each frame is generated in <code>idCinematicLocal::ImageForTime</code> on the CPU and uploaded on the fly to the GPU as an OpenGL texture.</li>
                    </ul>
                    </br>
                    <p>
                    
                    But the interactive surfaces can do so much more than that thanks to scripting and its ability to call native methods.
                    Some people got <a href="http://www.battleteam.net/tech/fis/docs/index.html">really interested</a> and managed to have <a href="http://www.battleteam.net/tech/fis/">Doom 1 run in it</a> !
                        <br/><br/>
                        <img style="display:block;margin-left:auto; margin-right:auto;" src="../fd_proxy/doom3/doom3_running_doom1.jpeg"/>
                        <br/>
                <b><u>Trivia :</u></b>The Interactive Surface technology was also reused in order to design all the menus in Doom3 (settings, main screen etc,....).
                <p/>
	
                             
                             
                             <br/>
                             <h2>So much more....</h2>
                             <p id="paperbox">
                             This page is only the tip of the iceberg and it is possible to go <a href="renderer.txt">so much deeper</a>.
                             </p>
                                     
                             
                             
                             
                             <h2>Recommended readings</h2>

            <p id="paperbox"> 
                             <a style="float:left;margin-right:40px;" href="http://www.amazon.com/Real-Time-Rendering-Third-Tomas-Akenine-Moller/dp/1568814240/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1312836258&amp;sr=1-1"><img src="../fd_proxy/quake2/realtime_rendering.png" style="margin: 0 0px 0 0px;"></a>
            If you are reading this and you don't own a copy of <a href="
http://www.realtimerendering.com/">Realtime rendering</a> you are depriving yourself of priceless information.
<div style="clear:both;"></div>
                             </p>
                             
                             
                                     
                <!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

