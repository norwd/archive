<script type="text/javascript">
  var disqus_identifier = "quakeSource";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Quake engine, Documented Quake source, Quake code review, idtech1"/>
		<meta name="Description" content="Quake source code review"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>Quake Source Code Review</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       March 9th, 2009</div>
   <h1>Quake Engine code review : Rendition (4/4)</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="quakeEngine.jpg"" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         		Quake renderer is the module that took the most work during the initial development. It is extensivly described by Michael
		Abrash book and John Carmack's .plan files.<br/>
		<br/>
		This article is in four parts :<br/>
		<Br/>
					<a href="index.php">Architecture section</a><br/>
<a href="quakeSourceNetWork.php">Network section</a><br/>
<a href="quakeSourcePrediction.php">Prediction section</a><br/>
<a href="quakeSourceRendition.php">Rendition section</a><br/>

					<br/>				<div style="clear:both;"></div>
			</p>
					
			



			<h3>Rendition</h3>
			<p id="paperbox">
				The scene rendition process revolves around the map's BSP. I invite you to read more about <a href="http://en.wikipedia.org/wiki/Binary_space_partitioning">Binary Space Partitioning</a> on Wikipedia. In a nutshell, Quake maps are heavily pre-processed ; The volume is sliced recursively as in the following drawing:<br/>
				<br/>
				 <img style="display: block; margin-left: auto; margin-right: auto;" src="bsp.jpg"   />
				<br/>
				<br/>
				The process generates a leafy BSP ( the rules are: choose an existing polygon as splitting plan and choose the splitter cutting the less polygons).
				After the BSP is generated, for each leaves is calculated the PVS (Potentially Visible Set). As an example: the leaf 4 can potentially see leave 7 and 9:<br/>
				<br/>
					 <img style="display: block; margin-left: auto; margin-right: auto;" src="pvs.jpg"   />
				<br/>
				The resulting PVS for this leaf is stored as a bit vector:<br/>
				<br/>
				<table border="1" style="background-color:white; width:50%; border-color: rgb(170,170,170);width:700px;text-align: center;border-width: 1px 1px 1px 1px;border-spacing: 2px;border-collapse: collapse;">
					<tr>
						<th >Leaf Id</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th>
					</tr>
					<tr>
						<th>PVS for leaf 4</th><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
					</tr>
				</table>
				<br/>
				This resulted in a global PVS size of about 5Mb, way too much for PC in 1996. The PVS is hence compressed via delta length compression.<br/>
				<br/>
					<table border="1" style="background-color:white; width:50%; border-color: rgb(170,170,170);width:300px;text-align: center;border-width: 1px 1px 1px 1px;border-spacing: 2px;border-collapse: collapse;">
					<tr>
						<th >Compressed PVS for leaf 4</th><td>3</td><td>2</td><td>1</td><td>7</td></th>
					</tr>
				</table>
				<br/>
				The Run-length encoded PVS only contains the number of 0s between the 1s. Although it may not look like a very efficient compression technique, the high number of leaves (32767), combined with a very limited set of visible leaves, brings down the size of the entire PVS to 20kB.<br/>
				<br/>
				<br/>

				<h3>Pre-processing in action</h3>
				<p id="paperbox">
				Armed with the precalculated BPS and PVS, the engine's map rendition routine was simply:<br/>
				<br/>
				<ul>
					<li>Traverse the BSP to determine in which leaf the camera is positioned.</li>
					<li>Retrieve and decompress the PVS for this leaf, iterate through PVS and mark leaves in the BSP.</li>
					<li>Traverse the BSP near to far</li>
					<li>If a Node is not marked, skip it.</li>
					<li>Test the Node Boundary Box against the Camera Frustrum.</li>
					<li>Add the current leaf to the rendition list</li>
				</ul>
				</p>
				<p>
				<b>Note:</b> The BSP is used multiple times ex: to walk the map near to far for each active light and tag the polygons of the map. <br/>
				<b>Note2:</b> In software rendition, the BSP is walked far to near.
				</p>
			





			<h3>Code analysis</h3>
			<p>
				The rendition code can be summarized as follow:
			</p>
			<pre  class="long">
			
SCR_UpdateScreen 											
{
		GL_BeginRendering
		SCR_SetUpToDrawConsole
		V_RenderView
		|		R_Clear
		|		R_RenderScene
		|		|		R_SetupFrame
		|		|				Mod_PointInLeaf
		|		|		R_SetFrustum
		|		|		R_SetupGL
		|		|		R_MarkLeaves
		|		|		|		Mod_LeafPVS
		|		|		|				Mod_DecompressVis
		|		|		R_DrawWorld
		|		|		|		R_RecursiveWorldNode
		|		|		|		DrawTextureChains
		|		|		|		|		R_RenderBrushPoly
		|		|		|		|			DrawGLPoly
		|		|		|		R_BlendLightmaps
		|		|		S_ExtraUpdate
		|		|		R_DrawEntitiesOnList
		|		|		GL_DisableMultitexture
		|		|		R_RenderDlights
		|		|		R_DrawParticles
		|		R_DrawViewModel
		|			R_DrawAliasModel
		|		R_DrawWaterSurfaces
		|		R_PolyBlend
		GL_Set2D
		SCR_TileClear
		V_UpdatePalette
		GL_EndRendering
}
				</pre>
				
				
				<p>
				<u>SCR_UpdateScreen</u><br/>
				<br/>
				<br/>
				Calls:<br/>
				<ol>
					<li><code>GL_BeginRendering</code> (Set variables (<code>glx,gly,glwidth,glheight</code>) later used in <code>R_SetupGL</code> to setup viewPort and projection matrix)</li>
					<li><code>SCR_SetUpToDrawConsole</code> (Decid console height : Why this is here and not in the 2D part ?! )</li>
					<li><code>V_RenderView</code>  (Render 3D scene)</li>
					<li><code>GL_Set2D</code> (Switch to ortho projection (2D))</li>
					<li><code>SCR_TileClear</code></li>
					<li>Optionally draws a lot of 2D stuff, console, FPS metrics etc...</li>
					<li><code>V_UpdatePalette</code> (name fit software renderer, in openGL this set the blending mode, according to damage received or active bonus etc making screen red or bright etc...). Value is stored in <code>v_blend</code></li>
					<li><code>GL_EndRendering</code> (Swap the buffer (double-buffering)!!)</li>
				</ol>																														
				<br/>	 
				<br/>
				<u>V_RenderView</u><br/>
				<br/>	
				Calls:<br/>
				<ol>
					<li><code>V_CalcRefdef</code> (No idea sorry :) !)</li>
					<li><code>R_PushDlights</code> Mark polygons with every light with effect on them(see note)</li>
					<li><code>R_RenderView</code></li>
				</ol>						
				Note:<br/>
				<br/>
				R_PushDlights calls a recursive method (<code>R_MarkLights</code>). It uses the BSP to mark (using an int bit vector) polygons affected by lights, BSP is walked near to far (from the light's POV). The method checks if light is active and if in range. <code>R_MarkLights</code> method is particulary noticable because we can find here Michael Abrash's direct application of distance point-plan article "Frames of Reference" (<code>dist = DotProduct (light->origin, splitplane->normal) - splitplane->dist;</code>)  ).
				<br/>	 
				<br/>
				<u>R_RenderView</u><br/>
				<br/>	
				Calls:<br/>
				<ol>
					<li><code>R_Clear</code> (Clear GL_COLOR_BUFFER_BIT and/or GL_DEPTH_BUFFER_BIT do only what is needed)</li>
					<li><code>R_RenderScene</code></li>
					<li><code>R_DrawViewModel</code> (Render player model is we are in spectator mode)</li>
					<li><code>R_DrawWaterSurfaces</code> (Switch to GL_BEND/GL_MODULATE mode to draw water. Warping is done via sin and cos lookup table from <code>gl_warp.c</code>)</li>
					<li><code>R_PolyBlend</code> (Blend the entire screen with value set in <code>V_UpdatePalette</code> via <code>v_blend</code>. This is to show when we take damage (red), are under water or under bonus boost effect)</li>
				</ol>						
					 
					 
				<br/>
				<u>R_RenderScene</u><br/>
				<br/>	
				Calls:<br/>
				<ol>
					<li><code>R_SetupFrame</code>(Retrieve the BSP leaf where the camera is, store it in variable "r_viewleaf" )</li>
					<li><code>R_SetFrustum</code> (Setup the <code>mplane_t frustum[4]</code>. No near and far plane</li>
					<li><code>R_SetupGL</code> (Setup GL_PROJECTION, GL_MODELVIEW, viewport and glCullFace side, also Rotate Y and Z axis as Quake z axis and x axis are switched with openGL. )</li>
					<li><code>R_MarkLeaves</code></li>
					<li><code>R_DrawWorld</code></li>
					<li><code>S_ExtraUpdate</code> (Reset mouse location, take care of sound issues)</li>
					<li><code>R_DrawEntitiesOnList</code> (Self-explained)</li>
					<li><code>GL_DisableMultitexture</code> (Idem)</li>
					<li><code>R_RenderDlights</code> (Light bubbles, light effects)</li>
					<li><code>R_DrawParticles</code> (Explosions, Fire, Static, etc )</li>
				</ol>						
					
				
				
				
				
				
				<br/>
				<u>R_SetupFrame</u><br/>
				
				Notice the line:
			
				<code>r_viewleaf = Mod_PointInLeaf (r_origin, cl.worldmodel);</code>
				<br/>
				This is where the Quake engine retrieves the leaf/node the camera is currently positioned in the BSP.<br/>
				<br/>
				Mod_PointInLeaf can be found in model.c, it runs through the BSP (the BSP root is at model->nodes ).<br/>
				<br/>
				For every node:
				<ul>
					<li> If the node is not splitting the space further, it's a leaf and hence it's returned as the current node position.
					<li> Else the BSP splitting plane is tested against the current position (via a simple dot product, that's the usual way BSP tree are visited) and the matching children is visited.
					
				</ul>
				
				</p>
				
				
				
				
				
				<br/>
				<u>R_MarkLeaves</u><br/>
				<br/>
				 Variable <code>r_viewleaf</code> holding the camera location in the BSP (retrieved in <code>R_SetupFrame</code>), lookup (<code>Mod_LeafPVS</code>) and decompress (<code>Mod_DecompressVis</code>)the Potentially Visible Set (PVS.)<br/>
				 Then iterate on the bit vector and mark Potentialy visible nodes of the BSP with:  node->visframe = r_visframecount.<br/>
				<br/>
				
				
				
			

			
			
				
				<br/>
				<u>R_DrawWorld</u><br/>
				<br/>
				Calls:<br/>
				<ol>
					<li><code>R_RecursiveWorldNode</code> ( Walk the BSP world front to back, skipping Nodes not marked earlier (via <code>R_MarkLeaves</code>), populate <code>cl.worldmodel->textures[]->texturechain</code> list with the appropriate polygons.)</li>
					<li><code>DrawTextureChains</code> ( Draw the list of polygons stored in texturechain: Iterating through cl.worldmodel->textures[]. This way, there is only one switch per material. Neat.)</li>
					<li><code>R_BlendLightmaps</code> (Second pass used to blend the lightmaps in the framebuffer)</li>
				</ol>
				 <br/>
				 <u>Note:</u><br/>
				 <br/>
				 This part uses the openGL infamous "immediate mode", at the time it was probably considered "start of the art".<br/>
				 <br/>
				 <code>R_RecursiveWorldNode</code> is where most of the surface culling is being done; A node is discarded if:
				 <ul>
				 	<li>The content is solid.</li>
					<li>The leaf was not marked via the PVS (<code>node->visframe != r_visframecount</code>)</li>
					<li>The leaf fails the frustrum clipping.</li>
				</ul>
			</p>	
					
			






			<h3>MDL format</h3>
			
			<p id="paperbox">
				The MDL format is a set of fixed frames, Quake engine does not interpolate vertex location to smooth animation (so higher frame rate do not makes models animation look better).
			</p>
			
			

			<h3>Some elegant things
			</h3>
			<p>
				<u id="elegant_leaf_marking">Elegant leaf marking</u><br/>
				<br/>
				The naive approach to mark a leaf of the BSP to be rendered would be to use a boolean <code>isMarkedVisible</code> and before each frame:
				<ol>
					<li>Set all boolean to false.</li>
					<li>Iterate through the PVS and set visible leaf to true.</li>
					<li>Later, test leave with <code>if (leave.isMarkedVisible)</code></li>
				</ol>
			</p>
			<p>
				Instead of this, Quake engine uses an integer to count the number of frame rendered (<code>r_visframecount</code> variable). This allow the step 1 to be skipped entirely:
				<ol>
					<li>Iterate through the PVS and set visible leaf <code>leaf.visframe = r_visframecount</code></li>
					<li>Later, test leave with <code>if (leaf.visframe == r_visframecount)</code></li>
				</ol> 
			
			

			<p>

				<u>Recursion avoidance</u><br/>

				<br/>

				Found in <code>R_SetupFrame</code>, instead of going with a quick and dirty recursion to walk the BSP and retrieve the current position: a while loop is used.<br/>

			</p>

			<pre  class="long">

	node = model->nodes;

	while (1)

	{

		if (node->contents < 0)

			return (mleaf_t *)node;

		plane = node->plane;

		d = DotProduct (p,plane->normal) - plane->dist;

		if (d > 0)

			node = node->children[0];

		else

			node = node->children[1];

	}

				</pre>

			<p>
			<u>Minimize texture switchs</u><br/><br/>
			</p>
			<p id="paperbox">

				In openGL, switch texture via (<code>glBindTexture(GL_TEXTURE_2D,id)</code>)is very expensive. In order to minimize switchs numbers, every polygon marked for rendition is stored in an array chain, indexed on the polygon's texture material.<br/>
				<br/>
				<code>cl.worldmodel->textures[textureId]->texturechain[]</code>
				<br/>
				<br/>
				Upon culling is done, the texturechains are drawn in order, this way there is N texture switchs where N is the total number of texture visible.
			</p>
			
			<pre  class="long">
			
			
	int i;
	for ( i = 0; i < cl.worldmodel->textures_num ; i ++)
		DrawTextureChains(i);
			
			
			</pre>




			
			<p>
				<a  style="display: block; text-align: center;" href="index.php#rendition"> Return to main Quake Source Exploration page.</a>
			</p>
			
			
<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

