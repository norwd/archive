<html>
<head>
  <link rel="alternate" type="application/rss+xml"  title="RSS Feed for fabiensanglard.net" href="../rss.xml" />
  <style type="text/css">

    @font-face {
      font-family: 'fabfont';
      src: url('../font/DejaVuSansMono.woff2');
      font-display: block;
    }

    @font-face {
      font-family: 'fabfont';
      src: url('../font/DejaVuSansMono-Bold.woff2');
      font-weight: bold;
      font-display: block;
    }

    * {
       font-size: 16px;
    }

    html {
      font-family: fabfont,  monospace;
      max-width: 900px;  /* For Desktop PC (see @media for Tablets/Phones) */
      padding-left: 2%;
      padding-right: 3%;
      margin: 0 auto;
      background: #F5F5F0;
  	} 
    


  	a {
      color: black;
      font-weight: bold;
    }

    img {
      border: none; 
    }

    p {
      margin-top: 0px;
      text-align: justify;
    }
    sup {
      vertical-align: 0.3em;
      font-size: 0.65em;
    }   

    pre {
      font-family: fabfont, monospace;
      background-color: white; 
      border: 1px solid Black; 
      padding-left: 2%;
      padding-top: 1ch;
      padding-bottom: 1ch;
      /* Only take care of X overflow since this is the only part that can be too wide.
         The Y axis will never overflow.
      */
      overflow: hidden;
    }

    div.heading {
      font-weight: bold;      
      text-transform: uppercase;
      margin-top: 4ch;
    }

    /** {
      font-size: 16px;
    }*/
    @media (max-width: 500px) { /* For small screen decices */
      * {
        font-size: 12px; 
      }
    }   
    .title {
      text-decoration: none;
    }

    img.pixel, canvas.pixel {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    blockquote { 
    background-color: #f3f3f3;
    border: dashed 1px grey; 
    width: 97.5%; 
    font-style: italic; 
    text-align: justify;

    padding: 1ch; 
    padding-top: 2ch; 
    padding-bottom: 2ch;     
    
    margin : 0ch; 
    margin-bottom: 2ch; 
    margin-top: 0ch;
  }

  blockquote div {
    text-transform: none;
    text-align: right;
    width: 100%;
  }

  code {
    /*font-size: 110%;*/
    font-weight: bold;
    background-color: #e1e1e1;
    border-radius: 0.5ch;
    padding-left: 0.3ch;
    padding-right: 0.3ch;
  }

  .trivia {
    border-left: 1px black solid;
    padding-left: 1ch;
  }

  .trivia::before {
  font-weight: bold;
  text-decoration: underline;
  padding-right: 1ch;
  content: "Trivia:";

  </style>
  <title>Revisiting the postcard pathtracer with CUDA and Optix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=12.0, minimum-scale=1.0, user-scalable=yes">
</head>  
  <body><br><center>
    <div style="display: inline-block; vertical-align:middle;">
<a href="../index.html" class="title"><b>FABIEN SANGLARD'S WEBSITE</b><br>
</a><hr/><div style="text-align: justify;display: inline-block; width: 100%;">
<!-- <a class="title" href="/about/index.html">ABOUT</a> &nbsp;<a class="title" href="/contact/index.html">EMAIL</a> &nbsp;<a class="title" href="../rss.xml">RSS</a> &nbsp;<a class="title" href="https://paypal.me/fabiensanglard">DONATE</a></div></div> -->
<a class="title" href="../about/index.html">ABOUT</a> &nbsp;<a class="title" href="../contact/index.html">CONTACT</a> &nbsp;<a class="title" href="../rss.xml">RSS</a> &nbsp;<a class="title" href="https://paypal.me/fabiensanglard">GIVE</a></div></div>

</center><br><br>
<div style="margin-bottom: 2ch;text-transform: none;">
May 18, 2020</div>
<div class='heading'>Revisiting the postcard pathtracer with CUDA and Optix</div><hr/>
<style>
  img {
    border: solid 1px black;
  }

  
</style>



<p>
  <picture>
    <source srcset="rendered.webp" type="image/webp">
    <img loading="lazy" src="rendered.jpg" width="960" height="540" style="width: 35%; height: auto; float:right; margin-left: 3%; margin-bottom: 10px;"/>  </picture>
Last week, I revisited Andrew Kensler's business card raytracer to make it run as fast as possible<a name="back_1" style="text-decoration: none;" href="index.html#footnote_1"><sup>[1]</sup></a>. It was a lot of fun and I learned a lot in the process. I enjoyed it so much that I decided to revisit Andrew's follow up, the postcard sized pathtracer<a name="back_2" style="text-decoration: none;" href="index.html#footnote_2"><sup>[2]</sup></a>.

<br/>
<br/>
I spent a lot of time trying to make sense of that code back in 2018 and I knew it was going to be a bigger challenge. Because it is a pathtracer and not a raytracer, it is more computationally intensive. The quality of the image is directly correlated with how many rays are cast per pixel. 
<br/>
<br/>
 This twist allowed me to change the rules of my self-imposed game. Instead of attempting to run as fast as possible, I decided on a time budget (1mn) and resolved to generate the best image possible. The name of the game was to maximize the samples per pixel (spp) at resolution 960x540.
<br/>
<br/>
The hardware used was a DB4<a name="back_3" style="text-decoration: none;" href="index.html#footnote_3"><sup>[3]</sup></a> cube containing a Ryzen 5 2600 (6 cores, 12 threads at 3.5Ghz) with an Nvidia Pascal based GTX 1050 Ti GPU.
<!-- <br/> -->
<!-- <br/> -->
I followed the same path as last time. Starting with compiler flags, then moving to SIMD, multi-threading, and GPU rendering via CUDA. In the end, despite skepticism, I gave a try to OptiX denoiser and it blew my mind.
<br/>
</p>

<div class='heading'>Cleaning up the code</div><hr/><p style="margin-bottom: 1ch;">
  At first sight, the postcard pathtracer code (<a href="pixar.cpp">pixar.cpp</a>) is a tad intimidating.<br/> 
  <pre>#include &lt;stdlib.h> // card > pixar.ppm
#include &lt;stdio.h>
#include &lt;math.h>
#define R return
#define O operator
typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F
c=0){x=a;y=b;z=c;}V O+(V r){R V(x+r.x,y+r.y,z+r.z);}V O*(V r){R V(x*r.x,y*r.
y,z*r.z);}F O%(V r){R x*r.x+y*r.y+z*r.z;}V O!(){R*this*(1/sqrtf(*this%*this)
);}};F L(F l,F r){R l&lt;r?l:r;}F U(){R(F)rand()/RAND_MAX;}F B(V p,V l,V h){l=p
+l*-1;h=h+p*-1;R-L(L(L(l.x,h.x),L(l.y,h.y)),L(l.z,h.z));}F S(V p,I&m){F d=1\
e9;V f=p;f.z=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\
eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l
[i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\
rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,o.x>0?f\
absf(sqrtf(o%o)-2):(o.y+=o.y>0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(p.z,
8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V
(25,20,25))),B(V(fmodf(fabsf(p.x),8),p.y,p.z),V(1.5,18.5,-25),V(6.5,20,25)))
;if(r&lt;d)d=r,m=2;F s=19.9-p.y;if(s&lt;d)d=s,m=3;R d;}I M(V o,V d,V&h,V&n){I m,s=
0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))<.01||++s>99)R n=!V(S(h+V(.01,0
),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}V T(V o,V d){V h,n,r,t=
1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*(
n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c),
g=n.z&lt;0?-1:1,u=-1/(g+n.z),v=n.x*n.y*u;d=V(v,g+n.y*n.y*u,-n.y)*(cosf(p)*s)+V(
1+g*n.x*n.x*u,g*v,-g*n.x)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i>0&&M(h
+n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}}
R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(g.z,
0,-g.x)*(1./w),u(g.y*l.z-g.z*l.y,g.z*l.x-g.x*l.z,g.x*l.y-g.y*l.x);printf("P\
6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e
,!(g+l*(x-w/2+U())+u*(y-h/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(c.x/o.x,c.
y/o.y,c.z/o.z)*255;printf("%c%c%c",(I)c.x,(I)c.y,(I)c.z);}}// Andrew Kensler</pre>
<p style="margin-bottom: 0;">
Adding colors to outline the different parts helps to understand that it is in fact very simple with seven sections based on a Pixel Sampler with RayMarches into a Database.<br/>

<pre><div style="margin-bottom:1ch;display:inline;text-transform:none;color:LightGray;">#include &lt;stdlib.h> // card > pixar.ppm
#include &lt;stdio.h>
#include &lt;math.h>
<div style="display:inline;text-transform:none;color:fuchsia;">#define R return
#define O operator
typedef float F;typedef int I;<div style="display:inline;text-transform:none;color:blue;">struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F
c=0){x=a;y=b;z=c;}V O+(V r){R V(x+r.x,y+r.y,z+r.z);}V O*(V r){R V(x*r.x,y*r.
y,z*r.z);}F O%(V r){R x*r.x+y*r.y+z*r.z;}V O!(){R*this*(1/sqrtf(*this%*this)
);}};<div style="display:inline;text-transform:none;color:orange;">F L(F l,F r){R l&lt;r?l:r;}F U(){R(F)rand()/RAND_MAX;}F B(V p,V l,V h){l=p
+l*-1;h=h+p*-1;R-L(L(L(l.x,h.x),L(l.y,h.y)),L(l.z,h.z));}</div><div style="display:inline;text-transform:none;color:LimeGreen      ;">F S(V p,I&m){F d=1\
e9;V f=p;f.z=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\
eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l
[i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\
rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,o.x>0?f\
absf(sqrtf(o%o)-2):(o.y+=o.y>0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(p.z,
8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V
(25,20,25))),B(V(fmodf(fabsf(p.x),8),p.y,p.z),V(1.5,18.5,-25),V(6.5,20,25)))
;if(r&lt;d)d=r,m=2;F s=19.9-p.y;if(s&lt;d)d=s,m=3;R d;}<div style="display:inline;text-transform:none;color:black   ;">I M(V o,V d,V&h,V&n){I m,s=
0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))<.01||++s>99)R n=!V(S(h+V(.01,0
),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}<div style="display:inline;text-transform:none;color:SkyBlue;">V T(V o,V d){V h,n,r,t=
1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*(
n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c),
g=n.z&lt;0?-1:1,u=-1/(g+n.z),v=n.x*n.y*u;d=V(v,g+n.y*n.y*u,-n.y)*(cosf(p)*s)+V(
1+g*n.x*n.x*u,g*v,-g*n.x)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i>0&&M(h
+n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}}
R r;}<div style="display:inline;text-transform:none;color:red;">I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(g.z,
0,-g.x)*(1./w),u(g.y*l.z-g.z*l.y,g.z*l.x-g.x*l.z,g.x*l.y-g.y*l.x);printf("P\
6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e
,!(g+l*(x-w/2+U())+u*(y-h/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(c.x/o.x,c.
y/o.y,c.z/o.z)*255;printf("%c%c%c",(I)c.x,(I)c.y,(I)c.z);}}<div style="display:inline;text-transform:none;color:LightGray;">// Andrew Kensler</div></pre>
<p style="margin-bottom: 3ch;">
<table  style="display:inline;background-color:fuchsia; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Usual tricks,
<table  style="display:inline;background-color:blue; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Vector class, 
<table  style="display:inline;background-color:orange; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Utils, 
<table  style="display:inline;background-color:LimeGreen      ; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Database, 
<table  style="display:inline;background-color:black ; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Ray marching, 
<table  style="display:inline;background-color:SkyBlue; width: 1ch; height: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> Sampling, 
<table  style="display:inline;background-color:red; width: 1ch; heightight: 1ch; border: 1px solid black;"><tr><td>&nbsp;</td></tr></table> main.<br/>
<p>

With a bit of renaming and clang-tidy, <a href="a.html">a.cpp</a> gives a much clearer picture.<br/>
</p>





<div class='heading'>Establishing the baseline</div><hr/><p style="margin-bottom: 0;">
To make testing easier, I modified the code to take as parameter the number of samples per pixel. The 1mn budget was completely blown up when establishing the baseline (with all optimization disabled). Even lowering spp to one, it took 5mn27s to generate a very noisy image.<br/>  
<pre>
$ clang -O0 -lm -o a a.cpp 
$ time ./a <font color=red>1</font> > /dev/null

real    5m27.311s
user    5m27.094s
sys     0m0.078s
</pre>
<p>
  <picture>
    <source srcset="pixar_1sample.webp" type="image/webp">
   <img loading="lazy" src="pixar_1sample.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 0ch;"/></picture>

   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>One core, no SIMD, -O0, and 1spp = 5mn27s runtime.</small></i></span>
</p>


<div class='heading'>Compiler optimizations</div><hr/><p style="margin-bottom: 0;">
The first step, and some people would even argue that there is nothing below -O3 and it should have been the base, is to enable compiler optimizations. Performance improved 30x resulting in 6spp.<br/>
<pre>
$ clang -lm -O3 -o a a.cpp 
$ time ./a <font color=red>6</font> > /dev/null

real    0m58.100s
user    0m58.266s
sys     0m0.031s
</pre>
<p>
  <picture>
    <source srcset="pixar_O3_6samples.webp" type="image/webp">
   <img loading="lazy" src="pixar_O3_6samples.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>

  <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>With -O3 the pathtracer can be pushed to 6spp and renders in 57s.</small></i></span>
</p>


<div class='heading'>-fFast-math</div><hr/><p style="margin-bottom: 0;">
  There is a compilation flag, -ffast-math, which allows the compiler to relax IEEE 754 compliance in favor of performance. It is automatically enabled when using -Ofast and shows another 2.6x performance improvement allowing 16spp.<br/>
  <pre>
$ clang -lm -Ofast -o a a.cpp 
$ time ./a <font color=red>16</font> > /dev/null 

real    0m56.304s
user    0m56.266s
sys     0m0.031s
</pre>
<p>
  <picture>
    <source srcset="pixar_16samples.webp" type="image/webp">
   <img loading="lazy" src="pixar_16samples.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>

  <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>With -ffast-math we can cross a double digit spp to reach 16.</small></i></span>
  <b><u>Trivia:</u></b> Opening the executable with BinaryNinja showed that clang was able to detect two calls to cosf(X) and sinf(X) separated by several lines of code and optimizes them into sincosf (which I had no idea existed). Surprisingly this only happened with -Ofast and not with -O3.<br/> 
</p>



<div class='heading'>Going SIMD</div><hr/><p style="margin-bottom: 2ch;">
 Going SIMD is something I also did when I revisited the business card raytracer. Or at least I thought I did. I was mistaken when after opening the binary and seeing XMM registers in use I concluded that SIMD instructions were used.<br/>
 <blockquote>
   Just because compiler is outputting SIMD instructions it does not mean it's taken care of. In asm you can see that pretty much all mul/add instructions have ss or sd suffix - meaning they operate on single data element. What you want is to have mulps/mulpd instructions.
   <br/>
   <br/>
   <div>-Mārtiņš Možeiko<a name="back_4" style="text-decoration: none;" href="index.html#footnote_4"><sup>[4]</sup></a></div>
 </blockquote> 
 <p style="margin-bottom: 1ch;">If Clang is able to generate SIMD instructions via auto-vectorization, I found the feature capricious to trigger.<br/>
  <table style="width: 100%; height: auto; table-layout:fixed; margin-top: 1ch;">
    <tr>
      <td style="width: 30%;">
  <pre style="">
struct Vec{

 float p[<font color=red>3</font>];

 <font color=red>NOT SIMD!!</font>
 Vec operator+(Vec o){ 
   Vec v;
   for(int i=0 ; i<<font color=red>3</font> ; i++){
     v.p[i] = p[i] + o.p[i];
   }
   return v;
 }
};
  </pre>
</td>
      <td style="width: 30%;">
  <pre style="">
struct Vec{

 float p[<font color=red>4</font>];

 <font color=red>NOT SIMD!!</font>
 Vec operator+(Vec o){ 
   Vec v;
   for(int i=0 ; i<<font color=red>3</font> ; i++){
     v.p[i] = p[i] + o.p[i];
   }
   return v;
 }
};
  </pre>
</td>
<td style="width: 30%;">

  <pre style="">
struct Vec{

 float p[<font color=#0F0>4</font>];

 <font color=#0F0>SIMD!!</font>
 Vec operator+(Vec o){ 
   Vec v;
   for(int i=0 ; i<<font color=#0F0>4</font> ; i++){
     v.p[i] = p[i] + o.p[i];
   }
   return v;
 }
};
  </pre>    
</td>
</tr>
</table>
<p style="margin-bottom: 0;">
In a professional environment I would probably not have felt confident relying on the compiler's good will. Using intrinsics via "nmmintrin.h", __m128, _mm_set_ps, _mm_add_ps, and _mm_div_ps<a name="back_5" style="text-decoration: none;" href="index.html#footnote_5"><sup>[5]</sup></a> would have been safer. For research purposes however it was fine.
<br/>
<br/>
 Modifying the Vector struct to operate on four items (<a href="b.html">b.cpp</a>) secured the Packet SIMD Instructions mulps and addps.<br/>
    <pre>
$ clang -lm -Ofast -o b b.cpp 
$ time ./b <font color=red>17</font> > /dev/null 

real    0m59.722s
user    0m59.719s
sys     0m0.000s
</pre>
<p>
The speed increase was marginal (17spp) and the visual difference imperceptible.
</p>




<div class='heading'>Using all cores</div><hr/><p style="margin-bottom: 1ch;">
At this point, it was time to use the 11 other cores on the Ryzen 5 2600. The task was considerably facilitated by the code from the previous exercise. A few pthread_create and pthread_join resulted in <a href="c.html">c.cpp</a> which spawn 540 threads, each rendering lines of 960 pixels.<br/>
    <pre>
$ clang -lm -lpthread -Ofast -o c c.cpp 
$ time ./c <font color=red>128</font> > /dev/null 

real    0m55.203s
user    10m52.188s
sys     0m0.063s
</pre>
<p>
As expected, the performance gain was linear with the number of cores. Twelve of them allowed to push sampling to 128spp. However the visual result had too much personality for my liking.<br/>
  <picture>
    <source srcset="b_rand_issues.webp" type="image/webp">
   <img loading="lazy" src="b_rand_issues.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>
   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>It is fast but also ugly. What is going on here?</small></i></span>
 There is a visible repeating horizontal pattern. Could it be explained by the random generator implemented by truncating libc's rand()<a name="back_6" style="text-decoration: none;" href="index.html#footnote_6"><sup>[6]</sup></a> and keeping only the linear congruential generator (LCG)?
<br/>
<br/>
 Nope. LCG is fine. The problem was that each thread pseudo-random number generator seed is initialized with the same value. Which means the same "random" serie is used across each line. Changing the seed value to use the thread id fixed the glitch (<a href="d.html">d.cpp</a>).<br/>

  <picture>
    <source srcset="pixar_128samples.webp" type="image/webp">
   <img loading="lazy" src="pixar_128samples.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>
   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>12 cores, -Ofast -> 128spp. Still noisy.</small></i></span>
   <b><u>Trivia:</u></b> The business raytracer optimization from last week prompted feedback from readers advising that 500+ threads was messing up with the scheduler and likely degraded performance. I tried to lower the thread count (12, 24, and even 36) but could not confirm this claim. An OS may have trouble dealing with 10,000 threads but it looks like Linux was well able to handle 500 of them.<br/>
</p>

<div class='heading'>GPGPU with CUDA</div><hr/><p style="margin-bottom: 0;">
All optimizations used for the business card raytracer were applied into <a href="e.html">e.cu</a>.<br/>
<ul>
  <li>Maximize occupancy -> 0.2 :/.</li>
  <li>Maximize branch efficiency -> 90% :).</li>
  <li>Avoid float64.</li>
  <li>Use intrinsics.</li>
  <li>Use -use_fast_math flag.</li>
</ul>
    <pre>
C:\Users\fab>nvcc -O3 -o e -use_fast_math e.cu
C:\Users\fab>e.exe <font color=red>2048</font> > NUL 
Time: 59s
</pre>
<p style="margin-bottom: 0;">
 The speed gain (2048spp) was monstrous. Unfortunately, so was the generated image.<br/>
  <picture>
    <source srcset="fastmath_issue.webp" type="image/webp">
   <img loading="lazy" src="fastmath_issue.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top:2ch;"/></picture>
   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>Probably a bug in the kernel.</small></i></span>

<p style="margin-bottom: 0;">   
   That bug took an afternoon to track down. Ultimately the culprit was determined to be fastmath flag which made intrinsic __powf too inaccurate for ray-marching. Replacing it with manual multiplication (<a href="f.html">f.cu</a>) solved the problem but also reduced spp to 600. There was also another issue.
<br/>    

  <picture>
    <source srcset="rand_issue600.webp" type="image/webp">
   <img loading="lazy" src="rand_issue600.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>
   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>Quite artistic but also quite not right.</small></i></span>
The pseudo-random generator had been converted in a hurry using the same seed uninitialized seed for a whole Streaming Multiprocessor. Using cuRAND and having a seed per block/thread solved the issue (<a href="g.html">g.cu</a>).<br/>
  <picture>
    <source srcset="pixar_600samples.webp" type="image/webp">
   <img loading="lazy" src="pixar_600samples.png" width="960" height="540" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>
   <span style="text-align: center; display: block; margin-bottom: 2ch;margin-top: 1ch;"><i><small>GPGPU rendering, 600spp. And still noisy.</small></i></span>
</p>

<div class='heading'>Denoising</div><hr/><p>
Starting with OptiX 5.0, NVidia provides an A.I based denoiser with a pre-trained neural network. Even though NVidia claimed the model was "trained using tens of thousands of images rendered from one thousand 3D scenes", I had reservations about the result. I didn't even check the API and instead used Declan Russeel's standalone executable<a name="back_7" style="text-decoration: none;" href="index.html#footnote_7"><sup>[7]</sup></a>.
<br/>    
<br/>    
The denoiser ran in 300ms and the result made me eat my words. It is so good it is mind-blowing. A denoised 600spp which takes 1mn to render is equivalent to a 40,960spp which takes 1h to render.
<br/>    

<script type="text/javascript">
  function t(e) {
    document.getElementById('t.png').src='denoisedtest' + e.value + '.png';
    document.getElementById('t.webp').srcset='denoisedtest' + e.value + '.webp';
  }
</script>
  <picture>
    <source srcset="denoisedtest600d.webp" id="t.webp" type="image/webp">
   <img loading="lazy" src="denoisedtest600d.png" width="960" height="540" id="t.png" style="width: 100%; height: auto; float:right; margin-bottom: 1ch; margin-top: 2ch;"/></picture>
 <form >
    <div style="width: 100%; display: inline-block; margin-top: 0px;">
      <center>
  <label><input type="radio" name="d" value="600" onclick="t(this);">600spp</label>
  <label><input type="radio" name="d" value="600d" onclick="t(this);" checked="checked">600spp (denoised)</label>
  <label><input type="radio" name="d" value="40960" onclick="t(this);">40,960spp</label>
  </center>
</div>
</form>

<p style="margin-bottom: 0;">
Below is presented the denoised version (d) from 1spp to 2048spp. There is a minimum under which denoising does not work well (1spp and 2spp :P). Inversely, there is a threshold after which returns diminishes. The sweet spot for this method seems to be around 512spp.<br/>
<script type="text/javascript">
  function setDenoisedImage(e) {
    document.getElementById('denoised.png').src='denoised' + e.value + '.png';
    document.getElementById('denoised.webp').srcset='denoised' + e.value + '.webp';
  }
</script>
<picture>
  <source srcset="denoised8.webp" id="denoised.webp" type="image/webp">
  <img loading="lazy" src="denoised8.png" width="960" height="540" id="denoised.png" style="width: 100%; height: auto; margin-top: 2ch; margin-bottom: 0ch;"/> 
</picture>
<p style="margin-bottom: 1ch;">
  <form >
    <div style="width: 100%; display: inline-block; margin-top: 0px;">
      <center>
  <label><input type="radio" name="d" value="1" onclick="setDenoisedImage(this);">1d</label>
  <label><input type="radio" name="d" value="2" onclick="setDenoisedImage(this);">2d</label>
  <label><input type="radio" name="d" value="4" onclick="setDenoisedImage(this);">4d</label>
  <label><input type="radio" name="d" value="8" onclick="setDenoisedImage(this);"  checked="checked">8d</label>
  <label><input type="radio" name="d" value="16" onclick="setDenoisedImage(this);">16d</label>
  <label><input type="radio" name="d" value="32" onclick="setDenoisedImage(this);">32d</label>
  <label><input type="radio" name="d" value="64" onclick="setDenoisedImage(this);">64d</label>
  <label><input type="radio" name="d" value="128" onclick="setDenoisedImage(this);">128d</label>
  <label><input type="radio" name="d" value="256" onclick="setDenoisedImage(this);">256d</label>
  <label><input type="radio" name="d" value="512" onclick="setDenoisedImage(this);">512d</label>
  <label><input type="radio" name="d" value="1024" onclick="setDenoisedImage(this);">1024d</label>
  <label><input type="radio" name="d" value="2048" onclick="setDenoisedImage(this);">2048d</label>
  </center>
</div>
</form>
</p>
<style type='text/css'>td.ref {  padding-bottom: 0ch; width:0;}</style><div class='heading'>References</div><hr/><p id='paperbox' style='text-align:left;'><table><tbody style='vertical-align: top;'><tr><td class='ref' style='width:1ch;'><a name="footnote_1"></a><a href="index.html#back_1">^</a></td><td  class='ref' style='width:4ch;'> [1]</td><td style='width:100%;text-align:left;' class='ref'><a href="../revisiting_the_businesscard_raytracer/index.html">Revisiting the Business Card Raytrace</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_2"></a><a href="index.html#back_2">^</a></td><td  class='ref' style='width:4ch;'> [2]</td><td style='width:100%;text-align:left;' class='ref'><a href="../postcard_pathtracer/index.html">Postcard sized path tracer</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_3"></a><a href="index.html#back_3">^</a></td><td  class='ref' style='width:4ch;'> [3]</td><td style='width:100%;text-align:left;' class='ref'><a href="../the_beautiful_machine/index.html">The beautiful machine</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_4"></a><a href="index.html#back_4">^</a></td><td  class='ref' style='width:4ch;'> [4]</td><td style='width:100%;text-align:left;' class='ref'><a href="https://twitter.com/mmozeiko/status/1257574246462570497">Twitter reply by Mārtiņš Možeiko</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_5"></a><a href="index.html#back_5">^</a></td><td  class='ref' style='width:4ch;'> [5]</td><td style='width:100%;text-align:left;' class='ref'><a href="SIMD_Tutorial.pdf">SIMD tutorial</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_6"></a><a href="index.html#back_6">^</a></td><td  class='ref' style='width:4ch;'> [6]</td><td style='width:100%;text-align:left;' class='ref'><a href="https://stackoverflow.com/questions/18634079/glibc-rand-function-implementation">glibc rand function implementation</a></td></tr><tr><td class='ref' style='width:1ch;'><a name="footnote_7"></a><a href="index.html#back_7">^</a></td><td  class='ref' style='width:4ch;'> [7]</td><td style='width:100%;text-align:left;' class='ref'><a href="https://declanrussell.com/portfolio/nvidia-ai-denoiser/">NVIDIA AI DENOISER by Declan Russell (<a href='Denoiser_v2.4.zip'>mirror</a>)</a></td></tr></tbody></table></p> <hr>
 <center>*