<script type="text/javascript">
  var disqus_identifier = "Duke3D_Code_Review" ;
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Duke Nukem 3D: Build Engine Internals"/>
		<meta name="Description" content="Duke Nukem 3D: Build Engine Internals"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>Duke Nukem 3D: Build Engine Internals</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="https://fabiensanglard.net/" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="http://fabiensanglard.net/" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="http://fabiensanglard.net/about/">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="http://fabiensanglard.net/faq/">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="http://fabiensanglard.net/rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="http://fabiensanglard.net/rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="http://fabiensanglard.net/rss.xml" />
<div id="date">
       February 14th, 2013</div>
   <h1>Duke Nukem 3D: BUILD ENGINE INTERNALS (PART 2 OF 4) <a href="code_legacy.php">>></a></h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="duke3d.png" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         <style type="text/css">

#box {
text-align: center;
padding: 0 0 0 3px;
}
    
#box img { 
margin: 0 0px;
}

blockquote.style1 {
  
  padding: 8px;
  
  width: 80%;
  
  background-color: #eeeeee;
  border: 1px solid #dddddd;
  
  
  margin: 5px;
  background-image: url(../quake2/images/openquote1.gif);
  background-position: top left;
  background-repeat: no-repeat;
  text-indent: 23px;

}
  
blockquote.style1 span {
  display: block;
  font-style:italic;
  background-image: url(../quake2/images/closequote1.gif);
  background-repeat: no-repeat;
  background-position: bottom right;
  text-align: justify;
}

</style>
<a href="http://en.wikipedia.org/wiki/Build_engine"><i>Build</i></a> powered Duke Nukem 3D and many other successful games such as 
<a href="http://en.wikipedia.org/wiki/Shadow_Warrior">Shadow Warrior</a> and <a href="http://en.wikipedia.org/wiki/Blood_(video_game)">Blood</a>
. Upon release on January 29th, 1996 it obliterated <i>Doom</i> engine with innovative features:
<ul>
    <li>Destructible environments.</li>
    <li>Sloped floor and ceiling.</li>
    <li>Mirrors.</li>
    <li>Look up and down.</li>
<li>Ability to fly, crouch and go underwater.</li>
<li><a href="https://fabiensanglard.net/fd_proxy/duke3d/blood_voxels.png">Voxel objects</a> (only appeared later in "Blood").</li>
<li>True 3D immersion (via teleporters).</li>
</ul>
<p>
The crown would be claimed back by highend Pentiums running Quake in June 1996 ... but for years <i>Build</i> delivered high value,  
freedom to designers and most important: Speed on the most common PCs of the time.<br/>
<br/>
Many thanks to <b>Ken Silverman</b> for proof-reading this article: His patience and diligent replies to my emails were instrumental.
<div style="clear:both;"></div>
</p>










<h3>Key concept: The Portal system.</h3>
<p id="paperbox"> 
  Most 3D engines partitioned their map via Binary Space Partition or an Octree. Doom for example preprocessed each
  map via a time consuming method (up to 30 minutes) resulting in a BSP Tree allowing :
<ul>
   <li>Sorting of walls.</li>
   <li>Position determination.</li>
   <li>Collision detections</li>
</ul>
<p>
  This speed gain was a trade-off : Walls <b>could not move</b>. <i>Build</i> removed this limitation by not preprocessing 
  its maps and relying on a <b>Portal system</b>:<br/>
<br/>
<div id="box">
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/duke_map.png" style=" 
  margin: 10px 20px 10px 0px; width: 419px; height: 421px;">
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/duke_map_portal.png" style=" 
  margin: 10px 20px 10px 0px; width: 419px; height: 421px;">
</div>
<p>
In this map, the game designer drew 5 sectors (left) and connected them together by marking walls as portal (right).<br/>
<br/>
The resulting world database of <i>Build</i> is ridiculously simple: One array for sectors and one array for walls.<br/>
<br/>
<pre class="long">
  

  Sectors         (5 entries):                         Walls  (29 entries)   :
  ============================                 ==========================================
  0| startWall:  0 numWalls: 6                  0|  Point=[x,y], nextsector = -1    // Wall in sector 0
  1| startWall:  6 numWalls: 8                 ..|                                  // Wall in sector 0
  2| startWall: 14 numWalls: 4                 ..|                                  // Wall in sector 0
  3| startWall: 18 numWalls: 3                  3|  Point=[x,y], nextsector =  1    // Portal from sector 0 to Sector 1
  4| startWall: 21 numWalls: 8                 ..|                                  // Wall for sector 0
  ============================                 ..|                                  // Wall for sector 0
                                               ..|
                    Sector 1 first wall   >>    6|  Point=[x,y], nextsector = -1
                                                7|  Point=[x,y], nextsector = -1
                                                8|  Point=[x,y], nextsector = -1   
                                                9|  Point=[x,y], <span style="color:red;">nextsector =  2</span>    //Portal from Sector 1 to Sector 2
                                               10|  Point=[x,y], nextsector = -1   
                                               11|  Point=[x,y], <span style="color:red;">nextsector =  0</span>    //Portal from Sector 1 to Sector 0
                                               12|  Point=[x,y], nextsector = -1
                    Sector 1  last  wall  >>   13|  Point=[x,y], nextsector = -1
                                               ..|
                                               28|  Point=[x,y], nextsector = -1
                                               ===========================================

</pre>
<br/>
<p>
<br/>
A misconception about <i>Build</i> is that it is a <b>raycaster</b>. It is not. At least most of the time. Vertices are projected first in player space and then a column/distance from POV are generated. There is an exception when sloped floors/ceiling are detected in a sector. In that case the engine uses raytracing with optimized floating-point ASM routines to find walls boundaries.<br/>
 <br/>
</p>


<h3>Runtime Overview</h3>
<p id="paperbox"> 
High level summary of a frame rendition :<br/>
<ol>
  <li>The <i>Game module</i> provides the <i>Engine module</i> with the sector where rendition should start (usually 
  the player sector but it may be a mirror sector).</li>
  <li>The <i>Engine module</i> navigates the portal system and visit <i>interesting</i> sectors. For each sector visited:
      <ul>
         <li>Group walls in sets called "bunches". Store those in a stack.</li>
         <li>Determine which sprites in that sector are visible. Store those in a stack.</li>
      </ul>
   <li>Consume bunches in a near to far order: Render solid walls and portals.</li>   
   <li>Stop the rendition: Let the <i>Game module</i> update the visible sprites.</li>
   <li>Render all sprites and transparent walls in a far to near order.</li>
   <li>Swap buffers.</li>
</ol>
<p>
Here are each steps in the code :<br/>
<pre class="long">

   <span style="color:green;">//  <span style="color:red;">1.</span> Each time an entity is moved, its current sector has to be updated.</span>
   updatesector(<span style="color:blue;">int</span> x, <span style="color:blue;">int</span> y, <span style="color:blue;">int</span>* lastKnownSectorID)
   
   displayrooms()
   {
      <span style="color:green;">// Render solid walls, ceilings and floors. Also populate a list of visible sprites (but DO NOT RENDER THEM).</span>
      drawrooms(<span style="color:blue;">int</span> startingSectorID) 
      {
          <span style="color:green;">// Clear "gotsector" variable, the "visited sectors" bit array.</span>
          clearbufbyte(&gotsector[0],(<span style="color:blue;">long</span>)((numsectors+7)>>3),0L);
          
          <span style="color:green;">// Reset umost and dmost array (occlusion tracker arrays).</span>
          
          <span style="color:green;">// <span style="color:red;">2.</span> Visit sectors and portal: Build a list of "bunch". </span>
          scansector(startingSectorID)
          {
             <span style="color:green;">// Visit all connected sectors and populate a BUNCH array.</span>
             <span style="color:green;">// Determine which sprites are visible and store a reference in tsprite, spritesortcnt++</span>
          }
          
          <span style="color:green;">//At this point, numbunches is set and bunches have been generated.</span>
          
          <span style="color:green;">// Iterate on the bunch stack. This is a (O)n*n operation since the algorith seach for the closest bunch each time.</span>
          <span style="color:blue;">while</span> ((numbunches > 0) && (numhits > 0))
          {
               <span style="color:green;">//Find closest bunch via a (o) n*n  method</span>
               <span style="color:blue;">for</span>(i=1;i&gt;numbunches;i++)
               {
                  <span style="color:green;">//Hard to read code in here :( :( </span>
                  bunchfront test
               }
              
               <span style="color:green;">//DRAW a bunch of wall identified by bunchID (closest)</span>
               drawalls(closest);
          }
      }
   
      <span style="color:green;">// <span style="color:red;">3.</span> Stop rendition and run the game module so it can update ONLY the visible sprites.</span>
      animatesprites() 
   
      <span style="color:green;">// <span style="color:red;">4.</span> Render partially transparent walls such as grid, windows and visible sprites (players, items).</span>
      drawmasks()
      {
          while ((spritesortcnt > 0) && (maskwallcnt > 0))
          {
              drawsprite
                 or
              drawmaskwall
          }
      }
   }
   
   <span style="color:green;">// GAME Module code. Draw 2D elements (HUD, hand with weapon)</span>
   displayrest();
   
   <span style="color:green;">// <span style="color:red;">5.</span> Swap buffers</span>
   nextpage() 
   
   
</pre>
<p>
  <br/>
  <u><b>Trivia :</b></u> If you study the code, here is the <a href="duke3d_code_review_unrolled.txt">fully unrolled loop</a> that I used as a map.</br>
  <br/>
  <u><b>Trivia :</b></u> Why is the swapping buffer method called <code>nextpage()</code>. Back in the 90's, the joy of VGA/VESA programming meant 
  doing double buffering manually: Two portions of the video RAM were reserved and alternatively used.
   Each portion was called a "page" One portion was used by the VGA CRT Module while the other was updated by the engine. 
   Swapping buffer was about setting the CRT to use the "next page" by changing the base address.
    You can read a lot about that in the <a href="http://downloads.gamedev.net/pdf/gpbb/gpbb23.pdf">Chapters 23 of
  Michael Abrash's Black Book of Graphic Programming: Bones and sinew</a>.<br/>
  Nowaday SDL alleviates this burden with a simple video mode flag <code>SDL_DOUBLEBUF</code> but the method name remain as an artefact of the past.

</p>

<br/>
<h3>1. Where to start rendering ?</h3>
<p id="paperbox"> 
No BSP means it is not possible to take a point <code>p(x,y)</code> and navigate tree nodes until we reach a leaf sector. In <i>Build</i> 
the current sector of
a player has to be <u>tracked</u> after each position update via <code>updatesector(int newX, int newY, int* lastKnownSectorID)</code>. 
The <i>Game module</i> calls this method of the <i>Engine module</i> very often.<br/>
<br/>
A naive implementation of <code>updatesector</code> would have scanned linearly each sectors and check each time if <code>p(x,y)</code> is
 <I>inside</I> the sector S. 
But <code>updatesector</code> is optimized with behavior pattern: 
<ol>
   <li>By supplying the <code>lastKnownSectorID</code>, the algorithm assume the player hasn't moved much and start checking sector 
   <code>lastKnownSectorID</code>.</li>
   <li>If #1 fails, the algorithm checks neighboring sectors of <code>lastKnownSectorID</code> using portals.</li>
   <li>Finally in a worse case scenario it checks all sectors with a linear search.</li>
</ol>
<p>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/duke_map.png" style="float:left; margin: 10px 20px 10px 0px; width: 419px; height: 421px;">
In the left map, the player last know sector is sector id <code>1</code>: Depending how much the player has 
moved, <code>updatesector</code> will test in order:
<ol style="margin-left: 450px;">
   <li><code>inside(x,y,1)</code> (Entity did not move enough to leave the sector).</li>
   <li><code>inside(x,y,0)</code> (Entity moved a little to a neighbor sector).<br/>
       <code>inside(x,y,2)</code>
   </li>
   <li><code>inside(x,y,0)</code>  (Entity moved a lot: every sectors in the game may potentially be scanned).<br/>
       <code>inside(x,y,1)</code><br/>
       <code>inside(x,y,2)</code><br/>
       <code>inside(x,y,3)</code><br/>
       <code>inside(x,y,4)</code><br/>
   </li>   
</ol>
The worse case scenario can be costy. But most of the time the player/projectiles haven't moved much and the operation is fast.
<div style="clear:both;">
</p>

<br/>
<h3>Inside details</h3>
<p id="paperbox">
  Inside is a noteworthy method for two reasons:
  <ul>
    <li>It can only use integers.</li>
    <li>It must run against sectors that can be concave.</li>
  </ul> 
  <p>
    I detail this method because it perfectly illustrate how <i>Build</i> works: With good old cross-product and XORs.<br/>
  </p>


<h3>Fixed point era and the ubiquitous cross-product</h3>
<p id="paperbox"> 
Since most of the PC of 90s did not have a Floating Point unit (386SX, 386DX and 486SX): <i>Build</i> exclusively uses integers.
<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/problem.png" style="margin-right: 15px; float:
 left; width: 430px; height: 219px;">
The example is a Wall with points A and B at its extremitis: The goal is to determine if the point is on the right or on the left.

<div style="clear:both;"/>
<br/>
<p>

<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/problem_fp.png" style="margin-right: 15px; float:
 left; width: 430px; height: 219px;">
In <a href="http://twimgs.com/ddj/abrashblackbook/gpbb61.pdf">Chapter 61 of Michael Abrash's Black Book of Programming: Frame of Reference</a> this
 is a single matter of performing a dot product and a comparaison.<br/>
</p>
<pre class="long" style="margin-left: 460px;">


  <span style="color:blue;">bool</span> inFrontOfWall(<span style="color:blue;">float</span> plan[4], <span style="color:blue;">float</span> point[3])
  {
       <span style="color:blue;">float</span> dot = dotProduct(plan,point);

       <span style="color:blue;">return</span> dot < plan[3];
  }


</pre>
<div style="clear:both;"/>
<p>
<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/problem_fixedp.png" 
style="margin-top:15px; margin-right: 15px; float: left; width: 430px; height: 219px;">
But in a world with no FP Unit this is done with a cross-product :<br/>
</p>
<pre class="long" style="margin-left: 460px;">

  <span style="color:blue;">bool</span> inFrontOfWall(<span style="color:blue;">int</span> wall[2][2], <span style="color:blue;">int</span> point[2])
  {
       <span style="color:blue;">int</span> pointVector[2], wallVector[2]  ;

       pointVector[0] = point[0] - wall[0][0];  // <span style="color:green;">Blue vector</span>
       pointVector[1] = point[1] - wall[0][1];

       wallVector[0] = wall[1][0] - wall[0][0]; // <span style="color:green;">Red vector</span>
       wallVector[1] = wall[1][1] - wall[0][1];

       <span style="color:green;">// crossProduct only compute the Z component: we just want the Z sign.</span>
       <span style="color:blue;">return</span> 0 < crossProduct(wallVector, pointVector);
  }
</pre>
<div style="clear:both;"/>
<p>
<br/>
<u><b>Trivia :</b></u> If you search for "float" in the source code of <i>Build</i> you will not get a single hit.<br/>
<u><b>Trivia :</b></u> The <code>float</code> type usage was democratized by Quake since it was targeted for Pentium and their Floating Point Unit.<br/>
<br/>
<u><b>EDIT August 7th, 2018 : Nico de Poel did some digging and found interesting things.</b></u><br/>
<br/>
<blockquote class="style1"> 
<br> 
<span> 
Recently I got caught in a discussion about the behavior of the Build engine and specifically Duke Nukem 3D on 486SX processors. I used to have one of those in the mid-90's and while Duke 3D ran fine on it for the most part, it would turn into a right slideshow whenever I neared a sloping floor in the game. On a friend's 486DX computer the same problem did not occur.<br> 
<br> 
I always assumed this was because the Build engine used some floating point calculations on sloping floors, and had to fall back on software FP emulation on the FPU-less 486SX, slowing the game down to a crawl. I read about similar experiences from other 486SX owners, which only reinforced my assumption.<br> 
<br> 
Then recently I got into this discussion, where someone vehemently denied the Build engine using any floating point calculations at all. This got me doubting my own story, and curious for an official explanation, so I went looking for a reliable source. That led me to re-read your code review of the Build engine, and I noticed you also mentioned that Build uses integers exclusively ("If you search for "float" in the source code of Build you will not get a single hit"). Reading that only puzzled me more.<br> 
<br> 
To get a definitive answer on why slopes are so slow on 486SX processors, I turned to the most reliable source I can think of: the original Duke 3D source code released in 2003. After looking around for slope-related code, I finally found what I was looking for: the Build engine does in fact use floating point assembly instructions in its slope rendering routines (setupslopevlin_,  slopevlin_) inside the A.ASM source file (<i>Note from Fab</i>: Also in C with <a href="https://github.com/fabiensanglard/chocolate_duke3D/blob/master/Engine/src/engine.c#L297">krecipasm</a>) . It's just a few short simple instructions (fild, fadd, fst, fstp), hardly worth mentioning, but it's enough to bring a non-FPU processor to its knees when invoked.<br> 
<br> 
I also looked into how the software floating point emulation works. Turns out it's very simple: the original Build engine source is written for the Watcom C/C++ compiler as you know, and the Watcom assembler tool (wasm.exe) used to assemble the rendering routines "by default, generates code with support for 8087 software emulation". This is mentioned in the codebase of what is now the Open Watcom project <a href="https://github.com/open-watcom/open-watcom-v2/blob/master/bld/wasmtest/test3/fpu1.asm">here</a>.<br> 
<br> 
Curiously enough, I did encounter an alternative implementation of the slope rendering routines that uses only integer instructions (setupslopevlin2_ and slopevlin2_), but those functions do not appear to be used anywhere in the code.<br> 
</span> 
</blockquote>

</p>




<h3>Inside a concave polygon</h3>
<p>
  Now that we have seen how a cross-product can be used to classify a point with regard to a wall, we can take a closer
   look at <a href="https://github.com/fabiensanglard/vanilla_duke3D/blob/master/SRC/ENGINE.C#L2733"><code>inside</code></a>.<br/>
  <br/>
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/inside_both.png" 
  style="margin: 10px 10px 10px 0px; width:430px ; height:219px; float:left;"/><div style="width=100%;">An example with 
  a concave polygon 
  and two points: Point 1 and Point 2.
  <ul style="margin-left:450px;">
    <li>Point 1 is considered outside.</li>
    <li>Point 2 is considered inside.</li>
  </u>
 </div>
  <div style="clear:both;"></div>
  <br/>
  <p>
  The "modern day" algorithm for point-in-polygon (PIP) is to cast a ray from the left and check how many edges are crossed. 
  An odd number means the point is inside, 
  an even number means the point is outside.<br/>
   <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/inside_p1.png" 
  style="margin: 10px 10px 10px 0px; width:430px ; height:219px;"/>
   <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/inside_p2.png" 
  style="margin: 10px 10px 10px 0px; width:430px ; height:219px;"/><br/>
  <br/>
  <i>Build</i> uses a variation of this algorithm: It counts the number of edges on each sides and combine the results with XORs :<br/>
   <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/inside_fixed_p1.png" 
  style="margin: 10px 10px 10px 0px; width:430px ; height:219px;"/>
   <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/inside_fixed_p2.png" 
  style="margin: 10px 10px 10px 0px; width:430px ; height:219px;"/>
  <br/>
  <br/>
  <u><b>Trivia : </b></u> Doom engine had to do through the same kind of gymastic 
  in <a href="https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/r_main.c#L162">R_PointOnSide</a>. 
  Quake used planes and Floating Point operations in <a href="https://github.com/id-Software/Quake/blob/master/WinQuake/gl_model.c#L96">Mod_PointInLeaf</a>.<br/>
  <br/>
  <u><b>Trivia : </b></u> If you found <code>inside</code> difficult to read, try to go through the 
    <a href="https://github.com/fabiensanglard/chocolate_duke3D/blob/master/Engine/src/engine.c#L4544">Chocolate Duke Nukem Version</a>
    : It features comments.
  
</p>






<h3>2. Portal and Opaque Walls</h3>
<p>
  The starting sector being provided to <i>Build</i> by the <i>Game Module</i>, rendition start with opaque walls in <code>drawrooms</code>: Two steps
   connected by a stack.<br/>
  <br/>
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/two_step_solidworlds_rendition.png" 
  style="margin: 10px 10px 10px 0px; width:535px ; height:118px; margin-left: auto;margin-right: auto;display: block;"/>
<br/>
<ul>
  <li>A preprocessing step flood the portal system (starting from <code>startingSectorID</code>) and store walls in a stack: <code>scansector()</code>.</li>
  <li>The stack is made of "bunch" elements.</li>
  <li>The stack elements are consumed by the renderer method: <code>drawwalls()</code>.</li>
</ul>
<p>
What is a bunch anyway ?<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/bunch.png" 
  style="float:left;margin: 10px 10px 10px 0px; width:170px ; height:374px;"/>
  A bunch is a set of walls that are considered "Potentially Visible". Those walls all belong to the same sector 
  and are continuously (connected by a point)
   facing the player.<br/><br/>
  Most of the walls in the stack will be discard, only a few will end up rendered to the screen.<br/>
<br/>
<b><u>Note :</b></u> The "wall proxy" is an integer referencing a wall in the list of "Potentially Visible" walls. 
The pvWalls array contains a reference to 
the wall in the world database plus its coordinates rotated/translated into player space and screen space.<br/>
<br/>
 <b><u>Note :</b></u> The datastructure is actually more complicated: Only the first wall in the bunch is stored on a stack. The rest is in
an array used as an id linked list: This is done so bunches can be moved up or down very fast in the stack.<br/>
<br/>
<b><u>Trivia :</b></u> The flooding process uses an array to mark visited "sectors". This array has to be cleaned up before each frame. 
It does not use the <a href="https://fabiensanglard.net/quakeSource/quakeSourceRendition.php#elegant_leaf_marking">framenumber trick</a> 
in order to determine if a sector has been visited for the current frame.<br/>
<br/>

<b><u>Trivia :</b></u> Doom engine used quantification to convert angles to screen column. <i>Build</i> uses 
<a href="https://github.com/fabiensanglard/chocolate_duke3D/blob/master/Engine/src/engine.c#L425">cos/sin matrix to convert</a>
 worlspace vertice to playerspace.<br/>
<br/>
<br/>
<br/>


<div style="clear:both;"></div>
<p> 
  The portal flooding heuristic is: Any portal facing the player and within the 90 degres FOV will be flooded. 
  This part is <a href="https://github.com/fabiensanglard/vanilla_duke3D/blob/master/SRC/ENGINE.C#L640" target="scansector_heuristic">hard to understand</a>
   but it is interesting because it shows how the developers tried to save cycles everywhere:<br/>
  <br/>
  <pre class="long">


    <span style="color:green;">//Cross product -> Z component</span>
    tempint = x1*y2-x2*y1;

    <span style="color:green;">// Using cross product, determine if the portal is facing us or not.</span>
    <span style="color:green;">// If it is: Add it to the stack and bump the stack counter.</span>
    <span style="color:blue;">if</span> (((uint32_t)tempint+262144) < 524288) {
        <span style="color:green;">//(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) is the squared length of the wall</span>
        <span style="color:blue;">if</span> (mulscale5(tempint,tempint) <= (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))
              sectorsToVisit[numSectorsToVisit++] = nextsectnum;
    }


  </pre>
<br/>
 <p>
  <div style="display:none;">
The first test check if <code>mulscale5</code> would overflow.<br/>
The second test check if the portal is within the 90 degres FOV frustrum.
</div>
</p>






<h3>Bunch generation</h3>
<p id="paperbox"> 
  Walls inside a sector are grouped into "bunches". Here is a drawing to help understand the idea :<br/>
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/bunch_generation.png" 
  style="margin: 10px 10px 10px 0px; width:754px ; height:397px;  margin-left: auto;margin-right: auto;display: block;"/><br/>
  In the previous drawing we can see that three sectors have generated four bunches:
  <ul>
    <li>Sector 1 generated one bunch containing one wall.</li>
    <li>Sector 2 generated one bunch containing three walls.</li>
    <li>Sector 3 generated two bunches, both containing two walls.</li>
  </ul>
  <p>
    Why are walls even grouped into bunches ? Because <i>Build</i> did not have any data structure to allow fast sorting. 
    It extracts the 
    nearest bunch via a (O&sup2;) process which would have been very costy if it had been done on a per wall basis. The cost 
    is much lower on a per wall set basis.
</p>








<br/>
<h3>Bunch consumption</h3>
<p id="paperbox"> 
Once the bunches stack is populated the engine will draw them near to far. The engine select the first bunch that is no occluded by an other bunch
 (there is always at least one bunch that satisfies this condition ):<br/>
<pre class="long">


    <span style="color:green;">/* Almost works, but not quite :( */</span>
    closest = 0; 
    tempbuf[closest] = 1; 

    <span style="color:blue;">for</span>(i=1; i < numbunches; i++){
         <span style="color:blue;">if</span> ((j = bunchfront(i,closest)) < 0) 
             <span style="color:blue;">continue</span>;

         tempbuf[i] = 1;

         <span style="color:blue;">if</span> (j == 0){
            tempbuf[closest] = 1;
            closest = i;
         }
    }



</pre>
<p>
<u><b>Note :</b></u> Despite the name of the variable, the bunch selected is not necessarly the closest.<br/>
<br/>
<style type="text/css">
blockquote.style1 
  {
      
      padding: 8px;
      
      width: 80%;
      
      background-color: #eeeeee;
      border: 1px solid #dddddd;
      
      
      margin: 5px;
      background-image: url(../quake2/images/openquote1.gif);
      background-position: top left;
      background-repeat: no-repeat;
      text-indent: 23px;
    
    }
    
    blockquote.style1 span 
    {
      display: block;
      font-style:italic;
      background-image: url(../quake2/images/closequote1.gif);
      background-repeat: no-repeat;
      background-position: bottom right;
      text-align: justify;
    }
</style>
<u>Explanation of the selection by Ken Silverman :</u><br/>
  <blockquote class="style1" style="margin-left:6em;">
<br/>
  <span style="margin-left">
  Given 2 bunches, first see if they overlap in screen-x coordinates.
 If they do not, then there is no overlapping violation and move on to the next pair of bunches. To compare bunches, find the 
 first wall on each of the bunches that overlaps in screen-x coordinates. Then it becomes a wall to wall test.<br/>
 <br/>
 The wall to wall 
 sorting algorithm is: Find the wall that can be extended to infinity without intersecting the other wall. (NOTE: if they both 
 intersect, then it is an invalid sector and you should expect a drawing glitch!) The points of the other (non-extended) wall must
  both be on the same side of the extended wall. If that happens to be the same side as the player viewpoint, then the other wall 
  is in front, otherwise it is behind.<br/>
  <br/>
  <br/>
  </span>
</blockquote>
<br/>
<p>
<code>bunchfront</code> is fast, complicated and not perfect so <i>Build</i> 
<a href="https://github.com/fabiensanglard/chocolate_duke3D/blob/master/Engine/src/engine.c#L2999">
double checks</a> before sending the result to the renderer.
That makes the code ugly but the result is O(n) instead of  O(n&sup2;).<br/>
<br/>
 Each bunch selected is sent to the renderer <code>drawalls(closest)</code>: This part of the code will draw as much wall/ceiling/floor as possible.<br/>
<br/>
</p>



<h3>Wall/Ceiling/Floor rendition</h3>
<p id="paperbox">
  The key to understanding this part is that the screen is rendered starting from top and bottom edges. Each wall/portal makes the rendere progress toward the vertical center of the screen. Floor and ceilings are the gaps located between wall/portal in screen-space.<br/>
  <br/>
  At the core of the renderer are two occlusion arrays. Together they keep track of the occlusion upper and lower bounds of each column of pixels on screen.:

<pre class="long">

   <span style="color:green;">//The maximum software renderer resolution is 1600x1200</span>
   <span style="color:blue;">#define</span> MAXXDIM <span style="color:green;">1600</span>

   <span style="color:green;">//FCS: (up-most pixel on column x that can still be drawn to)</span>
   <span style="color:blue;">short</span> umost[MAXXDIM+1];

   <span style="color:green;">//FCS: (down-most pixel on column x that can still be drawn to)</span>
   <span style="color:blue;">short</span> dmost[MAXXDIM+1];

</pre>
<p>
<u><b>Notes :</b></u> The engine tends to rely on arrays of primitive types instead of array of struct.<br/>
<br/>
The engine writes vertical span of pixels starting from the upper or lower bound. Bounds values progress toward each other. 
When they encounter the column of pixels is entirely occluded an a counter is decreased:<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/occlusion/duke_occ_principle.png" 
style="margin-left: 78px;margin-right: auto;display: block; width:605px ; height:206px;"/><br/>
<b><u>Note :</u></b> Most of the time the occulusion array is only partially updated: Portals leaves "holes".<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/occlusion/occ_pixels.png" 
style="margin-left: auto;margin-right: auto;display: block; width:654px ; height:227px;"/><br/>
<br/>
Each wall in the bunch is projected in screenspace and then :
<ul>
    <li>If it is a solid wall:
    <ul>
        <li>Render ceiling if visible.</li>
        <li>Render floor if visible.</li>
        <li>Render wall if visible</li>
        <li>Mark the entire column as occluded in the occlusion array.</li>
     </ul>
     </li>
     <li>If it is a portal:
        <ul>
           <li>Render ceiling if visible.</li>
            <li>Render floor if visible.</li>
           <li>Peek into the next sector:</li>
                <ul>
                    <li>If the next sector ceiling is lower than current sector ceiling: Draw a "DOWN" step partial wall.</li>
                    <li>If the next sector floor is higher than current sector floor: Draw an "UP" step  partial wall.</li>
                </ul>
            <li>Update the occlusion array according to what has been drawn.</li>
        </ul>
        
     </li>
</ul> 
<p>

<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/occlusion/occ_example.png" 
style="margin-left: auto;margin-right: auto;display: block; width:624px ; height:464px;"/><br/>
<br/>
<br/>
  <u>Stop condition :</u> :This loop will go on until all bunches have been consumed or all pixels columns are marked as completed.<br/>

It is much easier to understand with an example breaking down a scene such as the familiar auditorium :<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/movies/inside-poster.jpg" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The maps shows the portals in red and the solid walls in white:<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/maps/inside_map.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The first bunch three walls are projected in screenspace: Only the bottom parts made it to the screen:<br/><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/first_bunch.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The engine can hence render the floor vertically:<br/><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/first_bunch_render1.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The engine next peek into the next sector of each three walls: Since they are not <code>-1</code> those walls are portals.
 By looking at the floor height difference
the engine figures out it has to draw an "UP" step for each of them:<br/><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/first_bunch_render2.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
And that is all what is rendered with the first bunch. Now the second bunch is projected in screen space:<br/>
<br/><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/second_bunch.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
Again, only the lower part of the wall made it which means the engine can render the floor:<br/><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/second_bunch_floor.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
Peeking in the next sector for the longest portal allows to draw a "STEP UP". However, the second portal in the bunch leads to a
 lower sector: No STEP is drawn.<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/second_bunch_walls.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The process repeats itself. Here is a video that shows the full scene:<br/>
<br/>
<b>Theatre Inside:</b>
<br/>
<div style="float:left; margin-right:10px">

<video width="640" height="480" preload="none" poster="../fd_proxy/duke3d/movies/inside-poster.jpg" controls>
  <source src="../fd_proxy/duke3d/movies/inside-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>

</div>
   Upon drawing the door portal, <i>Build</i> drew a step up and a step down with two different textures. How is this 
   possible with only one <code>picnum</code> ??! :<br/>
    <br/>
    This is possible because the wall structure has a "<code>picnum</code>", an "<code>overpicnum</code>" for 1-way or masked walls, and a flag 
    that allows the lower texture index to be stolen from the opposite sector's wall. It was a
     hack to keep the size of the sector structure small.

<br/>
<br/>
<div style="clear:both;"></div><br/>
<u><b>Note : </b></u> The Quicktime format is used because the players allows to grab the cursor and move back and forth 
with instant feedback. I found it very useful
to study the engine and far superior to any other format/hosting solution since going backward requires buffering.<br/>


<br/>
Two other scenes compiled into a video:<br/>
<br/>
<b>Street :</b>
<br/>
<div style="float:left; margin-right:10px">

<video width="640" height="480" preload="none" poster="../fd_proxy/duke3d/movies/outside-poster.jpg" controls>
  <source src="../fd_proxy/duke3d/movies/outside-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>

</div>

<u>0:00 to 0:08 :</u> The sidewalk lower line portal is used to draw a vertical piece of floor.<br/>
<br/>
At 0:08 the engine lookup the sector floor level after the sidewalk. Since it is going up the portal wall is drawn: The sidewalk is rendered.<br/>
<br/>
<u>0:18 to 0:30 :</u> A bunch made of the two sidewalks on the left is used to render a huge piece of floor.
<div style="clear:both;"></div>





<br/>
<b>Theatre Outside:</b>
<br/>
<div style="float:left; margin-right:10px">

<video width="640" height="480" preload="none" poster="../fd_proxy/duke3d/movies/theatre-poster.jpg" controls>
  <source src="../fd_proxy/duke3d/movies/theatre-desktop.m4v" type="video/mp4">
  Your browser does not support the video tag.
</video>

</div>
Interesting scene featuring a window.
<div style="clear:both;"></div>
<br/>
This last video shows a window. Here are some details about how it is done :<br/>
<br/>
<u>The map :</u><br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/maps/theatre_map.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>

The first bunch features four walls, once projected in screenspace they allow drawing of ceiling and floor:<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/theatre/ceiling_floor.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The left wall in the bunch is a portal. Upon inspection it turns our the next sector floor is at the same height and the next sector 
ceiling is higher: No steps walls
have to be rendererd here. The second wall is an opaque wall (white in the map). It result in a full column of pixels draw:<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/theatre/opaquewall1.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The third wall is a portal. Peeking at the next sector height shows that is is lower so a "DOWN STEP WALL" has to be rendered:<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/theatre/portal_stepdown.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
The same peeking process goes for the floor. Since it is higher, an "UP STEP WALL" is drawn:<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/theatre/portal_stepup.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>
Finally the last wall is processed. It is not a portal so full columns of pixels are drown.<br/>
<br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/breakdown/theatre/opaquewall2.png" 
style="margin-left: auto;margin-right: auto;display: block; width:640px ; height:480px;"/><br/>
<br/>

<br/>
<u><b>Trivia : </b></u> Since walls are draws vertically, <u>Build</u> stores textures rotated 90 degres in RAM. This improves the cacheline hit rate tremendously. 
</p>

<h3>3. Pause</h3>
<p id="paperbox"> 
  At this point the visible solid walls have made it to the offscreen buffer. The engine stops and let the <i>Game Module</i> runs so it can animate the visible sprites.
  Those sprites are exposed in the following array:<br/>
  <pre class="long">


    <span style="color:blue;">#define</span> MAXSPRITESONSCREEN 1024
    <span style="color:blue;">extern</span> <span style="color:blue;">long</span> spritesortcnt;
    <span style="color:blue;">extern</span> spritetype tsprite[MAXSPRITESONSCREEN];

  </pre>
  
</p>





<h3>4. Sprite rendering</h3>
<p id="paperbox"> 
  Once the <i>Game Module</i> is done animating the visibles sprites, <i>Build</i> draws then: Far to Near in <code>drawmasks()</code>.<br/>
  <ol>
    <li>The distance of each sprite to the POV is computed.</li>
    <li>The array of sprites is sorted via Shell Sort. <span style="color:red;"></span></li>
    <li>The engine consumes alternatively from two lists (one for sprites and one for transparent walls).</li>
    <li>Once one list has been exhausted the engine tries to minimize branching and switch to a loop that only render one kind: Sprites or walls.</li>
  </ol>
  <p>
</p>



<h3>Profiling</h3>
<p id="paperbox"> 
  Running <i>Duke Nukem 3D</i> with "Instruments" gave an idea of were CPU cycles are consumed :<br/>
  <br/>
  <u>Main method :</u><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/profiling/profiling_01_main.png" 
  style=" box-shadow: rgb(119, 119, 119) 3px 3px 3px; margin: 10px 10px 10px 0px; width:695px ; height:190px;"/><br/>
  No surprise: Most of the time is spent rendering opaque walls and waiting for an opportunity to flip the buffer (vsync enabled).
  <br/>
  <br/>
  <br/>
  <u>displayrooms method :</u><br/>
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/profiling/profiling_02_walls.png" 
  style=" box-shadow: rgb(119, 119, 119) 3px 3px 3px; margin: 10px 10px 10px 0px; width:697px ; height:227px;"/><br/>
  93% time is spent drawing the solid walls. 6% is dedicated to sprites/transparent walls rendition.
  <br/>
<br/>
<br/>
 <u>drawrooms method :</u><br/>
 <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/profiling/profiling_021.png" 
  style=" box-shadow: rgb(119, 119, 119) 3px 3px 3px; margin: 10px 10px 10px 0px; width:698px ; height:196px;"/><br/>
  Despite its complexity the Visible Surface Determination only accounts for 0.1% of the solid walls rendition step.
<br/>
<br/>
<br/>
<u>drawalls method :</u><br/>
<img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/profiling/profiling_022.png" 
  style=" box-shadow: rgb(119, 119, 119) 3px 3px 3px; margin: 10px 10px 10px 0px; width:693px ; height:306px;"/><br/>
The *scan functions are the interface between the engine and the ASM routines:
<ul>
  <li><code>wallscan()</code>:: walls</li>
<li><code>ceilscan()</code>: unsloped ceilings</li>
<li><code>florscan()</code>: unsloped floors</li>
<li><code>parascan()</code>: parallaxing skies (uses <code>:wallscan()</code>: inside)</li>
<li><code>grouscan()</code>: sloped ceilings and floors - slower</li>
</ul>
<p>
  <u>Comments by Ken Silverman :</u><br/>
  <blockquote class="style1" style="margin-left:6em;">
<br/>
  <span style="margin-left">
  ceilscan() and florscan() are complicated by the fact that they convert a list of vertical 
  spans to a list of horizontal spans. This is what all those "while" loops in there are for. 
  The reason I do this is because it is much faster to texture-map unsloped ceilings and floors
   in the horizontal direction. This is a critical optimization in the engine that you seem to 
   have overlooked. I have seen similar while loops in the Doom source code as well.<br/>
  <br/>
  <br/>
  </span>
</blockquote>
  <br/>
  <br/>
    Ken sent an <A href="http://advsys.net/ken/evaltut/evaldraw_tut.htm">evaldraw</a> script, <A href="span_v2h.kc">span_v2h.kc</a> 
    that shows how ceilscan() and florscan() convert a list of vertical spans to a list of horizontal spans.: <br/>
    <br/>
    <img src="../lazy_load/grey.gif" data-original="evalDraw.png" 
  style="margin-left: auto;margin-right: auto;display: block; box-shadow: rgb(119, 119, 119) 3px 3px 3px;  width:788px ; height:368px;"/>
    
  <br/>
<br/>
<br/>
<br/>
<u>displayrest method :</u><br/>
  <img src="../lazy_load/grey.gif" data-original="/fd_proxy/duke3d/profiling/profiling_05_rest.png" 
  style=" box-shadow: rgb(119, 119, 119) 3px 3px 3px; margin: 10px 10px 10px 0px; width:695px ; height:145px;"/><br/>
  <code>displayrest</code> is from the <i>Game Module</i>. The major cost is once again drawing (the weapon). The status bar is not 
  drawn each frame, it is only patched when the ammo counter is updated.
<br/>
<br/>
<br/>
</p>









<h3>VGA and VESA Trivia</h3>
<p id="paperbox"> 
Most people ran <i>Build</i> in 320x240 thanks to VGA's X-Mode. But the engine also supported Super-VGA 
resolution thanks to the VESA standard. The Vanilla source
code is packed with VESA code that allowed portable resolution detection and rendition.<br/>
<br/>The nostalgics can read about VESA Programming <a href="http://www.monstersoft.com/tutorial1/">in this good tutorial</a>. 
Today all what remains in the code is method names such as <code>getvalidvesamodes()</code>.<br/>
<br/>
</p>


<h3>Sound engine</h3>
<p id="paperbox"> 
  Duke3D had a very impressive sound system engine at the time. It was even able to mix sound effect in order to simulate reverberation.
  Read more about it in <a href="https://github.com/fabiensanglard/chocolate_duke3D/blob/master/Game/src/audiolib/mvreverb.c">reverb.c</a>.
<br/>
</p>

<h3>Legacy</h3>
<p id="paperbox"> 
<i>Build</i> was very hard to read. I listed all the things making it difficult in the next page:<br/>
<br/>
<a href="code_legacy.php">Duke Nukem 3D and Build engine: Source code issues and legacy</a>
</p>


<h3>Recommended Readings</h3>
<p id="paperbox">    
  <ul>
  <li>If you want to read about another game that was portal based, I recommend this <a href="http://nothings.org/gamedev/thief_rendering.html">excellent Post-Mortem</a> by Sean Barrett about Thief: The Dark Project.</li>
  <li>Many interviews of Ken Silverman :</li>
  <ul>
  <li><a href="http://www.classicdosgames.com/interviews/kensilverman.html">21 November 2005</a> from classicdosgames.com 
    (<a href="https://fabiensanglard.net/fd_proxy/duke3d/interviews/ks_interview_classicdos.zip">mirror</a>).</li>
  <li><a href="http://www.strifestreams.com/KenSilvermanInterview">2005</a> from strifestreams.com 
    (<a href="https://fabiensanglard.net/fd_proxy/duke3d/interviews/ks_interview_strife.zip">mirror</a>).</a></li>
  <li><a href="http://www.3drealms.com/news/2006/02/the_apogee_legacy_8.html">February 27, 2006</a> from 3drealms.com 
    (<a href="https://fabiensanglard.net/fd_proxy/duke3d/interviews/ks_interview_3drealms.zip">mirror</a>).</li>
  <li><a href="http://misterdai.yougeezer.co.uk/2010/03/25/retro-game-interview-ken-silverman-duke-nukem-3d/">March 25, 2010</a> misterdai.yougeezer.co.uk 
    (<a href="https://fabiensanglard.net/fd_proxy/duke3d/interviews/ks_interview_misterdai.zip">mirror</a>).</li>
   <li><a href="http://videogamepotpourri.blogspot.ca/2012/05/interview-with-ken-silverman.html">May 01, 2012</a> videogamepotpourri.blogspot.ca 
    (<a href="https://fabiensanglard.net/fd_proxy/duke3d/interviews/ks_interview_popourri.zip">mirror</a>).</li>
  
  </ul>
  </ul>
</p>     
<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

