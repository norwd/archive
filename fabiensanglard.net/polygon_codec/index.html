<script type="text/javascript">
  var disqus_identifier = "polygon_codec";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="iPhone 3D engine, iOS, Android 3D engine, openGL ES 1.1, openGL ES 2.0, tutorial, specularMapping, homogenuous coordinate, clipping"/>
		<meta name="Description" content="Iphone 3D engine"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>Homogeneous clipping clipping</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="https://fabiensanglard.net/" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="http://fabiensanglard.net/" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="http://fabiensanglard.net/about/">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="http://fabiensanglard.net/faq/">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="http://fabiensanglard.net/rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="http://fabiensanglard.net/rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="http://fabiensanglard.net/rss.xml" />
<div id="date">
       June 26th, 2011</div>
   <h1>Polygon Codec/Homogeneous clipping</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="polyCodec.png" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         
	<style>
	blockquote.style1 
	{
  		
  		padding: 8px;
  		
  		width: 80%;
  		
  		background-color: #eeeeee;
  		border: 1px solid #dddddd;
  		
  		
  		margin: 5px;
  		background-image: url(../quake2/images/openquote1.gif);
  		background-position: top left;
  		background-repeat: no-repeat;
  		text-indent: 23px;
  	
  	}
  	
  	blockquote.style1 span 
  	{
    	display: block;
    	font-style:italic;
    	background-image: url(../quake2/images/closequote1.gif);
    	background-repeat: no-repeat;
    	background-position: bottom right;
    	text-align: justify;
  	}
  	</style>


		
			Back in the summer of 2009 I was working on a 3D engine that would power my next game: <a href="http://itunes.apple.com/us/app/shmup/id337663605?mt=8">SHMUP</a> a 3D shoot'em up "à la" Ikaruga. The target was the very first iPhone (now called iPhone 2G). Despite being impressive on paper (600Mhz with dedicated GPU), the hardware had several issues and the lack of dedicated VRAM was a huge bottleneck.<br/>
			<br/>
			Unwilling to settle for anything less than 60 frames per second I became obsessed with saving bandwidth and I tried different approach until an idea proved to be not so bad...but I had to dive in the four dimensionnal world of homogeneous coordinates to make it work.
			</p>
		</p>
<br/>
<h3>60 frames per seconds</h3>

			<p id="paperbox"> 
			Shmups are a great type of game: They provide instant fun, are usually packed with eye candies...and challenging to program because anything less than 60 frames per second ruins the magic. In this regard "Ikaruga" is often regarded as the best shmup ever created. If you don't know this legendary game, check out these videos:<br/>
			<br/>
			<iframe style="width:100%;" width="640" height="510" src="https://www.youtube.com/embed/LES0bAg0dBk" frameborder="0" allowfullscreen></iframe>
			<br/>
			<br/>
			It looks easy as the beginning but things gets nasty after the first Act:<br/>
			
			<br/>
			<iframe style="width:100%;" width="640" height="510" src="https://www.youtube.com/embed/EGNSdcy-apU#t=2m20s" frameborder="0" allowfullscreen></iframe>
			<br/>
			<br/>
			Shortly after the released of the iPhone, Sega stated that the iPhone was <a href="http://gizmodo.com/5032743/john-carmack-says-iphone-as-powerful-as-dreamcast-more-powerful-than-ds-and-psp-combined">as powerful as a Dreamcast</a> (In reality it was <u><b>not even close</b></u>). I was hoping for a port from Treasure but it never came so I decided to roll up my sleeves, write my own game and craft my own 3D engine to run it.
			</p>






<h3>Crafting the 3D engine</h3>
			
			<p id="paperbox">
			Pretty early in the development I found out that the CPU and GPU were far outperforming the data bus capabilities. In a nutshell the more data exchanged between the CPU and the GPU = the slower the engine.<br/>
			I started to become obsessed with saving bandwidth, the list of optimizations can be found on the <a href="http://fabiensanglard.net/dEngine/">dEngine</a> page. From mipmapping to normal/tangent compression, VBO storage and even changing the framebuffer color space (R8G8B8 to R5G6B5 = yummy): A lot was investigated. But something more could be achieved to squize the machine a bit further and it had to do with visible surface determination.
			
			</p>			
			





<h3>Visibile surface determination</h3>
			
			<p id="paperbox">

				This is what Michael Abrash has to say about  Visibile surface determination:

				<blockquote class="style1"> 
<br/> 
<span> 
<br/> I want to talk about what is, in
my book, the toughest 3-D problem of all, visible surface determination (drawing the proper
surface at each pixel), and its close relative, culling (discarding non-visible polygons as quickly
as possible, a way of accelerating visible surface determination).  In the interests of brevity, I’ll
use the abbreviation VSD to mean both visible surface determination and culling from now on.<br/>
<br/>
Why do I think VSD is the toughest 3-D challenge?  Although rasterization issues such as
texture mapping are fascinating and important, they are tasks of relatively finite scope, and are
being moved into hardware as 3-D accelerators appear; also, they only scale with increases in
screen resolution, which are relatively modest.<br/>
<br/>
In contrast, VSD is an open-ended problem, and there are dozens of approaches currently in
use.  Even more significantly, the performance of VSD, done in an unsophisticated fashion,
scales directly with scene complexity, which tends to increase as a square or cube function, so
this very rapidly becomes the limiting factor in doing realistic worlds.  I expect VSD increasingly
to be the dominant issue in realtime PC 3-D over the next few years, as 3-D worlds become
increasingly detailed.<br/>
<br/>
<br/> 
</span> 
</blockquote> 
<br/>
<p>
I agree a lot with this: VSD is the toughest 3-D challenge of all.
				Before even sending anything to render to the GPU a 3D engine must perform a key step: Determine what is visible on the screen. If you don't do this you have to send the entire world to the GPU: It would take too much time and the game would run at 0.5 frames per second.<br/>
				<br/>
				As an example every engine from id software used <a href="http://fabiensanglard.net/quakeSource/quakeSourceRendition.php">Binary Space Partition with PVS</a> (at least until Doom3 when they switched to portals). But most of the time the world is preprocessed by slicing it up via an <a href="http://en.wikipedia.org/wiki/Octree">Octree</a>. Once the world is segmented, at runtime it can be recursively tested against the view frustrum and hence <u><b>most</b></u> of what is sent to the GPU ends up contributing to a pixel.<br/>
				<br/>
				But there are several issues with an octree:<br/>
				<ul>
					<li>Slicing the world create a lot of additional polygons (each time a splitting plan cut a polygon, it results in three sub-polygons). This result in more polygons to render when a block is fully visible.
					</li>
					<li>
						All the polygons returned are not necessarily renderered. A block of the octree can intersect with the view frustrum but contribute nothing to the screen.
					</li>
					<li>It is not the best structure when the camera path is predetermined. Freedom of movement is mandatory in a First Person Shooter: Wherever the player is, its view frustrum can be tested against the Octree and the right polygons can be sent to the GPU for rendition. But in the case of a shmup we can clearly use a structure or design that takes advantage of the determinism of the camera path.
					</li>
				</ul>
			
			</p>
            <br/>
<h3>Polygon Codec</h3>
			<br/>
			<p id="paperbox">
			"Polygon codec" is a simple idea: Since the camera path is predetermined the set of visible polygons is precalculated for each frame and stored compressed (it is an extension of the PVS (Probably Visible Set) from the Quake engines). At runtime the CPU decompress the visible set as a stream of updates to the indice list of each object.<br/>
			<br/>
			<u>Preprocessing :</u><br/>
			<br/>
			For each frame in the camera path of the level:
			<ul>
				<li>Generate the Visible Surface Set for the current frame.</li>
				<li>Based on the signed area keep only the 2500 biggest polygons in the set and discard the rest. This set is called SVS (Significant Visible Set)</li>
			</ul>
			<p>
			For each blocks of 60 frames:
			</p>
			<ul>
				<li>Keep the first frame SVS as a full update, this is similar as the keyframe in a video codec.</li>
				<li>Delta encode the next frame based on the previous, recording only the updates (objectId + polygonId to remove and objectID + polygonId to add).</li>
			</ul>
			<p>
			<br/>
			<u>Runtime :</u>
			
			At runtime, the engine upload the object vertices to a VBO and just maintain an indice list for each object thanks to what was precalculated.<br/>
			<br/>
			
			
			
			&nbsp;&nbsp;&nbsp;<u>For each object:
			</u>
			
			<ul>
				<li>
			If the frame is a keyframe just copy the indices set provided and send it to the GPU. A simple <code>memcpy</code>: it doesn't get simpler than that !.<br/>
				</li>
				<li>If the frame is a deltaframe, just apply the deletion and addition the the indices and send to the GPU. Very quick too !</li>
			</ul>
			<p>
			As a result, the runtime process time is greatly reduced to virtually 0 operations and provides only polygons that will contribute to the scene.
			</p>
			</p>
			








<h3>The Vertex Pipeline</h3>
			
			<p id="paperbox">
			An idea if you cannot implement is <u>worthless</u>. Poylgon Codec is a simple idea but we need to fully understand the GPU pipeline to make it happen. You probably already know about this but here is a reminder just so we are on the same page:<br/>
			<br/>
			<img style="float:right;" src="../fd_proxy/polygon_codec/GPU-pipeline-small.jpg"/>
					<br/>
					<br/>
					<br/>
					<br/>
					<br/>
					<br/>
					<br/>
					<br/>					
					<br/>
					<ol>
						<li>The vertices database resides either on the CPU RAM or in the GPU VRAM in a VBO.</li>
						<br/>
						<li>Usually vertices have a X,Y and a Z component. The driver adds a fourth one : Called W it is later used for perspective and initialized with value 1. A point is now four dimensional and expressed in homogeneous coordinate</li>
						<br/>
						<li>The vertex in Model space is first transformed to Eye Space via the GL_MODEL_VIEW matrix, this is the <b>Model view Transform</b></li>
						<br/>
						<li>Next is the <b>Perpsective Transform</b> that takes points in Eye Space and transform them in Clipping space. At this point W is not 1 anymore and we are truly dealing with a four dimensionnal coordinate.</li>
						<br/>
						<li>The <b>Perspective Divide</b> bring things back to three dimensions and actually fake perspective: Things far away shrink and things closer get bigger.</li>
						<br/>
						<li>Finally the <b>Viewport Transform</b> takes the coordinates from a [-1,1] value set to pixel coordinate (X,Y) and Zbuffer values.</li>
						<br/>
					</ol>
					<br/>
					All thoses steps are extensively covered in any good 3D book (check out <a href="http://www.realtimerendering.com/">Real-Time Rendering</a> as an example).<br/>
					<br/>
					<br/>
					One aspect that is rarely covered is how to perform clipping in homogeneuous coordinate.
					Because Polygon Codec requires the area of a polygon on the screen (when it selects only the biggest ones): we cannot ignore with step.<br/>
					<br/>
					There are a few gems that will help you to understand homogeneous coordinates:<br/>
					<br/>
					<ul>
						<li>The original <a href="clippingdocument/p245-blinn.pdf">"CLIPPING USING HOMOGENEOUS COORDINATES"</a> by James F. Blinn and Martin E. Newell</li>			
						<li><a href="http://www.amazon.ca/Jim-Blinns-Corner-Graphics-Pipeline/dp/1558603875/ref=sr_1_1?ie=UTF8&qid=1308682944&sr=8-1">A Trip Down the Graphics Pipeline</a> by Jim Blinn (yes the same Blinn that co-authored the paper above).</li>
						<li><a href="clippingdocument/Clipping.pdf">"CLIPPING"</a>by Kenneth I. Joy</li>
						<li>A set of links to PDF treating of homogeneuous clipping: <a href="http://www.ece.uvic.ca/~btill/20007/additional/">Here</a>  (<a href="clippingdocument/clippingdocument.zip">mirror</a>).</li>
						
					</ul>
					<br/>
					Most of the drawing and code found on this webpage were derivated from the material previously listed.
					<div style="clear:both;"></div>
			
			
			</p>

			



<h3>Homogeneous coordinate clipping: Theory</h3>
			
	<p id="paperbox">
		Homogeneous coordinate clipping is the art of clipping in four dimensions avoiding in the process to output a <code>W=0</code> (division by zero in the next stage of the pipeline).<br/>
		Since the W divide is essentially a projection on the <code>W=1</code> line, it can be visualized as follow for the [X,W] couple (the same would go for [Y,W] and [Z,W]):<br/>
		<br/>
		
							

	<img style="display:block; margin-left:auto;margin-right:auto;" src="../fd_proxy/polygon_codec/homogeneousCoordinates.jpg" />



<br/>
In the next drawing, we can see that thanks to the W divide (projection on W=1 line), objects far away from the point of view will appear smaller than objects located closer.	


				<img  style="display:block; margin-left:auto;margin-right:auto;" src="../fd_proxy/polygon_codec/perspective.jpg" />


<br/>
The next drawing illustrate the left and right clipping planes (<code>W=-X</code> and <code>W=X</code>). The three vertices of the polygons are projected on W=1 during the perspective divide.
			

<br/>

	<img style="display:block; margin-left:auto;margin-right:auto;" src="../fd_proxy/polygon_codec/polyProjection.jpg" />

<br/>
<br/>
<br/>
<br/>
The next polygon has to be clipped against the right clipping plan. In this case the 3 vertices polygon becomes a 4 vertices polygons.
Since the two new vertices are now sitting on the edge, they are projected to the same [X,W=1] coordinates.

 
		<img style="display:block; margin-left:auto;margin-right:auto;" src="../fd_proxy/polygon_codec/clipping_normal.jpg" />


<br/>
<br/>
<br/>

The following case illustrate two special cases:
<ul>
	<li>One of the vertices has a negative W, this would cause a "polygon inversion" if projected as is on W=1.</li>
	<li>The clipping actually produce vertices with a W=0 component. That would cause a divide by zero. A way to solve this is to clip against W=0.00001 plan.</li>
</ul>
<br/>


		<img style="display:block; margin-left:auto;margin-right:auto;" src="../fd_proxy/polygon_codec/clipping_divide_zero.jpg" />

				<br/>
			</p>	









<h3>Homogeneous coordinate clipping code sample</h3>
			
			<p id="paperbox">
				With all this knowledge we can now write a preprocessor that will take as input the camera path, the level description and will output an SVS (Significant Visible Set of polygons) that will be played at runtime.<br/>
				From a high level:
				<ul>
					<li>We clip the polygon against the LEFT,RIGHT,TOP,BOTTOM,NEAR,FAR planes plus an other one.</li>
					<li>The output polygon of a plan clipping feed the next plan clipping.</li>
					<li>During a plan clipping each edge is tested in sequence via a simplified dot product.</li>
					<li>If an intersection is detected, the exact location is determined using parametric equations.</li>
				</ul>	  
				<br/>
				<br/>
				<p>
				First we declare our data structure and a few helpers macros.
				</p>
				<br/>
				<pre class="long">


    enum { X, Y, Z, W };

    typedef float vec4_t[4];

    typedef float vec2_t[2];

    #define MAX_VERTICES_PRE_POLYGON  10 

    typedef struct polygon_t
    {
        //Homogenous space vertices
        unsigned char	hs_numVertices;
        vec4_t	hs_vertices[MAX_VERTICES_PRE_POLYGON];
	
    } polygon_t;




    #define vector4Subtract( a, b, c )   ((c)[ 0 ] = (a)[ 0 ] - (b)[ 0 ], \
                                          (c)[ 1 ] = (a)[ 1 ] - (b)[ 1 ], \
                                          (c)[ 2 ] = (a)[ 2 ] - (b)[ 2 ], \
                                          (c)[ 3 ] = (a)[ 3 ] - (b)[ 3 ] )

    #define vector4Add( a, b, c )        ((c)[ 0 ] = (a)[ 0 ] + (b)[ 0 ],\
                                          (c)[ 1 ] = (a)[ 1 ] + (b)[ 1 ],\
                                          (c)[ 2 ] = (a)[ 2 ] + (b)[ 2 ],\
                                          (c)[ 3 ] = (a)[ 3 ] + (b)[ 3 ] )

    #define vector4Copy( a, b )          ((b)[ 0 ] = (a)[ 0 ],\
                                          (b)[ 1 ] = (a)[ 1 ],\
                                          (b)[ 2 ] = (a)[ 2 ],\
                                          (b)[ 3 ] = (a)[ 3 ] )

    #define vector4Scale( v, s, o )      ((o)[ 0 ] = (v)[ 0 ] * (s),\
                                          (o)[ 1 ] = (v)[ 1 ] * (s),\
                                          (o)[ 2 ] = (v)[ 2 ] * (s),\
                                          (o)[ 3 ] = (v)[ 3 ] * (s) )


    void copyVertices(vec4_t* from, polygon_t* to, int numVertices)
    {
        int i;

        to->hs_numVertices = numVertices;
        for(i=0 ; i < numVertices ; i++)
        {
            vector4Copy(from[i],to->hs_vertices[i]);
        }
    }


</pre>

<p>
	<br/>
	We can then write the first method that will remove any point with W negative and bring them just above zero to avoid a divive by zero during the perspective divide phase. This will avoid the special case mentionned previously.
</p>

<pre class="long">


    #define W_CLIPPING_PLANE 0.00001 

    //Clip against plane w=W_CLIPPING_PLANE

    void ClipPolygonOnWAxis(polygon_t* face)
    {
        int i;
	
        vec4_t* currentVertice;
        vec4_t* previousVertice;
	
	
        unsigned char in_numVertices=0;
        vec4_t in_vertices[MAX_VERTICES_PRE_POLYGON];
	
        char previousDot;
        char currentDot;
	
        float intersectionFactor;
        vec4_t intersectionPoint;

	
        previousVertice = &face->hs_vertices[face->hs_numVertices-1];
        previousDot = ((*previousVertice)[W] < W_CLIPPING_PLANE) ? -1 : 1;
        currentVertice = &face->hs_vertices[0];
        while (currentVertice != &face->hs_vertices[face->hs_numVertices] ) 
        {
            currentDot = ((*currentVertice)[W] < W_CLIPPING_PLANE) ? -1 : 1;
		
        if (previousDot * currentDot < 0)
        {
            //Need to clip against plan w=0
			
            intersectionFactor = (W_CLIPPING_PLANE - (*previousVertice)[W] ) / ((*previousVertice)[W]- (*currentVertice)[W]);
			
            // I = Qp + f(Qc-Qp))
            vector4Copy(*currentVertice,intersectionPoint);                              //          Qc
            vector4Subtract(intersectionPoint, *previousVertice  ,intersectionPoint);    //         (Qc-Qp)
            vector4Scale(intersectionPoint,intersectionFactor,intersectionPoint);        //        f(Qc-Qp))
            vector4Add(intersectionPoint,*previousVertice,intersectionPoint);            //Qp    + f(Qc-Qp))
			
            // Insert
            vector4Copy(intersectionPoint,in_vertices[in_numVertices]);
            in_numVertices++;
        }
		
        if (currentDot > 0)
        {
            //Insert
            vector4Copy(*currentVertice,in_vertices[in_numVertices]);
            in_numVertices++;
        }
		
        previousDot = currentDot;
		
        //Move forward
        previousVertice = currentVertice;
        currentVertice++;
    }

        //Copy the output(in_vertices) into the source (face)
        copyVertices(in_vertices,face,in_numVertices);
        in_numVertices = 0;
    }


</pre>
<br/>
<br/>
<p>
	Then we have a generic method that can be used for any of the axis:<br/>
	<ul>
		<li><code>X</code> will clip against w=x and w=-x, respectively RIGHT and LEFT</li>
		<li><code>Y</code> will clip against w=y and w=-y, respectively TOP and BOTTOM</li>
		<li><code>Z</code> will clip against w=z and w=-z, respectively FAR and NEAR</li> 
	</ul>

</p>

<pre class="long">


    void ClipPolygonForAxis(polygon_t* face, int AXIS)
    {
        int i;
	
        vec4_t* currentVertice;
        vec4_t* previousVertice;
	
	
        unsigned char in_numVertices=0;
        vec4_t in_vertices[MAX_VERTICES_PRE_POLYGON];
	
        char previousDot;
        char currentDot;
	
        float intersectionFactor;
        vec4_t intersectionPoint;

        //Clip against first plane
        previousVertice = &face->hs_vertices[face->hs_numVertices-1];
        previousDot = ((*previousVertice)[AXIS] <= (*previousVertice)[W]) ? 1 : -1;
        currentVertice = &face->hs_vertices[0];
        while (currentVertice != &face->hs_vertices[face->hs_numVertices] ) 
        {
            currentDot = ((*currentVertice)[AXIS] <= (*currentVertice)[W]) ? 1 : -1;
		
            if (previousDot * currentDot < 0)
            {
                //Need to clip against plan w=0
			
                intersectionFactor = 
                ((*previousVertice)[W] - (*previousVertice)[AXIS]) / 
                (((*previousVertice)[W] - (*previousVertice)[AXIS]) - ((*currentVertice)[W] - (*currentVertice)[AXIS]) );
			
                vector4Copy(*currentVertice,intersectionPoint);
                vector4Subtract(intersectionPoint, *previousVertice  ,intersectionPoint);
                vector4Scale(intersectionPoint,intersectionFactor,intersectionPoint);
                vector4Add(intersectionPoint,*previousVertice,intersectionPoint);
			
                // Insert
                vector4Copy(intersectionPoint,in_vertices[in_numVertices]);
                in_numVertices++;
            }
		
            if (currentDot > 0)
            {
                //Insert
                vector4Copy(*currentVertice,in_vertices[in_numVertices]);
                in_numVertices++;
            }
		
            previousDot = currentDot;
		
            //Move forward
            previousVertice = currentVertice;
            currentVertice++;
        }

        //Copy the output(in_vertices) into the source (face)
        copyVertices(in_vertices,face,in_numVertices);
        in_numVertices = 0;
	




        //Clip against opposite plane
        previousVertice = &face->hs_vertices[face->hs_numVertices-1];
        previousDot = (-(*previousVertice)[AXIS] <= (*previousVertice)[W]) ? 1 : -1;
        currentVertice = &face->hs_vertices[0];
        while (currentVertice != &face->hs_vertices[face->hs_numVertices] ) 
        {
            currentDot = (-(*currentVertice)[AXIS] <= (*currentVertice)[W]) ? 1 : -1;
		
            if (previousDot * currentDot < 0)
            {
                //Need to clip against plan w=0
			
                intersectionFactor = 
                ( (*previousVertice)[W] + (*previousVertice)[AXIS]) / 
                ( ( (*previousVertice)[W] + (*previousVertice)[AXIS]) - ((*currentVertice)[W] + (*currentVertice)[AXIS]) );
			
                vector4Copy(*currentVertice,intersectionPoint);
                vector4Subtract(intersectionPoint, *previousVertice  ,intersectionPoint);
                vector4Scale(intersectionPoint,intersectionFactor,intersectionPoint);
                vector4Add(intersectionPoint,*previousVertice,intersectionPoint);
			
                // Insert
                vector4Copy(intersectionPoint,in_vertices[in_numVertices]);
                in_numVertices++;
            }
		
            if (currentDot > 0)
            {
			//Insert
			vector4Copy(*currentVertice,in_vertices[in_numVertices]);
			in_numVertices++;
            }
		
            previousDot = currentDot;
		
            //Move forward
            previousVertice = currentVertice;
            currentVertice++;
        }
        
        //Copy the output(in_vertices) into the source (face)
        copyVertices(in_vertices,face,in_numVertices);
        in_numVertices = 0;
    }


</pre>

<p>
<br/><br/>

	Finally we can write the <code>ClipPolygon</code> method:<br/>
</pre>

<pre class="long">


    void ClipPolygon(polygon_t* face)
    {
        ClipPolygonOnWAxis(face);       // w=W_CLIPPING_PLANE
        ClipPolygonForAxis(face,X);     // w=x   ,  w=-x
        ClipPolygonForAxis(face,Y);     // w=y   ,  w=-y
        ClipPolygonForAxis(face,Z);     // w=z   ,  w=-z
    }

    
</pre>
				<p>
				Full code source <a href="clip.c">here</a>.
				
				Note that this code is not optimized for a realtime processing apart for the simplified dot products. If anyone from Nvidia or ATI read this, feel free to let me know what could be improved ;) !
				</p>
			</p>

<h3>Delta encoding</h3>
			
			<p id="paperbox">
			<br/>
			The first level of shmup is three minutes long. The precalculated SVS was 2MB before delta compression but only 800KB after. Of course the compression gain depends on the 
			amount of delta between frames: The intro is 1200Kb for two minutes.<br/>
			</p>







<h3>Results</h3>
		
			<p id="paperbox">
			Precalculate the Visible Set of polygon in a 3D engine may sound like a stupid idea but in this case it allowed to squize an additional 15% in terms of framerate. 
			It also provided a constant framerate and made the level designer's life easy because he never had to worry about showing too many polygon with the camera.<br/>
			<br/> 
			<br/>
			A few videos so you can see by yourself:<br/>
			<br/>
			
 
 <div style="margin-left:auto;margin-right:auto;display:block; width: 100%; text-align:center;">

<video width="320" height="480" preload="none" poster="../fd_proxy/polygon_codec/Untitled_low.jpg" controls>
  <source src="../fd_proxy/polygon_codec/Untitled_low.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>
</div>
			<br/><br/><br/>
			Following: A test using Ikaruga models. The "TENSO" level is 10k polygons but the 2500 limitation doesn't show.	Note that some of the polygons are flashing because I didn't master the negative W issues yet.<br/>
			<br/>
				 <div style="display:block; width: 100%; text-align:center;">
				<iframe width="320" height="480" src="https://www.youtube.com/embed/PgHnqERODpk" frameborder="0" allowfullscreen></iframe>
				</div>
			</p>	

<h3>Additional readings</h3>
		
			<p id="paperbox">
				<table>
					<tr><td width="1%"><img style="width:70px" src="pdf-big.png"/></td><td><a href="clippingdocument/p245-blinn.pdf">Clipping using homegeneous coordinates</a> by James F. Blinn and Martin E. Newell</td></tr>
					<tr><td width="1%"><img style="width:70px" src="pdf-big.png"/></td><td><a href="clippingdocument/Clipping.pdf">CLIPPING</a> by Kenneth I. Joy</td></tr>
					<tr><td style="padding-left:10px;" width="1%"><img style="width:55px" src="../images/tripdownpipeline.jpg"/></td><td><a href="http://www.amazon.ca/Jim-Blinns-Corner-Graphics-Pipeline/dp/1558603875/ref=sr_1_1?ie=UTF8&qid=1308682944&sr=8-1">A Trip Down the Graphics Pipeline</a> by Jim Blinn</td></tr>
				
					<tr><td style="padding-left:10px;" width="1%"><img style="width:55px" src="bb.jpg"/></td><td><a href="http://www.amazon.com/Backroom-Boys-Secret-Return-British/dp/0571214967">Backroom Boys</a> great read about the genese of Elite game (in the style of "Masters of Doom").</td></tr>
				</table>
			

			</p>			
<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

