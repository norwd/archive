<script type="text/javascript">
  var disqus_identifier = "shmup_generate_videos";
</script>
<!DOCTYPE html>
<html>
	<head>	
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="Author" content="Fabien Sanglard">
		
		<meta name="Keywords" content="Generate/Record, Videos on iPhone/iPad,, openGL, TGA capture, Avi, WAV, RIFF, PCM, iPhone, iPad, iTouch"/>
		<meta name="Description" content="How to record videos on iPhone"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	

		
		

 
 	
		
		<title>SHMUP postmortem: How to generate videos from iPhone</title>
		
	</head>
	<body>
		<div id="main">
           
					
			<link rel='stylesheet' href='../css/neo_style.css' type='text/css'  />



    <h1 id="site-name">
        <a  href="../index.html" >Fabien Sanglard's Website</a>
    </h1>

<script>
   function setEmailTitle()
	{
 		var folders = window.location.href.split("/"); 

		var currentFolder = folders[folders.length-2];

		var emailLink = document.getElementById("mail");

		emailLink.href = "mailto:fabiensanglard.net@gmail.com?subject="+currentFolder;

	}
	
	window.onload = setEmailTitle;
</script>
<style type='text/css'>
		/**
		 * Bulletproof syntax:
		 * http://www.fontspring.com/blog/further-hardening-of-the-bulletproof-syntax
		 * Font files generated by Font Squirrel:
		 * http://www.fontsquirrel.com
		 * License: Open Font License. See http://evenchick.com/wp-content/themes/blaskan/OFL.txt.
		 */
		@font-face {
			font-family: 'LeagueGothic';
			src: url('../font/league_gothic/league_gothic-webfont.eot'); /* IE9 Compat Modes */
			src: url('../font/league_gothic/league_gothic-webfont.eot?iefix') format('eot'), /* IE6-IE8 */
			     url('../font/league_gothic/league_gothic-webfont.woff') format('woff'), /* Modern Browsers */
			     url('../font/league_gothic/league_gothic-webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
			     url('../font/league_gothic/league_gothic-webfont.svg') format('svg'); /* Legacy iOS */
		}
		
		@font-face {
			font-family: 'DejaVu Sans';
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf'); /* IE9 Compat Modes */
			src: url('../font/dejavu-sans/DejaVuSansMono.ttf')  format('truetype') /* Safari, Android, iOS */
			     
		}

		
</style>

<header id="header" role="banner"><nav id="nav" role="navigation"><div class="menu">
	<ul id="menu-primary-navigation-1" >
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-91">
           <a href="../index.html" >Home</a>
         </li>
         <li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95">
           <a href="../about/index.html">About</a>
         </li>
          <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-96">
           <a href="../faq/index.html">FAQ</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-92">
            <a id="mail" href="mailto:fabiensanglard.net@gmail.com?subject=Tunnel" title="Send me an email.">Email</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-93">
            <a href="../rss.xml" title="Suscribe to RSS Feed.">Rss</a>
         </li>
         <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-94">
            <a href="http://twitter.com/fabynou" title="Follow me on Twitter.">Twitter</a>
         </li>
     </ul></div></nav></header>
<!-- / #header -->
<section id="content" role="main">



		
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Feed" href="../rss.xml" />
<link rel="alternate" type="application/rss+xml" title="Fabien Sanglard &raquo; Comments Feed" href="../rss.xml" />
<div id="date">
       Feb 21st, 2011</div>
   <h1>SHMUP postmortem: How to create 60 fps videos from iOS devices</h1>
   <p id="paperbox">
	   	
          <a  href="index.php">
          <img src="video_icon.jpg" style="margin-left: 2ch;float:right; border:1px black solid;width:35%;">   
          </a> 
         

			Back in winter 2009 I was working pretty hard on the 3D engine that would  power my next iPhone/iPad game: "<a href="http://itunes.apple.com/us/app/shmup/id337663605?mt=8">SHMUP</a>". To demo the work in progress required to generate videos, a task far from being trivial on a  smartphone: Slow CPU/GPU, Little RAM, no TV output, no storage space, no real multitasking. Hence I had the idea to have the engine generate its own videos. This is how I did it, maybe it will inspire someone.
            <div style="clear:both;"></div>
</p>
<br/>
<h3>The constraints </h3>
	
	<p id="paperbox">
		To record a game session on platform such as Windows, Linux or MacOS X is very easy: just use a Capture software. I have used <a href="http://www.fraps.com/">Fraps</a> and <a href="http://www.ambrosiasw.com/utilities/snapzprox/">Snapz Pro X</a> for acceptable results by the past. If really your engine is pushing the machine to it limits or you want a professional 60 frames per second video, you can use an other device that you plug on both the DVI output of the graphic card and the sound card output.<br/> But on a mobiles device none of those are possible because of the following constraints:<br/><br/> 
	<ul> 
		<li>Very limited CPU/GPU power: An additional process, grabbing the framebuffer each frame would kill the framerate.</li>
		<li>Very limited storage space and memory, reduce the length and quality of a video you can generate.</li> 
		<li>No real multitasking, you cannot run two applications at the same time and use one to capture video/sound from the other.</li>
		<li>No access to the framebuffer (at least with public frameworks), applications are isolated from each other.</li>
		<li>No TV output, no way to use an external device to record anything else but the sound and music. <u>Note:</u> There is actually a way to output video on the USB port via <code>MPTVOutWindow</code> but no way to get above 10 frames per seconds.</li>
	</ul> 
</p>
	
	<h3>A solution</h3> 
	
	<p id="paperbox">	
		The main element of the solution is to centralize all user inputs and record them so they can be replayed in order to replicate a session precisely. This was originally a suggestion from John Carmack in a <a href="http://www.team5150.com/~andrew/carmack/johnc_plan_1998.html#d19981014">plan from Oct 14, 1998</a> (<a href="oct14-1998plan.pdf.zip">mirror</a>).<br/> 
<br/> 
<br/> 
		With an appropriate structure, user inputs are timestamped as soon as they are received from the touchscreen or the network:<br/> 
		<pre class="long"> 
			
    typedef struct
    {
        unsigned int time;
        unsigned int delta_time;
        unsigned char buttons_state;

    } command_t ;	
		
		</pre><br/> 
<p>
		This is not the only thing to do in order to be able to replay a session accurately. You also have to make the game deterministic and deal with issues such as different framerate between recording and playing but this beyond the scope for now (Check out Doom and Quake source code to learn more about how to deal with this issue).<br/>
<br/>
Once a game session is recorded it can be replayed anywhere at any speed. It can be loaded in XCode's iphone simulator, running on your desktop where a lot of storage space is available. Additionally the timer can behave differently upon video generation and return a constant 16.666ms delta in order to dissociate realtime and simulation time. The overall allowing to spend as much time are needed between frames:<br/>
<br/>
<img src="../fd_proxy/shmup_generate_videos/timeline.png"/>
<br/><br/>
The overall method is summarized as follow:<br/>
<ul>
	<li>Play the game, record the inputs.</li>
	<li>Load the inputs in XCode simulator.</li>
	<li>Start the engine in playback mode, the timer now returns a fixed simulation time delta of 16,666ms for each frame tick. </li>
	<li>At the end of each frame, take as much time needed in order to save to HD:</li>

		<ul>
				<li>A PNG file: The current OpenGL framebuffer</li>
				<li>A PCM frame of the WAV file representing she sounds played by OpenAL during the last 16,666ms</li>
		</ul>

	<li>At the end of the session, combine all streams (video, audio track, sound effects) using Quicktime.</li>
</ul>		
</p>
<br/>
	</p> 
	
<h3>Full pipeline</h3> 

	<p id="paperbox"> 
	  <img src="../fd_proxy/shmup_generate_videos/pipeline.png" />
		<br/>
<br/>
	</p> 


	<h3>Save a video/OpenGL frame</h3> 
	
	<p id="paperbox"> 
		Visual frames are saved as TGA files. There is one file per frame. To save a visual frame is very easy, we just have to request it from openGL via <code>glReadPixels</code>, flip the channels R and B (btw I just learned about the xor trick!) and save to the hard-drive.
<pre class="long"> 
		
  uchar* screenShotBuffer;
  void dEngine_INIT_ScreenshotBuffer(void)
  {
	screenShotBuffer = calloc(SCREEN_WIDTH* SCREEN_HEIGHT, 4);
  }

  void dEngine_WriteScreenshot(char* screenshotPath)
  {

    //This is where we request OpenGL to send the current framebuffer

    glReadPixels(0,0,SCREEN_WIDTH,SCREEN_HEIGHT,GL_RGBA,GL_UNSIGNED_BYTE, screenShotBuffer);
	
 
    // OpenGL returns byte in RGBA order but TGA needs BGRA order
    // Next loop flips R and B components using XOR trick instead of a tmp variable

    uchar* pixel = screenShotBuffer;
    for(int i=0 ; i < SCREEN_WIDTH * SCREEN_HEIGHT ; i++)
    {
        pixel[0] ^= pixel[2];
        pixel[2] ^= pixel[0];
        pixel[0] ^= pixel[2];

        pixel += 4;
    }

    // Filling TGA header information

    uchar tga_header[18];
    memset(tga_header, 0, 18);
    tga_header[2] = 2;
    tga_header[12] = (SCREEN_WIDTH & 0x00FF);
    tga_header[13] = (SCREEN_WIDTH  & 0xFF00) / 256;
    tga_header[14] = (SCREEN_HEIGHT  & 0x00FF) ;
    tga_header[15] =(SCREEN_HEIGHT & 0xFF00) / 256;
    tga_header[16] = 32 ;


	
    // Open the file, write both header and payload, close, done.

    FILE* pScreenshot = fopen(screenshotPath, "wb");
    fwrite(&tga_header, 18, sizeof(uchar), pScreenshot);
    fwrite(screenShotBuffer, SCREEN_WIDTH * SCREEN_HEIGHT,4 * sizeof(uchar),pScreenshot);
    fclose(pScreenshot);

  }
		
		</pre> 
	<br/>
	</p> 
	
	<h3>Save an audio frame</h3> 
 
	<p id="paperbox"> 
		Sound effects are saved as one replay long WAV PCM file. To save an audio frame is a bit harder because we have to reconstruct what was played by the speakers during the 16,666ms duration of the frame. To add complexity the engine plays sounds on several channels simultaneously, we need to mix them the way OpenAL did. The trick is to keep track of what has been sent to OpenAL for each channel.

<pre class="long">

    typedef struct
    {
        uchar* data;
        ALenum format;
        
        [...]
	
        int duration;
        int lastTimePlayed ;	
     
     } sound_t;


     typedef struct openAL_channel_t
     {
          [...]

          sound_t* lastSoundPlayed;

     }  openAL_channel_t ;


</pre>
	<br/>
	<p>
	Every frame we write the PCM values resulting in the combination of all the channels currently playing a sound effect (All channels can be mixed into a single one by calculating the average PCM value of all channels).<br/>

<pre class="long">


    int WAV_SAMPLE_RATE = 22500 ; //samples/seconds
    int numSamplesToWrite = 16,666 / 1000 * WAV_SAMPLE_RATE;
    uchar* wavDataBuffer ; //An allocated buffer storing the WAV data payload

    for(int i=0 ; i < numSamplesToWrite ; i++)
    {
        int averagePCMValue = getAllChannelsAverage();
        *wavDataBuffer++ = averagePCMValue;
    }


</pre>
</p>
<p>
When the session is over we save the WAV PCM file to the HD. Here are the data structures we need:
</p>

<pre class="long">

    #define WAVE_FORMAT_PCM            0x0001		
    #define WAVE_FORMAT_IEEE_FLOAT     0x0003	
    #define WAVE_FORMAT_ALAW           0x0006	
    #define WAVE_FORMAT_MULAW          0x0007
    #define WAVE_FORMAT_EXTENSIBLE     0xFFFE


    typedef struct master_riff_chnk_t
    {
        char            ckID[4];
        unsigned int    cksize;
        char            WAVEID[4];
    } master_riff_chnk_t;


    typedef struct fmt_chunk_t
    {
        char            ckID[4];
        unsigned int    cksize;
        unsigned short  wFormatTag;        // 2	 WAVE_FORMAT_PCM
        unsigned short  nChannels;         // 2	Nc
        unsigned int    nSamplesPerSec;    // 4	F
        unsigned int    nAvgBytesPerSec;   // 4	F * M * Nc
        unsigned short  nBlockAlign;       // 2	M * Nc
        unsigned short  wBitsPerSample;    // 2	rounds up to 8 * M
	
    } fmt_chunk_t;


    typedef struct basic_chunk_t
    {
        char            ckID[4];
        unsigned int    cksize;
    } basic_chunk_t;


    typedef struct wave_file_t
    {
        master_riff_chnk_t riff;
        fmt_chunk_t fmt;
        basic_chunk_t dataChunk;
    } wave_file_t ;


</pre>
<p>
At the end of the replay we save the buffer as a WAVE as follow:
<br/>
</p>
<pre class="long">


    void SND_SaveWAV(char* path, char* audioTrack, int sizeAudioTrack)
    {
        wave_file_t waveFile;
        
        memset(&waveFile,0,sizeof(waveFile));
	
        //Value explanation 4(dataChunk header) + 24(fmt header) + 8 (riff header) + data payload
        waveFile.riff.cksize =  4 + 24 + (8 + sizeAudioTrack);  
        memcpy(waveFile.riff.ckID,"RIFF",4);
        memcpy(waveFile.riff.WAVEID,"WAVE",4);
	
        waveFile.dataChunk.cksize = sizeAudioTrack;
        memcpy(waveFile.dataChunk.ckID,"data",4);
	
        memcpy(waveFile.fmt.ckID,"fmt ",4);
        waveFile.fmt.cksize = 16;
        waveFile.fmt.wFormatTag = WAVE_FORMAT_PCM;
        waveFile.fmt.nChannels = 1;
        waveFile.fmt.nSamplesPerSec = 22050;
        waveFile.fmt.wBitsPerSample = 8;
        waveFile.fmt.nBlockAlign = waveFile.fmt.wBitsPerSample/8 * waveFile.fmt.nChannels;
        waveFile.fmt.nAvgBytesPerSec = waveFile.fmt.nSamplesPerSec * waveFile.fmt.wBitsPerSample/8 * waveFile.fmt.nChannels;


        //Write file on disk

        FILE* f = fopen(path, "wb");
        fwrite(&waveFile, 1, sizeof(wave_file_t), f);
        fwrite(audioTrack, 1, sizeAudioTrack, f);
        fclose(f);
	
    }

</pre>
	<p>
		This is for a 22500Hz, mono, 8bits WAV but it can easily be converted to any combination of Stereo/16bits/Frequency.
</p>
	</p> 
	


	
 
	<h3>Result</h3> 
	
	<p id="paperbox"> 
		In the end you get a 60 fps video with soundtrack and music. <br/><br/>
<table cellspacing="0" cellpadding="0" border="0" style="width:100%;"><tr><td align="center"> 

<video width="320" height="480" preload="none" poster="../fd_proxy/shmupLite/video_preview.jpg" controls>
  <source src="../fd_proxy/shmupLite/shmupLite_video.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>
</td></tr></table> 
	</p> 
	
<!-- <h2>Comments</h2>
<p> -->


     <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'fabiensanglardswebsite'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || 
                document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> -->
    <!--<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->
<!--     




</p> -->

 <h2 style="padding: 0px; margin: 0px;">&nbsp;</h2>
<div style="text-align:center ;">@</div>

		</div>
</div>

	<script src="../lazy_load/jquery.min.js" type="text/javascript" charset="utf-8"></script>
 	

  	<script src="../lazy_load/jquery.lazyload.min.js?v=3" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" charset="utf-8">
		      $(function() {
		          $("img").lazyload({
		              effect : "fadeIn"
		          });
		      });
    </script>	
	</body>

</html>

