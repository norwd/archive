<html>
<head>
<title>
Bjarne Stroustrup: The C++ Programming Language (2nd edition)
(errata, 1st printing)
</title>
<link rev="made" rel="made" href="mailto:jutta@pobox.com">
</head>
<body>
This is printing 1.&#160;<tt> </tt>Also available are errata for the
<a href="bs-errata-2.html">first year</a>, and printings
<a href="bs-errata-6.html">6</a> and
<a href="bs-errata-9.html">9</a>.
<hr>
Errata for
<h1>
Bjarne Stroustrup:<br>
The C++ Programming Language (2nd edition)</h1>
Addison-Wesley, 1991, ISBN0-201-53992-6, first printing.
<hr>
The corrections here cover program bugs and stylistic issues in the
program fragments, but not simple typos in the text.&#160;<tt> </tt>I am grateful
to all that have pointed out problems to me.
<p>
For brevity I have used the old ed syntax: s/old-text/new-text/
<p>
<dl>
<p><dt><i>pg25,29,99,194</i>&#160;<tt> </tt>s/stream.h/iostream/<dd>
<p><dt><i>pg39</i>&#160;<tt> </tt>s/cs.pop()/<b>s</b>.pop()/<dd>
<p><dt><i>pg64,99,116,119</i>&#160;<tt> </tt>s/main()/<b>int</b> main()/<dd>
<p><dt><i>pg71</i>&#160;&#160;&#160;<tt> </tt>s/unsigned/unsigned <b>int</b>/&#160;&#160;&#160;<tt> </tt>in struct sreg<dd>
<p><dt>
<i>pg85,86,87</i>&#160;<tt> </tt>s/&quot;\n&quot;/<b>'</b>\n<b>'</b>/
<p><dt>
<i>pg99</i>&#160;<tt> </tt>#include &lt;stdlib.h&gt; (to get the declaration of exit())
<p><dt>
<i>pg112</i>&#160;<tt> </tt>s/struct S { int a; char b; }/struct S { int a; char b; }<b>;</b>/
<p><dt>
<i>pg116,118</i>&#160;<tt> </tt>s/const TBLSZ/const <b>int</b> TBLSZ/
<p><dt>
<i>pg141</i>&#160;<tt> </tt>s/r.8.5/r.<b>9</b>.3/
<p><dt>
<i>pg152</i>&#160;<tt> </tt>s/delete s;/delete<b>[]</b> s;/
<p><dt>
<i>pg156</i>&#160;<tt> </tt>s/delete n-&gt;string;/delete<b>[]</b> n-&gt;string;/
<p><dt>
<i>pg158</i>&#160;<tt> </tt>main() should be
<dd><pre>
int main(int argc, char *argv[])
{
    if (argc != 3) error(&quot;two arguments expected&quot;);
    int count = 0;
    int m = atoi(argv[1]);      // number of set members
    int n = atoi(argv[2]);      // in the range 1..n
    intset s(m,n);

    while (count&lt;m) {
        int t = randint(n);
        if (s.member(t)==0) {
            s.insert(t);
            count++;
        }
    }

    print_in_order(&amp;s);
}</pre>
<dt>
<i>pg159</i>&#160;<tt> </tt>s/delete x;/delete<b>[]</b> x;/
<p><dt>
<i>pg170 function error():</i>&#160;<tt> </tt>name the arguments a1,a2, and a3
<p><dt>
<i>pg191</i>&#160;<tt> </tt>s/rotate::shape/shape::rotate/
<p><dt>
<i>pg191</i>&#160;<tt> </tt>s/rotate::draw/<b>shape</b>::draw/
<p><dt>
<i>pg193</i>&#160;<tt> </tt>s/class character_device {/class character_device { <b>public:</b>/
<p><dt>
<i>pg195</i>&#160;<tt> </tt>delete first definition of on_screen().&#160;<tt> </tt>(it is a duplicate)
<p><dt>
<i>pg197</i>&#160;<tt> </tt>s/point sw, ne;/<b>class rectangle : public shape {</b> point sw, ne;/
<p><dt>
<i>pg203</i>&#160;<tt> </tt>s/pending()/pending()<b>;</b>/
<p><dt>
<i>pg204 for dip, dip1, and dip2</i>&#160;<tt> </tt>s/debug_info/debug_info<b>*</b>/
<p><dt>
<i>pg204</i>&#160;<tt> </tt>s/dip.merge/dip<b>-&gt;</b>merge/
<p><dt>
<i>pg205,206</i>&#160;<tt> </tt>s/mamager::/ma<b>n</b>ager::/
<p><dt>
<i>pg208</i>&#160;<tt> </tt>s/from the work done from the base class./
<dd>from the work done from the <b>derived</b> class./
<p><dt>
<i>pg210,211</i>&#160;<tt> </tt>s/: public virtual window public window_w_input/: public virtual window<b>, </b>public window_w_input,/
<p><dt>
<i>pg218</i>&#160;<tt> </tt>s/void copy(expr* s);/void copy(expr* s<b>, deep = 0</b>);/
<p><dt>
<i>pg219</i>&#160;<tt> </tt>s/left = s-&gt;clone(1);/left = s-&gt;<b>left-&gt;</b>clone(1);/
<p><dt>
<i>pg219</i>&#160;<tt> </tt>s/right = s-&gt;clone(1);/right = s-&gt;<b>right-&gt;</b>clone(1);/<dd>
<p><dt>
<i>pg220</i>&#160;<tt> </tt>s/conditional::copy(expr* s, int deep)/
	<dd>conditional::copy(<b>conditional</b>* s, int deep)/<dd>

<p><dt>
<i>pg228</i>&#160;<tt> </tt>s/ivate:/<b>private</b>:/<dd>
<p><dt>
<i>pg229</i>&#160;<tt> </tt>s/trivially handled using friend functions/<dd>
	trivially handled using <b>nonmember</b> functions/
<p><dt>
<i>pg231</i>&#160;<tt> </tt>s/return this;/return <b>*</b>this;/<dd>
<p><dt>
<i>pg237</i>&#160;<tt> </tt>s/delete p;/delete<b>[]</b> p;/<dd>
<p><dt>
<i>pg241</i>&#160;<tt> </tt>s/max = (s&lt;16) ? s : 16;/max = (s&lt;16) ? <b>16 : s</b>;/<dd>
<p><dt>
<i>pg243</i>&#160;<tt> </tt>s/assoc* cs;/<b>const</b> assoc* cs;/<dd>
<p><dt>
<i>pg262</i>&#160;<tt> </tt>s/insert(T&amp;/insert(<b>const</b> T&amp;/<dd>
<p><dt>
<i>pg262</i>&#160;<tt> </tt>s/append(T&amp;/append(<b>const</b> T&amp;/<dd>
<p><dt>
<i>pg262</i>&#160;<tt> </tt>s/lnk.info/lnk<b>-&gt</b>;info/<dd>
<p><dt>
<i>pg263</i>&#160;<tt> </tt>s/lst1.insert(<b>*</b>p)/lst1.insert(p)/<dd>
<p><dt>
<i>pg265</i>&#160;<tt> </tt>the declaration of Isplist should be
<dd><pre>
template&lt;class T&gt;
class Isplist : private slist_base {
public:
    void insert(T* p) { slist_base::insert(p); }
    void append(T* p) { slist_base::append(p); }
    T* get() { return (T*) slist_base::get(); }
};
</pre>
<dt>
<i>pg277</i>&#160;<tt> </tt>the declaration of the sort function should be
<dd><pre>
template&lt;class T, class Comp&gt; void Sort&lt;T,Comp&gt;::sort(Vector&lt;T&gt;&amp; v)
{
    for (int i=0; i&lt;n-1; i++)
        for (int j=n-1; i&lt;j; j--)
            if (Comp::lessthan(v[j],v[j-1])) {
                T temp = v[j];
                v[j] = v[j-1];
                v[j-1] = temp;
            }
}</pre>
<dt>
<i>pg280</i>&#160;<tt> </tt>the examples should be
<dd><pre>
template&lt;class T&gt; void f1(T);   // fine
template&lt;class T&gt; void f2(T*);  // fine
template&lt;class T&gt; T f3(int);    // error
template&lt;int i&gt; void f4(int[][i]);  // error
template&lt;int i&gt; void f5(int = i);   // error
template&lt;class T, class C&gt; void f6(T);  // error
template&lt;class T&gt; void f7(const T&amp;, complex);  // fine
template&lt;class T&gt; void f8(Vector&lt; List&lt;T&gt; &gt;);  // fine
</pre>
<p><dt>
<i>pg306</i>&#160;<tt> </tt>s/mp.debug_print()/<b>m</b>.debug_print()/<dd>
<p><dt>
<i>pg306 first paragraph</i>&#160;<tt> </tt>s/Int_overflow's debug()/Int_overflow's <b>debug_print</b>()/<dd>
<p><dt>
<i>pg329</i>&#160;<tt> </tt>s/&quot;(&quot;/<b>'</b>(<b>'</b>/<dd>
s/&quot;,&quot;/<b>'</b>,<b>'</b>/   <br>
s/&quot;)&quot;/<b>'</b>)<b>'</b>/
<p><dt>
<i>pg335,336</i>&#160;<tt> </tt>s/,istream&amp;,ostream&amp;)/,cin,cout)/
<p><dt>
<i>pg340,341,342</i>&#160;<tt> </tt>s/10.4.2.7/10.4.2.<b>1</b>/
<p><dt>
<i>pg346,347</i>&#160;<tt> </tt>s/return f(os,i)/return m.f(os<b>,m.</b>i)/<dd>
<p><dt>
<i>pg355</i>&#160;<tt> </tt>the declarations of streambuf and filebuf should be
<dd><pre>
class streambuf {     // manage a stream buffer
protected:
    char* base;     // start of buffer
    char* pptr;     // next free char
    char* gptr;     // next filled char
    char* eptr;     // one off the end of buffer
    char  alloc;    // buffer allocated by &quot;new&quot;
// ...

        // Empty a buffer:
        // Return EOF on error, 0 on success
    virtual int overflow(int c =EOF);

        // Fill a buffer:
        // Return EOF on error or end of input,
        // next char otherwise
    virtual int underflow();
    // ...
public:
    streambuf();
    streambuf(char* p, int l);
    virtual ~streambuf();

    int snextc()        // get the next char
    {
        return (++gptr==pptr) ? underflow() : *gptr&amp;0377;
    }

    int allocate();     // allocate some buffer space
    // ...
};

class filebuf : public streambuf {
protected:
    int  fd;            // file descriptor
    char opened;        // file opened
public:
    filebuf() { opened = 0; }
    filebuf(int nfd, char* p, int l)
        : streambuf(p,l) { /* ... */ }
   ~filebuf() { close(); }

    int overflow(int c =EOF);
    int underflow();

    filebuf* open(char *name, ios::open_mode om);
    int close() { /* ... */ }
    // ...
};
</pre>
<dt>
<i>pg409</i>&#160;<tt> </tt>s/C(int i)/<b>C2</b>(int i)/<dd>
<p><dt>
<i>pg409</i>&#160;<tt> </tt>s/~C()/~<b>C2</b>()/<dd>
<p><dt>
<i>pg410</i>&#160;<tt> </tt>s/C(X* q)/<b>C3</b>(X* q)/<dd>
<p><dt>
<i>pg410</i>&#160;<tt> </tt>s/C(X&amp; q)/<b>C4</b>(X&amp; q)/<dd>
<p><dt>
<i>pg418</i>&#160;<tt> </tt>add `int size() { return sz; }' as a public mermber of String<dd>
<p><dt>
<i>pg419</i>&#160;<tt> </tt>s/Assert(i&lt;0 &amp;&amp; i&lt;s.size()/Assert(0&lt;<b>=</b>i &amp;&amp; i&lt;size()/<dd>
<p><dt>
<i>pg435</i>&#160;<tt> </tt>s/: private array/: private <b>vector</b>/<dd>
<p><dt>
<i>pg438</i>&#160;<tt> </tt>add `virtual ~iter();' to the declaration of class iter<dd>
<p><dt>
<i>pg438</i>&#160;<tt> </tt>s/istream&amp; is/istream&amp; is<b>;</b>/<dd>
<p><dt>
<i>pg453</i>&#160;<tt> </tt>s/operator[](int)/operator[](int)<b>;</b>/<dd>
<p><dt>
<i>pg467</i>&#160;<tt> </tt>s/Map&lt;void*,void(*)()&gt; m;/Map&lt;void*,void(*)(<b>void*</b>)&gt; m;/<dd>
<p><dt>
<i>pg472</i>&#160;<tt> </tt>s/, count(new int)/, <b>pcount</b>(new int)/<dd>
<p><dt>
<i>pg473</i>&#160;<tt> </tt>the declaration of class X should be
<dd><pre>
class X {
    static Pool my_pool;
    // ...
public:
    // ...
    void* operator new(size_t) { return my_pool.alloc(); }
    void operator delete(void* p) { my_pool.free(p); }
};

Pool X::my_pool(sizeof(X));
</pre>
<dt>
<i>pg473</i>&#160;<tt> </tt>s/class Link/<b>struct</b> Link/
<p><dt>
<i>pg474</i>&#160;<tt> </tt>the definition of the constructor should be<dd>
<pre>
Pool::Pool(unsigned sz)
    : esize(sz)
{
    head = 0;
}
</pre>
<p><dt>
<i>pg474</i>&#160;<tt> </tt>s/const overhead = 12/const <b>int</b> overhead = 12<b>;</b>/
<p>
<p><dt>
<i>in the index:</i>&#160;<tt> </tt>every reference to the manual proper refers to page <i>n</i>
	where it
	<dd>should refer to page <i>n-1</i>
</dl>
<p>
People have been polite enough not to inquire how so many errors
could creep in.&#160;<tt> </tt>In the case of most non-stylistic bugs, the answer
is in trouble with the software that inserts fragments of the tested
code examples into the text.
<hr>
To track new developments, both the Annotated Reference Manual and
Bjarne Stroustrup's book have an identical ``extra'' chapter that is
updated a couple of times a
year.&#160;<tt> </tt><a href="ftp://ftp.std.com/AW/stroustrup2e/iso.ps">Its most
recent version</a> and the most recent errata sheet are available from
Software, Tool &amp; Die's ftp server in
directory <a href="ftp://ftp.std.com/AW/stroustrup2e">AW/stroustrup2e</a>.
<hr>
Thanks to Bjarne Stroustrup (bs@research.att.com) for errata and pointer.<br>
Markup, etc. by jutta@pobox.com, corrections and comments welcomed.
</body>
</html>
