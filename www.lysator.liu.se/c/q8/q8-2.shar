#!/bin/sh
# Self-unpacking archive format.  To unbundle, sh this file.
echo 'Q8README.TXT' 1>&2
cat >'Q8README.TXT' <<'END OF Q8README.TXT'
The attached files were created by Doug Gwyn to supplement some
C implementations that did not provide all of the C99 library.
They may be useful to others in a similar situation, or perhaps
as a base for these parts of a conforming C99 implementation.
The author has placed these files in the PUBLIC DOMAIN, so you
may do what you wish with them without requiring further
permission.  There are no warranties expressed or implied.  If
you find problems, or add configuration parameters for a new
platform, the author would appreciate being informed by e-mail:
	gwyn@arl.mil

Q8defs.h is a support header used by the other headers.
For each standard header X.h, the C source file X.c implements
the functions defined by X.h.
There is no Makefile, because the nature of this product
requires its tailoring to one's specific development environment.
Much of this is currently UNTESTED, although there is source for
a <stdint.h>/<inttypes.h> tester, sitest.c.  Good luck!
END OF Q8README.TXT
echo 'Q8defs.h' 1>&2
cat >'Q8defs.h' <<'END OF Q8defs.h'
/*
	Q8defs.h -- defines platform-specific parameters for standard headers

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Several of the standard headers provided by Doug Gwyn make use
	of these __Q8_* symbols.  If you want to define other names of
	the form __Q8_*, please coordinate them with gwyn@arl.mil, who
	claims "dibs" on (first-come ownership of) that name space.

	Aside:	Why "Q8"?  That was used as a system external symbol
	prefix in old CDC Fortran implementations, to avoid link-time
	name-space collisions with user-defined symbols, on the
	assumption that no user would ever think of using such a name.
*/

/* This header doesn't need an idempotency lock; there are no typedefs here. */

/* This header doesn't need C++ extern "C"; there are no declarations here. */

#define	__Q8_TEST		/* [undef to disable configuration checks] */

#define	_SYS_INT_TYPES_H		/* kludge to override Solaris header */
#define	_SYS_INT_LIMITS_H		/* ditto */

/*
	The following macros come in handy in many situations.
*/

/* splice arguments into one token */
#ifdef	__STDC__
#define	__Q8_1J(a,b)	a ## b
#define	__Q8_2J(a,b)	__Q8_1J(a,b)
#else
#define	__Q8_1J(a)	a
#define	__Q8_2J(a,b)	__Q8_1J(a)b
#endif

/* older versions of C didn't have certain type qualifiers */
#ifdef	__STDC__
#define	__Q8_CONST	const
#else
#define	__Q8_CONST
#endif

#if	__STDC_VERSION__ >= 199901
#define	__Q8_RESTRICT	restrict
#else
#define	__Q8_RESTRICT	/* nothing */
#endif

/* older versions of C don't support function prototypes */
#ifdef	__STDC__
#define	__Q8_PARAMS(a)	a
#else
#define	__Q8_PARAMS(a)	()
#endif
/* usage:	return_type func_name __Q8_PARAMS((param_decls)); */

/*
	The following is based on the MUVES "Va" (variable argument) package.

	created:	94/08/16	D A Gwyn

	The Va package provides portable support for functions taking
	a variable number of arguments.  It defines several macros
	that work together to hide the differences between the old
	UNIX <varargs.h> facility and the new Standard C <stdarg.h>.

	Rather than describing each Va package macro separately, it is
	best to give an example of the proper usage of the whole set of
	macros.  It should be easy to adapt this generic example to any
	specific requirement.

	The example is for a function named Advise that has two
	required arguments, the first being a printf-like format string
	and the second a flag that indicates (when true) that an extra
	"verbosity level" is provided as the third argument.  Remaining
	arguments are those, if any, associated with the format string.
	The Advise function prints the formatted result on the standard
	error output if and only if the verbosity level is given and is
	greater than 0.  It returns true unless it had trouble printing
	on the standard error output stream.

	Any code that wants to invoke the Advise function must include
	a proper declaration for it:

	#include	<Q8defs.h>		// includes Va package
	extern bool	Advise( __Q8_T(const char *) __Q8_T(bool) __Q8_Dots );
	// alternatively:
	// extern bool	Advise __Q8_PARAMS(( const char *, bool, ... ));

	The implementation of the Advise function might be:

	#include	<stdbool.h>
	#include	<stdio.h>
	#ifdef	__STDC__
	#include	<stdarg.h>
	#else
	#include	<varargs.h>
	#endif
	#include	<Q8defs.h>

	// VARARGS				// not VARARGS2
	bool
	Advise( __Q8_T( const char *format ) __Q8_T( bool verbose ) __Q8_AList )
		__Q8_Dcl
		{
		__Q8_D( const char *	format )
		__Q8_D( bool		verbose )
		__Q8_List(		ap )
		register int		verbosity;
		register bool		status;

		__Q8_Start( ap, verbose )
		__Q8_I( ap, char *, format )	// no "const" here
		__Q8_I( ap, bool, verbose )

		if ( verbose )
			verbosity = __Q8_Arg( ap, int );
		else
			verbosity = 0;

		if ( verbosity > 0 )
			status = vfprintf( stderr, format, ap ) > 0;
		else
			status = true;

		__Q8_End( ap )
		return status;
		}

	Note that several of these macros are reminiscent of the va_*
	macros in <varargs.h> or <stdarg.h>, but there are significant
	differences.  Proper usage of the "function-like" macros, in
	particular, does not require semicolons; this is intentional,
	in order to avoid warnings about "null statements" from certain
	compilers and "lint".  The easiest way to ensure correct usage
	is to copy the above example and then make changes to the copy
	as needed for the specific application.
*/

#ifdef	__STDC__

#define	__Q8_T(t)		t,
#define	__Q8_Dots		...
#define	__Q8_AList		...
#define	__Q8_D(d)		/* nothing */
#define	__Q8_Dcl		/* nothing */
#define	__Q8_List(ap)		va_list ap;
#define	__Q8_Start(ap, A0)	va_start(ap, A0);
#define	__Q8_I(ap, T, Ai)	/* nothing */
#define	__Q8_Arg(ap, T)		va_arg(ap, T)
#define	__Q8_End(ap)		va_end(ap);

#else	/* "classic" version of UNIX assumed */

#define	__Q8_T(t)		/* nothing */
#define	__Q8_Dots		/* nothing */
#define	__Q8_AList		va_alist
#define	__Q8_D(d)		d;
#define	__Q8_Dcl		va_dcl
#define	__Q8_List(ap)		va_list ap;
#define	__Q8_Start(ap, A0)	va_start(ap);
#define	__Q8_I(ap, T, Ai)	Ai = va_arg(ap, T);
#define	__Q8_Arg(ap, T)		va_arg(ap, T)
#define	__Q8_End(ap)		va_end(ap);

#endif

/*
	The following are used to define macros in multiple headers.
*/

/* NOTE: The following must be spelled *exactly* like EOF in <stdio.h>. */
#define	__Q8_EOF	(-1)
/* XXX -- not currently used in the headers I provide. */

/* NOTE: The following must be spelled *exactly* like NULL in <stddef.h> etc. */
#if	defined(_LP64) && !defined(__cplusplus)	/* Why? */
#define	__Q8_NULL	0L
#else
#define	__Q8_NULL	0
#endif

#define	__Q8_WEOF	((wint_t)-1)

/*
	The following are used to typedef types in multiple headers.
*/

#define	__Q8_MBSTATE_T	int		/* dummy; usually a struct */
#define	__Q8_WINT_T	int		/* this type works nearly everywhere */
#define	__Q8_FILE	FILE		/* must match <stdio.h> */
	/* XXX -- At present, __Q8_FILE requires #including <stdio.h>. */
/* XXX -- the following are not currently used in the headers I provide. */
#define	__Q8_SIZE_T	unsigned long	/* this type works nearly everywhere */
#define	__Q8_WCHAR_T	char		/* for minimal implementations */
/* XXX -- this is incomplete; these should be coupled with the following
  parameter definitions, and their limits should be computed and defined. */

/*
	The following defines parameters for supported types;
	they are used mainly by <stdint.h>.

	C:char  S:short  I:int  L:long  P:void*  Q:long long  M:max-width int.
	D:ptrdiff_t  A:sig_atomic_t  Z:size_t  W:wchar_t  X:wint_t
	G:long double
	followed by	W:width  T:type  U:is unsigned  S:suffix for constant
			F:printf/scanf length modifier

	TC:twos-complement	OC:ones-complement	SM:signed-magnitude
	SC:"signed char" or "char" if signed

	These values depend strongly on the architecture and compiler;
	the only combinations included here are the ones I use myself.
	Please add your particular combination and e-mail me the edits.

	XXX -- system parameters really ought to be in a separate header.
*/

#if	defined(__i386)			/* Intel x86, 32-bit, Sun Solaris */

#define	__Q8_TC
#define	__Q8_SC	/* signed */ char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	32
#define	__Q8_LW	32
#define	__Q8_PW	32
#define	__Q8_DW	32
#define	__Q8_AW	32
#undef	__Q8_AU
#define	__Q8_ZW	32
#define	__Q8_WW	32
#undef	__Q8_WU
#define	__Q8_XW	32
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#endif
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#define	__Q8_GT	long double

#elif	defined(_M_IX86)		/* Intel x86, 32-bit, Microsoft */

#define	__Q8_TC
#define	__Q8_SC	signed char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	32
#define	__Q8_LW	32
#define	__Q8_PW	32
#define	__Q8_DW	32
#define	__Q8_AW	32
#undef	__Q8_AU
#define	__Q8_ZW	32
#define	__Q8_WW	32
#undef	__Q8_WU
#define	__Q8_XW	32
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#define	__Q8_QW	64
#define	__Q8_QT	__int64
#define	__Q8_QS	i64
#define	__Q8_QF	"I64"
#endif
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#define	__Q8_GT	long double

#elif	defined(__sparc)		/* SPARC, Sun Solaris */

#define	__Q8_TC
#define	__Q8_SC	/* signed */ char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	32
#define	__Q8_AW	32
#undef	__Q8_AU
#ifdef	__sparcv9			/* 64-bit environment */
#define	__Q8_LW	64
#else					/* 32-bit environment */
#define	__Q8_LW	32
#endif
#define	__Q8_PW	__Q8_LW
#define	__Q8_DW	__Q8_LW
#define	__Q8_ZW	__Q8_LW
#define	__Q8_WW	__Q8_LW
#undef	__Q8_WU
#define	__Q8_XW	__Q8_LW
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#endif
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#define	__Q8_GT	long double

#elif	defined(_TMS320C6000)		/* TI TMS320C6xxx DSP, Code Composer */

#define	__Q8_TC
#define	__Q8_SC	signed char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	32
#define	__Q8_AW	32
#undef	__Q8_AU
#define	__Q8_LW	40
#define	__Q8_PW	32
#define	__Q8_DW	32
#define	__Q8_ZW	32
#define	__Q8_WW	8
#define	__Q8_WU			/* XXX -- check */
#define	__Q8_XW	32
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#define	__Q8_MW	__Q8_LW
#define	__Q8_MT	long
#define	__Q8_MS L
#define	__Q8_MF "l"
#endif
#define	__Q8_GT	long double

#elif	defined(__vax)			/* DEC VAX-11 */

#define	__Q8_TC
#define	__Q8_SC	/* signed */ char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	32
#define	__Q8_LW	32
#define	__Q8_PW	32
#define	__Q8_DW	32
#define	__Q8_AW	32
#undef	__Q8_AU
#define	__Q8_ZW	32
#define	__Q8_WW	32
#undef	__Q8_WU
#define	__Q8_XW	32
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#define	__Q8_GT	long double
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#define	__Q8_MW	32
#define	__Q8_MT	long
#define	__Q8_MS	L
#undef	__Q8_GT		/* long double not supported */
#endif

#elif	defined(__pdp11)		/* DEC PDP-11 */

#define	__Q8_TC
#define	__Q8_SC	/* signed */ char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	16
#define	__Q8_LW	32
#define	__Q8_PW	16	/* (violates section 5.2.4.1) */
#define	__Q8_DW	16	/* (violates section 5.2.4.1) */
#define	__Q8_AW	16
#undef	__Q8_AU
#define	__Q8_ZW	16
#define	__Q8_WW	32
#undef	__Q8_WU
#define	__Q8_XW	32
#undef	__Q8_XU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#define	__Q8_GT	long double
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#define	__Q8_MW	32
#define	__Q8_MT	long
#define	__Q8_MS	L
#define	__Q8_MF	"l"
#undef	__Q8_GT		/* long double not supported */
#endif

#elif	defined(__ORCAC__)		/* Apple IIGS, large memory model */

/* #pragma	optimize	-1	/* enables all compiler optimizations */

#define	__Q8_TC
#define	__Q8_SC	signed char
#define	__Q8_CW	8
#define	__Q8_SW	16
#define	__Q8_IW	16
#define	__Q8_LW	32
#define	__Q8_PW	32
#define	__Q8_DW	32
#define	__Q8_AW	16
#undef	__Q8_AU
#define	__Q8_ZW	32		/* XXX -- check */
#define	__Q8_WW	32
#undef	__Q8_WU
#if	__STDC_VERSION__ >= 199901
#define	__Q8_CF	"hh"
#define	__Q8_QW	64
#define	__Q8_QT	long long
#define	__Q8_QS	LL
#define	__Q8_QF	"ll"
#define	__Q8_MW	__Q8_QW
#define	__Q8_MT	__Q8_QT
#define	__Q8_MS	__Q8_QS
#define	__Q8_MF	__Q8_QF
#else
#undef	__Q8_CF		/* no known length modifier for character type */
#define	__Q8_MW	32
#define	__Q8_MT	long
#define	__Q8_MS	L
#define	__Q8_MF	"l"
#endif
#define	__Q8_GT	long double

#else

#error	"Q8defs.h: unknown CPU type"

#endif

#if	defined(__Q8_TEST)

/*	sanity checks	*/

#if	defined(__Q8_TC)+defined(__Q8_OC)+defined(__Q8_SM) != 1
#error	"Q8defs.h: representation improperly defined"
#endif

#if	__Q8_CW < 8
#error	"Q8defs.h: __Q8_CW improperly defined"
#endif

#if	__Q8_SW < __Q8_CW || __Q8_SW < 16
#error	"Q8defs.h: __Q8_SW improperly defined"
#endif

#if	__Q8_IW < __Q8_SW
#error	"Q8defs.h: __Q8_IW improperly defined"
#endif

#if	__Q8_LW < __Q8_IW || __Q8_LW < 32 
#error	"Q8defs.h: __Q8_LW improperly defined"
#endif

#ifdef	__Q8_PW
#if	__Q8_PW < 16 || __Q8_PW < __Q8_CW || \
	__STDC_VERSION__ >= 199901 && __Q8_PW < 17
#error	"Q8defs.h: __Q8_PW improperly defined"
#endif
#endif

#ifdef	__Q8_DW
#if	__Q8_DW < 16 || __Q8_DW < __Q8_CW || \
	__STDC_VERSION__ >= 199901 && __Q8_DW < 17
#error	"Q8defs.h: __Q8_DW improperly defined"
#endif
#endif

#if	__Q8_AW < __Q8_CW
#error	"Q8defs.h: __Q8_AW improperly defined"
#endif

#if	__Q8_ZW < 16 || __Q8_ZW < __Q8_CW
#error	"Q8defs.h: __Q8_ZW improperly defined"
#endif

#if	__Q8_WW < __Q8_CW
#error	"Q8defs.h: __Q8_WW improperly defined"
#endif

#if	__Q8_XW < 16 || __Q8_XW < __Q8_CW
#error	"Q8defs.h: __Q8_XW improperly defined"
#endif

#ifdef	__Q8_QT
#if	__Q8_QW < __Q8_LW || __Q8_QW < 64
#error	"Q8defs.h: __Q8_QW improperly defined"
#endif
#elif	__STDC_VERSION__ >= 199901
#error	"Q8defs.h: __Q8_QT not defined"
#endif

#if	__Q8_MW < __Q8_LW || defined(__Q8_QT) && __Q8_MW < __Q8_QW
#error	"Q8defs.h: __Q8_MW improperly defined"
#endif

#ifndef	__Q8_MT
#error	"Q8defs.h: __Q8_MT not defined"
#endif

#endif	/* defined(__Q8_TEST) */

/*	limits for various types	*/

/* top signed values */
#define	__Q8_TI(w)	(~(~0<<(w)-1))
#define	__Q8_TL		(~(~0L<<__Q8_LW-1))
#define	__Q8_TQ		(~(~__Q8_2J(0,__Q8_QS)<<__Q8_QW-1))
#define	__Q8_TM		(~(~__Q8_2J(0,__Q8_MS)<<__Q8_MW-1))

/* upper unsigned values */
#define	__Q8_UI(w)	(~0U>>__Q8_IW-(w))
#define	__Q8_UL		(~0UL)
#define	__Q8_UQ		(~__Q8_2J(0U,__Q8_QS))
#define	__Q8_UM		(~__Q8_2J(0U,__Q8_MS))

/* bottom signed values */
#if	defined(__Q8_TC)
#define	__Q8_BI(w)	(-__Q8_TI(w)-1)
#define	__Q8_BL		(-__Q8_TL-1)
#define	__Q8_BQ		(-__Q8_TQ-1)
#define	__Q8_BM		(-__Q8_TM-1)
#else	/* defined(__Q8_OC) || defined(__Q8_SM) */
#define	__Q8_BI(w)	(-__Q8_TI(w))
#define	__Q8_BL		(-__Q8_TL)
#define	__Q8_BQ		(-__Q8_TQ)
#define	__Q8_BM		(-__Q8_TM)
#endif

#if	defined(__Q8_TEST)

/*	sanity checks	*/

#define	__Q8_X1		1
#define	__Q8_X2		2u
#if	__Q8_2J(__Q8_X1,__Q8_X2) != 12u
#error	"Q8defs.h: __Q8_2J macro is broken"
#endif

#if	__Q8_TI(__Q8_CW) <= 0 || __Q8_BI(__Q8_CW) >= 0 || \
	__Q8_TI(__Q8_SW) <= 0 || __Q8_BI(__Q8_SW) >= 0 || \
	__Q8_TI(__Q8_IW) <= 0 || __Q8_BI(__Q8_IW) >= 0 || \
	__Q8_TI(__Q8_CW) <= __Q8_BI(__Q8_CW) || \
	__Q8_TI(__Q8_SW) <= __Q8_BI(__Q8_SW) || \
	__Q8_TI(__Q8_IW) <= __Q8_BI(__Q8_IW)
#error	"Q8defs.h: __Q8_TI, __Q8_BI macros are broken"
#endif
#if	__Q8_UI(__Q8_CW) <= 0 || __Q8_UI(__Q8_CW) <= __Q8_TI(__Q8_CW) || \
	__Q8_UI(__Q8_SW) <= 0 || __Q8_UI(__Q8_SW) <= __Q8_TI(__Q8_SW) || \
	__Q8_UI(__Q8_IW) <= 0 || __Q8_UI(__Q8_IW) <= __Q8_TI(__Q8_IW)
#error	"Q8defs.h: __Q8_UI or __Q8_TI macro is broken"
#endif

#if	__Q8_TL <= 0 || __Q8_BL >= 0 || __Q8_TL <= __Q8_BL
#error	"Q8defs.h: __Q8_TL, __Q8_BL macros are broken"
#endif
#if	__Q8_UL <= 0 || __Q8_UL <= __Q8_TL
#error	"Q8defs.h: __Q8_UL or __Q8_TL macro is broken"
#endif

#ifdef	__Q8_QT
#if	__Q8_TQ <= 0 || __Q8_BQ >= 0 || __Q8_TQ <= __Q8_BQ
#error	"Q8defs.h: __Q8_TQ, __Q8_BQ macros are broken"
#endif
#if	__Q8_UQ <= 0 || __Q8_UQ <= __Q8_TQ
#if 0				/* XXX -- not working on Solaris */
#error	"Q8defs.h: __Q8_UQ or __Q8_TQ macro is broken"
#endif
#endif
#endif

#if	__Q8_TM <= 0 || __Q8_BM >= 0 || __Q8_TM <= __Q8_BM
#error	"Q8defs.h: __Q8_TM, __Q8_BM macros are broken"
#endif
#if	__Q8_UM <= 0 || __Q8_UM <= __Q8_TM
#if 0				/* XXX -- not working on Solaris */
#error	"Q8defs.h: __Q8_UM or __Q8_TM macro is broken"
#endif
#endif

#endif	/* defined(__Q8_TEST) */
END OF Q8defs.h
echo 'inttypes.h' 1>&2
cat >'inttypes.h' <<'END OF inttypes.h'
/*
	inttypes.h -- format conversion of integer types

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.8 of ISO/IEC 9899:1999 (E).

	This particular implementation requires the matching <stdint.h>
	and inttypes.c.

	This implementation is SELF-CONFIGURING, based on parameters defined
	in <stdint.h>.  If you plan to include it in a C implementation,
	it would be best to trim it down, with all the parameterized actions
	already performed.
*/

#if	!defined(_INTTYPES_H) && !defined(_INC_INTTYPES)	/* usual */
#define	_INTTYPES_H			/* idempotency lock (section 7.1.2) */
#define	_INC_INTTYPES

#include	<stdint.h>		/* defines various __Q8_* symbols */

#ifdef	__cplusplus
extern	"C"	{
#endif

/*
	type defined by this header (only)
*/

typedef struct
	{
	intmax_t	quot;		/* member order must match function */
	intmax_t	rem;
	}			imaxdiv_t;

#if	!defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)

/* figure out the type of wchar_t */
#ifdef	__Q8_WU

#if	__Q8_CW >= __Q8_WW
#define	__Q8_WT		unsigned char
#elif	__Q8_SW >= __Q8_WW
#define	__Q8_WT		unsigned short
#elif	__Q8_IW >= __Q8_WW
#define	__Q8_WT		unsigned int
#elif	__Q8_LW >= __Q8_WW
#define	__Q8_WT		unsigned long
#elif	__Q8_QW >= __Q8_WW
#define	__Q8_WT		unsigned __Q8_QT
#else
#define	__Q8_WT		unsigned __Q8_MT
#endif

#define	WCHAR_MIN		0

#else	/* !defined(__Q8_WU) */

#if	__Q8_CW >= __Q8_WW && defined(__Q8_SC)
#define	__Q8_WT		__Q8_SC
#elif	__Q8_SW >= __Q8_WW
#define	__Q8_WT		short
#elif	__Q8_IW >= __Q8_WW
#define	__Q8_WT		int
#elif	__Q8_LW >= __Q8_WW
#define	__Q8_WT		long
#elif	__Q8_QW >= __Q8_WW
#define	__Q8_WT		__Q8_QT
#else
#define	__Q8_WT		__Q8_MT
#endif

#endif	/* defined(__Q8_WU) */

/*
	7.8.1	Macros for format specifiers

	The optional 40-bit type is supported by the TMS320C6xxx DSP.

	Note that there was no length modifier for char type prior to C99.
*/

#if	__Q8_CW == 8 && defined(__Q8_SC)
#define	PRId8			"d"
#define	PRIi8			"i"
#define	PRIo8			"o"
#define	PRIu8			"u"
#define	PRIx8			"x"
#define	PRIX8			"X"
#ifdef	__Q8_CF
#define	SCNd8			__Q8_CF"d"
#define	SCNi8			__Q8_CF"i"
#define	SCNo8			__Q8_CF"o"
#define	SCNu8			__Q8_CF"u"
#define	SCNx8			__Q8_CF"x"
#endif
#endif
#if	__Q8_CW == 16 && defined(__Q8_SC)
#define	PRId16			"d"
#define	PRIi16			"i"
#define	PRIo16			"o"
#define	PRIu16			"u"
#define	PRIx16			"x"
#define	PRIX16			"X"
#ifdef	__Q8_CF
#define	SCNd16			__Q8_CF"d"
#define	SCNi16			__Q8_CF"i"
#define	SCNo16			__Q8_CF"o"
#define	SCNu16			__Q8_CF"u"
#define	SCNx16			__Q8_CF"x"
#endif
#elif	__Q8_SW == 16
#define	PRId16			"d"
#define	PRIi16			"i"
#define	PRIo16			"o"
#define	PRIu16			"u"
#define	PRIx16			"x"
#define	PRIX16			"X"
#define	SCNd16			"hd"
#define	SCNi16			"hi"
#define	SCNo16			"ho"
#define	SCNu16			"hu"
#define	SCNx16			"hx"
#endif
#if	__Q8_CW == 32 && defined(__Q8_SC)
#define	PRId32			"d"
#define	PRIi32			"i"
#define	PRIo32			"o"
#define	PRIu32			"u"
#define	PRIx32			"x"
#define	PRIX32			"X"
#ifdef	__Q8_CF
#define	SCNd32			__Q8_CF"d"
#define	SCNi32			__Q8_CF"i"
#define	SCNo32			__Q8_CF"o"
#define	SCNu32			__Q8_CF"u"
#define	SCNx32			__Q8_CF"x"
#endif
#elif	__Q8_SW == 32
#define	PRId32			"d"
#define	PRIi32			"i"
#define	PRIo32			"o"
#define	PRIu32			"u"
#define	PRIx32			"x"
#define	PRIX32			"X"
#define	SCNd32			"hd"
#define	SCNi32			"hi"
#define	SCNo32			"ho"
#define	SCNu32			"hu"
#define	SCNx32			"hx"
#elif	__Q8_IW == 32
#define	PRId32			"d"
#define	PRIi32			"i"
#define	PRIo32			"o"
#define	PRIu32			"u"
#define	PRIx32			"x"
#define	PRIX32			"X"
#define	SCNd32			"d"
#define	SCNi32			"i"
#define	SCNo32			"o"
#define	SCNu32			"u"
#define	SCNx32			"x"
#elif	__Q8_LW == 32
#define	PRId32			"ld"
#define	PRIi32			"li"
#define	PRIo32			"lo"
#define	PRIu32			"lu"
#define	PRIx32			"lx"
#define	PRIX32			"lX"
#define	SCNd32			"ld"
#define	SCNi32			"li"
#define	SCNo32			"lo"
#define	SCNu32			"lu"
#define	SCNx32			"lx"
#endif
#if	__Q8_CW == 40 && defined(__Q8_SC)
#define	PRId40			"d"
#define	PRIi40			"i"
#define	PRIo40			"o"
#define	PRIu40			"u"
#define	PRIx40			"x"
#define	PRIX40			"X"
#ifdef	__Q8_CF
#define	SCNd40			__Q8_CF"d"
#define	SCNi40			__Q8_CF"i"
#define	SCNo40			__Q8_CF"o"
#define	SCNu40			__Q8_CF"u"
#define	SCNx40			__Q8_CF"x"
#endif
#elif	__Q8_SW == 40
#define	PRId40			"d"
#define	PRIi40			"i"
#define	PRIo40			"o"
#define	PRIu40			"u"
#define	PRIx40			"x"
#define	PRIX40			"X"
#define	SCNd40			"hd"
#define	SCNi40			"hi"
#define	SCNo40			"ho"
#define	SCNu40			"hu"
#define	SCNx40			"hx"
#elif	__Q8_IW == 40
#define	PRId40			"d"
#define	PRIi40			"i"
#define	PRIo40			"o"
#define	PRIu40			"u"
#define	PRIx40			"x"
#define	PRIX40			"X"
#define	SCNd40			"d"
#define	SCNi40			"i"
#define	SCNo40			"o"
#define	SCNu40			"u"
#define	SCNx40			"x"
#elif	__Q8_LW == 40
#define	PRId40			"ld"
#define	PRIi40			"li"
#define	PRIo40			"lo"
#define	PRIu40			"lu"
#define	PRIx40			"lx"
#define	PRIX40			"lX"
#define	SCNd40			"ld"
#define	SCNi40			"li"
#define	SCNo40			"lo"
#define	SCNu40			"lu"
#define	SCNx40			"lx"
#endif
#if	__Q8_CW == 64 && defined(__Q8_SC)
#define	PRId64			"d"
#define	PRIi64			"i"
#define	PRIo64			"o"
#define	PRIu64			"u"
#define	PRIx64			"x"
#define	PRIX64			"X"
#ifdef	__Q8_CF
#define	SCNd64			__Q8_CF"d"
#define	SCNi64			__Q8_CF"i"
#define	SCNo64			__Q8_CF"o"
#define	SCNu64			__Q8_CF"u"
#define	SCNx64			__Q8_CF"x"
#endif
#elif	__Q8_SW == 64
#define	PRId64			"d"
#define	PRIi64			"i"
#define	PRIo64			"o"
#define	PRIu64			"u"
#define	PRIx64			"x"
#define	PRIX64			"X"
#define	SCNd64			"hd"
#define	SCNi64			"hi"
#define	SCNo64			"ho"
#define	SCNu64			"hu"
#define	SCNx64			"hx"
#elif	__Q8_IW == 64
#define	PRId64			"d"
#define	PRIi64			"i"
#define	PRIo64			"o"
#define	PRIu64			"u"
#define	PRIx64			"x"
#define	PRIX64			"X"
#define	SCNd64			"d"
#define	SCNi64			"i"
#define	SCNo64			"o"
#define	SCNu64			"u"
#define	SCNx64			"x"
#elif	__Q8_LW == 64
#define	PRId64			"ld"
#define	PRIi64			"li"
#define	PRIo64			"lo"
#define	PRIu64			"lu"
#define	PRIx64			"lx"
#define	PRIX64			"lX"
#define	SCNd64			"ld"
#define	SCNi64			"li"
#define	SCNo64			"lo"
#define	SCNu64			"lu"
#define	SCNx64			"lx"
#elif	__Q8_QW == 64
#define	PRId64			__Q8_QF"d"
#define	PRIi64			__Q8_QF"i"
#define	PRIo64			__Q8_QF"o"
#define	PRIu64			__Q8_QF"u"
#define	PRIx64			__Q8_QF"x"
#define	PRIX64			__Q8_QF"X"
#define	SCNd64			__Q8_QF"d"
#define	SCNi64			__Q8_QF"i"
#define	SCNo64			__Q8_QF"o"
#define	SCNu64			__Q8_QF"u"
#define	SCNx64			__Q8_QF"x"
#endif

#if	__Q8_CW < __Q8_IW && defined(__Q8_SC)
#define	PRIdLEAST8		"d"
#define	PRIiLEAST8		"i"
#define	PRIoLEAST8		"o"
#define	PRIuLEAST8		"u"
#define	PRIxLEAST8		"x"
#define	PRIXLEAST8		"X"
#ifdef	__Q8_CF
#define	SCNdLEAST8		__Q8_CF"d"
#define	SCNiLEAST8		__Q8_CF"i"
#define	SCNoLEAST8		__Q8_CF"o"
#define	SCNuLEAST8		__Q8_CF"u"
#define	SCNxLEAST8		__Q8_CF"x"
#endif
#elif	__Q8_SW < __Q8_IW
#define	PRIdLEAST8		"d"
#define	PRIiLEAST8		"i"
#define	PRIoLEAST8		"o"
#define	PRIuLEAST8		"u"
#define	PRIxLEAST8		"x"
#define	PRIXLEAST8		"X"
#define	SCNdLEAST8		"hd"
#define	SCNiLEAST8		"hi"
#define	SCNoLEAST8		"ho"
#define	SCNuLEAST8		"hu"
#define	SCNxLEAST8		"hx"
#else
#define	PRIdLEAST8		"d"
#define	PRIiLEAST8		"i"
#define	PRIoLEAST8		"o"
#define	PRIuLEAST8		"u"
#define	PRIxLEAST8		"x"
#define	PRIXLEAST8		"X"
#define	SCNdLEAST8		"d"
#define	SCNiLEAST8		"i"
#define	SCNoLEAST8		"o"
#define	SCNuLEAST8		"u"
#define	SCNxLEAST8		"x"
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 16 && defined(__Q8_SC)
#define	PRIdLEAST16		"d"
#define	PRIiLEAST16		"i"
#define	PRIoLEAST16		"o"
#define	PRIuLEAST16		"u"
#define	PRIxLEAST16		"x"
#define	PRIXLEAST16		"X"
#ifdef	__Q8_CF
#define	SCNdLEAST16		__Q8_CF"d"
#define	SCNiLEAST16		__Q8_CF"i"
#define	SCNoLEAST16		__Q8_CF"o"
#define	SCNuLEAST16		__Q8_CF"u"
#define	SCNxLEAST16		__Q8_CF"x"
#endif
#elif	__Q8_SW < __Q8_IW
#define	PRIdLEAST16		"d"
#define	PRIiLEAST16		"i"
#define	PRIoLEAST16		"o"
#define	PRIuLEAST16		"u"
#define	PRIxLEAST16		"x"
#define	PRIXLEAST16		"X"
#define	SCNdLEAST16		"hd"
#define	SCNiLEAST16		"hi"
#define	SCNoLEAST16		"ho"
#define	SCNuLEAST16		"hu"
#define	SCNxLEAST16		"hx"
#else
#define	PRIdLEAST16		"d"
#define	PRIiLEAST16		"i"
#define	PRIoLEAST16		"o"
#define	PRIuLEAST16		"u"
#define	PRIxLEAST16		"x"
#define	PRIXLEAST16		"X"
#define	SCNdLEAST16		"d"
#define	SCNiLEAST16		"i"
#define	SCNoLEAST16		"o"
#define	SCNuLEAST16		"u"
#define	SCNxLEAST16		"x"
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 32 && defined(__Q8_SC)
#define	PRIdLEAST32		"d"
#define	PRIiLEAST32		"i"
#define	PRIoLEAST32		"o"
#define	PRIuLEAST32		"u"
#define	PRIxLEAST32		"x"
#define	PRIXLEAST32		"X"
#ifdef	__Q8_CF
#define	SCNdLEAST32		__Q8_CF"d"
#define	SCNiLEAST32		__Q8_CF"i"
#define	SCNoLEAST32		__Q8_CF"o"
#define	SCNuLEAST32		__Q8_CF"u"
#define	SCNxLEAST32		__Q8_CF"x"
#endif
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 32
#define	PRIdLEAST32		"d"
#define	PRIiLEAST32		"i"
#define	PRIoLEAST32		"o"
#define	PRIuLEAST32		"u"
#define	PRIxLEAST32		"x"
#define	PRIXLEAST32		"X"
#define	SCNdLEAST32		"hd"
#define	SCNiLEAST32		"hi"
#define	SCNoLEAST32		"ho"
#define	SCNuLEAST32		"hu"
#define	SCNx32			"hx"
#elif	__Q8_IW >= 32
#define	PRIdLEAST32		"d"
#define	PRIiLEAST32		"i"
#define	PRIoLEAST32		"o"
#define	PRIuLEAST32		"u"
#define	PRIxLEAST32		"x"
#define	PRIXLEAST32		"X"
#define	SCNdLEAST32		"d"
#define	SCNiLEAST32		"i"
#define	SCNoLEAST32		"o"
#define	SCNuLEAST32		"u"
#define	SCNxLEAST32		"x"
#else
#define	PRIdLEAST32		"ld"
#define	PRIiLEAST32		"li"
#define	PRIoLEAST32		"lo"
#define	PRIuLEAST32		"lu"
#define	PRIxLEAST32		"lx"
#define	PRIXLEAST32		"lX"
#define	SCNdLEAST32		"ld"
#define	SCNiLEAST32		"li"
#define	SCNoLEAST32		"lo"
#define	SCNuLEAST32		"lu"
#define	SCNxLEAST32		"lx"
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 40 && defined(__Q8_SC)
#define	PRIdLEAST40		"d"
#define	PRIiLEAST40		"i"
#define	PRIoLEAST40		"o"
#define	PRIuLEAST40		"u"
#define	PRIxLEAST40		"x"
#define	PRIXLEAST40		"X"
#ifdef	__Q8_CF
#define	SCNdLEAST40		__Q8_CF"d"
#define	SCNiLEAST40		__Q8_CF"i"
#define	SCNoLEAST40		__Q8_CF"o"
#define	SCNuLEAST40		__Q8_CF"u"
#define	SCNxLEAST40		__Q8_CF"x"
#endif
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 40
#define	PRIdLEAST40		"d"
#define	PRIiLEAST40		"i"
#define	PRIoLEAST40		"o"
#define	PRIuLEAST40		"u"
#define	PRIxLEAST40		"x"
#define	PRIXLEAST40		"X"
#define	SCNdLEAST40		"hd"
#define	SCNiLEAST40		"hi"
#define	SCNoLEAST40		"ho"
#define	SCNuLEAST40		"hu"
#define	SCNxLEAST40		"hx"
#elif	__Q8_IW >= 40
#define	PRIdLEAST40		"d"
#define	PRIiLEAST40		"i"
#define	PRIoLEAST40		"o"
#define	PRIuLEAST40		"u"
#define	PRIxLEAST40		"x"
#define	PRIXLEAST40		"X"
#define	SCNdLEAST40		"d"
#define	SCNiLEAST40		"i"
#define	SCNoLEAST40		"o"
#define	SCNuLEAST40		"u"
#define	SCNxLEAST40		"x"
#elif	__Q8_LW >= 40
#define	PRIdLEAST40		"ld"
#define	PRIiLEAST40		"li"
#define	PRIoLEAST40		"lo"
#define	PRIuLEAST40		"lu"
#define	PRIxLEAST40		"lx"
#define	PRIXLEAST40		"lX"
#define	SCNdLEAST40		"ld"
#define	SCNiLEAST40		"li"
#define	SCNoLEAST40		"lo"
#define	SCNuLEAST40		"lu"
#define	SCNxLEAST40		"lx"
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
#define	PRIdLEAST40		__Q8_QF"d"
#define	PRIiLEAST40		__Q8_QF"i"
#define	PRIoLEAST40		__Q8_QF"o"
#define	PRIuLEAST40		__Q8_QF"u"
#define	PRIxLEAST40		__Q8_QF"x"
#define	PRIXLEAST40		__Q8_QF"X"
#define	SCNdLEAST40		__Q8_QF"d"
#define	SCNiLEAST40		__Q8_QF"i"
#define	SCNoLEAST40		__Q8_QF"o"
#define	SCNuLEAST40		__Q8_QF"u"
#define	SCNxLEAST40		__Q8_QF"x"
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 64 && defined(__Q8_SC)
#define	PRIdLEAST64		"d"
#define	PRIiLEAST64		"i"
#define	PRIoLEAST64		"o"
#define	PRIuLEAST64		"u"
#define	PRIxLEAST64		"x"
#define	PRIXLEAST64		"X"
#ifdef	__Q8_CF
#define	SCNdLEAST64		__Q8_CF"d"
#define	SCNiLEAST64		__Q8_CF"i"
#define	SCNoLEAST64		__Q8_CF"o"
#define	SCNuLEAST64		__Q8_CF"u"
#define	SCNxLEAST64		__Q8_CF"x"
#endif
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 64
#define	PRIdLEAST64		"d"
#define	PRIiLEAST64		"i"
#define	PRIoLEAST64		"o"
#define	PRIuLEAST64		"u"
#define	PRIxLEAST64		"x"
#define	PRIXLEAST64		"X"
#define	SCNdLEAST64		"hd"
#define	SCNiLEAST64		"hi"
#define	SCNoLEAST64		"ho"
#define	SCNuLEAST64		"hu"
#define	SCNxLEAST64		"hx"
#elif	__Q8_IW >= 64
#define	PRIdLEAST64		"d"
#define	PRIiLEAST64		"i"
#define	PRIoLEAST64		"o"
#define	PRIuLEAST64		"u"
#define	PRIxLEAST64		"x"
#define	PRIXLEAST64		"X"
#define	SCNdLEAST64		"d"
#define	SCNiLEAST64		"i"
#define	SCNoLEAST64		"o"
#define	SCNuLEAST64		"u"
#define	SCNxLEAST64		"x"
#elif	__Q8_LW >= 64
#define	PRIdLEAST64		"ld"
#define	PRIiLEAST64		"li"
#define	PRIoLEAST64		"lo"
#define	PRIuLEAST64		"lu"
#define	PRIxLEAST64		"lx"
#define	PRIXLEAST64		"lX"
#define	SCNdLEAST64		"ld"
#define	SCNiLEAST64		"li"
#define	SCNoLEAST64		"lo"
#define	SCNuLEAST64		"lu"
#define	SCNxLEAST64		"lx"
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
#define	PRIdLEAST64		__Q8_QF"d"
#define	PRIiLEAST64		__Q8_QF"i"
#define	PRIoLEAST64		__Q8_QF"o"
#define	PRIuLEAST64		__Q8_QF"u"
#define	PRIxLEAST64		__Q8_QF"x"
#define	PRIXLEAST64		__Q8_QF"X"
#define	SCNdLEAST64		__Q8_QF"d"
#define	SCNiLEAST64		__Q8_QF"i"
#define	SCNoLEAST64		__Q8_QF"o"
#define	SCNuLEAST64		__Q8_QF"u"
#define	SCNxLEAST64		__Q8_QF"x"
#endif

#define	PRIdFAST8		"d"
#define	PRIiFAST8		"i"
#define	PRIoFAST8		"o"
#define	PRIuFAST8		"u"
#define	PRIxFAST8		"x"
#define	PRIXFAST8		"X"
#define	SCNdFAST8		"d"
#define	SCNiFAST8		"i"
#define	SCNoFAST8		"o"
#define	SCNuFAST8		"u"
#define	SCNxFAST8		"x"
#define	PRIdFAST16		"d"
#define	PRIiFAST16		"i"
#define	PRIoFAST16		"o"
#define	PRIuFAST16		"u"
#define	PRIxFAST16		"x"
#define	PRIXFAST16		"X"
#define	SCNdFAST16		"d"
#define	SCNiFAST16		"i"
#define	SCNoFAST16		"o"
#define	SCNuFAST16		"u"
#define	SCNxFAST16		"x"
#if	__Q8_IW >= 32
#define	PRIdFAST32		"d"
#define	PRIiFAST32		"i"
#define	PRIoFAST32		"o"
#define	PRIuFAST32		"u"
#define	PRIxFAST32		"x"
#define	PRIXFAST32		"X"
#define	SCNdFAST32		"d"
#define	SCNiFAST32		"i"
#define	SCNoFAST32		"o"
#define	SCNuFAST32		"u"
#define	SCNxFAST32		"x"
#else
#define	PRIdFAST32		"ld"
#define	PRIiFAST32		"li"
#define	PRIoFAST32		"lo"
#define	PRIuFAST32		"lu"
#define	PRIxFAST32		"lx"
#define	PRIXFAST32		"lX"
#define	SCNdFAST32		"ld"
#define	SCNiFAST32		"li"
#define	SCNoFAST32		"lo"
#define	SCNuFAST32		"lu"
#define	SCNxFAST32		"lx"
#endif
#if	__Q8_IW >= 40
#define	PRIdFAST40		"d"
#define	PRIiFAST40		"i"
#define	PRIoFAST40		"o"
#define	PRIuFAST40		"u"
#define	PRIxFAST40		"x"
#define	PRIXFAST40		"X"
#define	SCNdFAST40		"d"
#define	SCNiFAST40		"i"
#define	SCNoFAST40		"o"
#define	SCNuFAST40		"u"
#define	SCNxFAST40		"x"
#elif	__Q8_LW >= 40
#define	PRIdFAST40		"ld"
#define	PRIiFAST40		"li"
#define	PRIoFAST40		"lo"
#define	PRIuFAST40		"lu"
#define	PRIxFAST40		"lx"
#define	PRIXFAST40		"lX"
#define	SCNdFAST40		"ld"
#define	SCNiFAST40		"li"
#define	SCNoFAST40		"lo"
#define	SCNuFAST40		"lu"
#define	SCNxFAST40		"lx"
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
#define	PRIdFAST40		__Q8_QF"d"
#define	PRIiFAST40		__Q8_QF"i"
#define	PRIoFAST40		__Q8_QF"o"
#define	PRIuFAST40		__Q8_QF"u"
#define	PRIxFAST40		__Q8_QF"x"
#define	PRIXFAST40		__Q8_QF"X"
#define	SCNdFAST40		__Q8_QF"d"
#define	SCNiFAST40		__Q8_QF"i"
#define	SCNoFAST40		__Q8_QF"o"
#define	SCNuFAST40		__Q8_QF"u"
#define	SCNxFAST40		__Q8_QF"x"
#endif
#if	__Q8_IW >= 64
#define	PRIdFAST64		"d"
#define	PRIiFAST64		"i"
#define	PRIoFAST64		"o"
#define	PRIuFAST64		"u"
#define	PRIxFAST64		"x"
#define	PRIXFAST64		"X"
#define	SCNdFAST64		"d"
#define	SCNiFAST64		"i"
#define	SCNoFAST64		"o"
#define	SCNuFAST64		"u"
#define	SCNxFAST64		"x"
#elif	__Q8_LW >= 64
#define	PRIdFAST64		"ld"
#define	PRIiFAST64		"li"
#define	PRIoFAST64		"lo"
#define	PRIuFAST64		"lu"
#define	PRIxFAST64		"lx"
#define	PRIXFAST64		"lX"
#define	SCNdFAST64		"ld"
#define	SCNiFAST64		"li"
#define	SCNoFAST64		"lo"
#define	SCNuFAST64		"lu"
#define	SCNxFAST64		"lx"
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
#define	PRIdFAST64		__Q8_QF"d"
#define	PRIiFAST64		__Q8_QF"i"
#define	PRIoFAST64		__Q8_QF"o"
#define	PRIuFAST64		__Q8_QF"u"
#define	PRIxFAST64		__Q8_QF"x"
#define	PRIXFAST64		__Q8_QF"X"
#define	SCNdFAST64		__Q8_QF"d"
#define	SCNiFAST64		__Q8_QF"i"
#define	SCNoFAST64		__Q8_QF"o"
#define	SCNuFAST64		__Q8_QF"u"
#define	SCNxFAST64		__Q8_QF"x"
#endif

#define	PRIdMAX			__Q8_MF"d"
#define	PRIiMAX			__Q8_MF"i"
#define	PRIoMAX			__Q8_MF"o"
#define	PRIuMAX			__Q8_MF"u"
#define	PRIxMAX			__Q8_MF"x"
#define	PRIXMAX			__Q8_MF"X"
#define	SCNdMAX			__Q8_MF"d"
#define	SCNiMAX			__Q8_MF"i"
#define	SCNoMAX			__Q8_MF"o"
#define	SCNuMAX			__Q8_MF"u"
#define	SCNxMAX			__Q8_MF"x"

#if	defined(__Q8_PW)
#if	__Q8_IW >= __Q8_PW
#define	PRIdPTR			"d"
#define	PRIiPTR			"i"
#define	PRIoPTR			"o"
#define	PRIuPTR			"u"
#define	PRIxPTR			"x"
#define	PRIXPTR			"X"
#define	SCNdPTR			"d"
#define	SCNiPTR			"i"
#define	SCNoPTR			"o"
#define	SCNuPTR			"u"
#define	SCNxPTR			"x"
#elif	__Q8_LW >= __Q8_PW
#define	PRIdPTR			"ld"
#define	PRIiPTR			"li"
#define	PRIoPTR			"lo"
#define	PRIuPTR			"lu"
#define	PRIxPTR			"lx"
#define	PRIXPTR			"lX"
#define	SCNdPTR			"ld"
#define	SCNiPTR			"li"
#define	SCNoPTR			"lo"
#define	SCNuPTR			"lu"
#define	SCNxPTR			"lx"
#elif	__Q8_QW >= __Q8_PW
#define	PRIdPTR			__Q8_QF"d"
#define	PRIiPTR			__Q8_QF"i"
#define	PRIoPTR			__Q8_QF"o"
#define	PRIuPTR			__Q8_QF"u"
#define	PRIxPTR			__Q8_QF"x"
#define	PRIXPTR			__Q8_QF"X"
#define	SCNdPTR			__Q8_QF"d"
#define	SCNiPTR			__Q8_QF"i"
#define	SCNoPTR			__Q8_QF"o"
#define	SCNuPTR			__Q8_QF"u"
#define	SCNxPTR			__Q8_QF"x"
#elif	__Q8_MW >= __Q8_PW
#define	PRIdPTR			__Q8_MF"d"
#define	PRIiPTR			__Q8_MF"i"
#define	PRIoPTR			__Q8_MF"o"
#define	PRIuPTR			__Q8_MF"u"
#define	PRIxPTR			__Q8_MF"x"
#define	PRIXPTR			__Q8_MF"X"
#define	SCNdPTR			__Q8_MF"d"
#define	SCNiPTR			__Q8_MF"i"
#define	SCNoPTR			__Q8_MF"o"
#define	SCNuPTR			__Q8_MF"u"
#define	SCNxPTR			__Q8_MF"x"
#endif
#endif

#endif	/* !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) */

/*
	7.8.2	Functions for greatest-width integer types
*/

intmax_t	imaxabs __Q8_PARAMS((intmax_t __j));
imaxdiv_t	imaxdiv __Q8_PARAMS((intmax_t __numer, intmax_t __denom));
intmax_t	strtoimax __Q8_PARAMS((__Q8_CONST char *__Q8_RESTRICT __nptr,
			char **__Q8_RESTRICT __endptr, int __base));
uintmax_t	strtoumax __Q8_PARAMS((__Q8_CONST char *__Q8_RESTRICT __nptr,
			char **__Q8_RESTRICT __endptr, int __base));
intmax_t	wcstoimax __Q8_PARAMS((__Q8_CONST __Q8_WT *__Q8_RESTRICT __nptr,
			__Q8_WT **__Q8_RESTRICT __endptr, int __base));
uintmax_t	wcstoumax __Q8_PARAMS((__Q8_CONST __Q8_WT *__Q8_RESTRICT __nptr,
			__Q8_WT **__Q8_RESTRICT __endptr, int __base));

#ifdef	__cplusplus
		}
#endif

#endif	/* !defined(_INTTYPES_H) && !defined(_INC_INTTYPES) */
END OF inttypes.h
echo 'iso646.h' 1>&2
cat >'iso646.h' <<'END OF iso646.h'
/*
	<iso646.h> -- macros for use in place of certain tokens that are
		not expressible in the invariant subset of ISO 646:1991

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclause 7.9 of ISO/IEC 9899:1999 (E).

	Usage:	??=include <iso646.h>

	Notes:	The C standard has always required that the following
		source trigraphs be supported in translation phase 1:
			??= mapped to #
			??( mapped to [
			??/ mapped to \
			??) mapped to ]
			??' mapped to ^
			??< mapped to {
			??! mapped to |
			??> mapped to }
			??- mapped to ~

		ISO/IEC 9899:1994 (ISO/IEC 9899:1990/Amendment 1)
		and subsequently ISO/IEC 9899:1999, which require
		conforming implementations to provide <iso646.h>,
		also require support in translation phases 3..4
		for the following preprocessing tokens:
			%: alternate spelling for #
			%:%: alternate spelling for ##
		They also require support in translation phases 3..7
		for the following preprocessing tokens:
			<: alternate spelling for [
			:> alternate spelling for ]
			<% alternate spelling for {
			%> alternate spelling for }

		The C standard also requires that the "difficult"
		characters be somehow provided in both the basic source
		and execution character sets, regardless of the
		provision of trigraph, digraph, and macro alternatives
		for these characters.  (Thus, the alternate spellings
		are intended to help programmers, not C implementors.)

		The 1999 revision of the C standard adds support for
		international characters in identifiers via Universal
		Character Names, but UCN equivalents are not allowed
		for the aforementioned "difficult" characters.

		It is suggested that *all* C programmers avoid use of
		the following identifiers in their programs, in case
		somebody later needs to use <iso646.h> in maintaining
		the programs.
 */

/* This header doesn't need an idempotency lock; there are no typedefs here. */

/* This header doesn't need C++ extern "C"; there are no declarations here. */

#define and	&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not	!
#define not_eq	!=
#define or	||
#define or_eq	|=
#define xor	^
#define xor_eq	^=
END OF iso646.h
echo 'locale.h' 1>&2
cat >'locale.h' <<'END OF locale.h'
/*
	<locale.h> -- definitions for internationalization functions

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclause 7.11 of ISO/IEC 9899:1999 (E).

	The standard allows additional macro definitions starting with
	"LC_" and an uppercase letter.
 */

/* This header doesn't need an idempotency lock; there are no typedefs here. */

#include	<Q8defs.h>		/* defines __Q8_NULL and __Q8_PARAMS */

#ifdef	__cplusplus
extern	"C"	{
#endif

struct lconv				/* members are in usual UNIX order */
	{
	/* The following are controlled by LC_NUMERIC: */
	char	*decimal_point;
	char	*thousands_sep;
	char	*grouping;
	/* The following are controlled by LC_MONETARY: */
	char	*int_curr_symbol;
	char	*currency_symbol;
	char	*mon_decimal_point;
	char	*mon_thousands_sep;
	char	*mon_grouping;
	char	*positive_sign;
	char	*negative_sign;
	char	int_frac_digits;
	char	frac_digits;
	char	p_cs_precedes;
	char	p_sep_by_space;
	char	n_cs_precedes;
	char	n_sep_by_space;
	char	p_sign_posn;
	char	n_sign_posn;
	char	int_p_cs_precedes;
	char	int_p_sep_by_space;
	char	int_n_cs_precedes;
	char	int_n_sep_by_space;
	char	int_p_sign_posn;
	char	int_n_sign_posn;
	};

/* The following have the usual UNIX values: */
#define	LC_CTYPE	(0)
#define	LC_NUMERIC	(1)
#define	LC_TIME		(2)
#define	LC_COLLATE	(3)
#define	LC_MONETARY	(4)
#define	LC_ALL		(6)
/* other categories may be added here: */
#define	LC_MESSAGES	(5)

#ifndef	NULL
#define	NULL	__Q8_NULL
#endif

extern char		*setlocale __Q8_PARAMS((int __category,
				const char *__locale));
extern struct lconv	*localeconv __Q8_PARAMS((void));

#ifdef	__cplusplus
		}
#endif
END OF locale.h
echo 'signal.h' 1>&2
cat >'signal.h' <<'END OF signal.h'
/*
	signal.h -- signal handling

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.14 of ISO/IEC 9899:1999 (E).

	This particular implementation requires the matching signal.c.

	This is a minimally functional version, solely for systems that don't
	already provide <signal.h> (such as the TMS320C6xxx DSP's compiler).
*/

#if	!defined(_SIGNAL_H) && !defined(_INC_SIGNAL)	/* usual lock names */
#define	_SIGNAL_H			/* idempotency lock (section 7.1.2) */
#define	_INC_SIGNAL

#include	<Q8defs.h>		/* defines __Q8_PARAMS */

#ifdef	__cplusplus
extern	"C"	{
#endif

/* atomic-access data type: */

typedef int	sig_atomic_t;		/* this type works nearly everywhere */

/* signal states: */

#define	SIG_DFL	((void (*)__Q8_PARAMS((int)))0)	/* default */
#define	SIG_ERR	__sig_err		/* error return from signal() */
#define	SIG_IGN	__sig_ign		/* ignore */

/* dummy functions for unique address */
extern void	__sig_err __Q8_PARAMS((int __sig));
extern void	__sig_ign __Q8_PARAMS((int __sig));

/* signal numbers (these are a subset of the traditional UNIX values): */

#define	SIGINT	(2)			/* interactive attention signal */
#define	SIGILL	(4)			/* invalid function image */
#define	SIGABRT	(6)			/* abnormal termination */
#define	SIGFPE	(8)			/* erroneous arithmetic operation */
#define	SIGSEGV	(11)			/* invalid access to storage */
#define	SIGTERM	(15)			/* termination request */
/* Note: SIGTERM is assumed by my signal.c to have the highest value. */

/*
	7.14.1 -- specify signal handling
*/

extern void	(*signal __Q8_PARAMS((int __sig, void (*__func)(int))))
			__Q8_PARAMS((int));

/*
	7.14.2 -- send signal
*/

extern int	raise __Q8_PARAMS((int __sig));

#ifdef	__cplusplus
		}
#endif

#endif	/* !defined(_SIGNAL_H) && !defined(_INC_SIGNAL) */
END OF signal.h
echo 'stdbool.h' 1>&2
cat >'stdbool.h' <<'END OF stdbool.h'
/*
	stdbool.h -- Boolean type and values

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.16 of ISO/IEC 9899:1999 (E).
*/

#if	!defined(_STDBOOL_H) && !defined(_INC_STDBOOL)	/* usual lock names */
#define	_STDBOOL_H			/* idempotency lock (section 7.1.2) */
#define	_INC_STDBOOL

/* This header doesn't need C++ extern "C"; there are no declarations here. */

/* program is allowed to contain its own definitions, so ... */
#undef	bool
#undef	true
#undef	false
#undef	__bool_true_false_are_defined

#define	bool				_Bool
#define	true				1
#define	false				0
#define	__bool_true_false_are_defined	1

#if	__STDC_VERSION__ < 199901
typedef int	_Bool;			/* not built into pre-C99 compilers */
#endif

#endif	/* !defined(_STDBOOL_H) && !defined(_INC_STDBOOL) */
END OF stdbool.h
echo 'stdint.h' 1>&2
cat >'stdint.h' <<'END OF stdint.h'
/*
	stdint.h -- integer types

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.18 of ISO/IEC 9899:1999 (E) + TC1.

	This particular implementation assumes that widths of the standard
	integer types are powers of 2, and that there are no extended integer
	types with intermediate widths.

	This implementation is SELF-CONFIGURING, based on parameters defined
	in <Q8defs.h>.  If you plan to include this in a C implementation,
	it would be best to trim it down, with all the parameterized decisions
	already made.
*/

/* This header doesn't need an idempotency lock; there are no typedefs here. */

#include	<Q8defs.h>		/* defines the __Q8_* symbols */

/* This header doesn't need C++ extern "C"; there are no declarations here. */

/*
	7.18.1.1	Exact-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.
*/

#if	__Q8_CW == 8 && defined(__Q8_SC)
typedef __Q8_SC			int8_t;
typedef unsigned char		uint8_t;
#endif
#if	__Q8_CW == 16 && defined(__Q8_SC)
typedef __Q8_SC			int16_t;
typedef unsigned char		uint16_t;
#elif	__Q8_SW == 16
typedef short			int16_t;
typedef unsigned short		uint16_t;
#endif
#if	__Q8_CW == 32 && defined(__Q8_SC)
typedef __Q8_SC			int32_t;
typedef unsigned char		uint32_t;
#elif	__Q8_SW == 32
typedef short			int32_t;
typedef unsigned short		uint32_t;
#elif	__Q8_IW == 32
typedef int			int32_t;
typedef unsigned int		uint32_t;
#elif	__Q8_LW == 32
typedef long			int32_t;
typedef unsigned long		uint32_t;
#endif
#if	__Q8_CW == 40 && defined(__Q8_SC)
typedef __Q8_SC			int40_t;
typedef unsigned char		uint40_t;
#elif	__Q8_SW == 40
typedef short			int40_t;
typedef unsigned short		uint40_t;
#elif	__Q8_IW == 40
typedef int			int40_t;
typedef unsigned int		uint40_t;
#elif	__Q8_LW == 40
typedef long			int40_t;
typedef unsigned long		uint40_t;
#endif
#if	__Q8_CW == 64 && defined(__Q8_SC)
typedef __Q8_SC			int64_t;
typedef unsigned char		uint64_t;
#elif	__Q8_SW == 64
typedef short			int64_t;
typedef unsigned short		uint64_t;
#elif	__Q8_IW == 64
typedef int			int64_t;
typedef unsigned int		uint64_t;
#elif	__Q8_LW == 64
typedef long			int64_t;
typedef unsigned long		uint64_t;
#elif	__Q8_QW == 64
typedef __Q8_QT			int64_t;
typedef unsigned __Q8_QT	uint64_t;
#endif

/*
	7.18.1.2	Minimum-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.

	Prefers type int over char or short char, due to a possible
	problem constructing suitable integer constants for 7.18.4.1.
*/

#if	__Q8_CW < __Q8_IW && defined(__Q8_SC)
typedef __Q8_SC			int_least8_t;
typedef unsigned char		uint_least8_t;
#elif	__Q8_SW < __Q8_IW
typedef short			int_least8_t;
typedef unsigned short		uint_least8_t;
#else
typedef int			int_least8_t;
typedef unsigned int		uint_least8_t;
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 16 && defined(__Q8_SC)
typedef __Q8_SC			int_least16_t;
typedef unsigned char		uint_least16_t;
#elif	__Q8_SW < __Q8_IW
typedef short			int_least16_t;
typedef unsigned short		uint_least16_t;
#else
typedef int			int_least16_t;
typedef unsigned int		uint_least16_t;
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 32 && defined(__Q8_SC)
typedef __Q8_SC			int_least32_t;
typedef unsigned char		uint_least32_t;
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 32
typedef short			int_least32_t;
typedef unsigned short		uint_least32_t;
#elif	__Q8_IW >= 32
typedef int			int_least32_t;
typedef unsigned int		uint_least32_t;
#else
typedef long			int_least32_t;
typedef unsigned long		uint_least32_t;
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 40 && defined(__Q8_SC)
typedef __Q8_SC			int_least40_t;
typedef unsigned char		uint_least40_t;
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 40
typedef short			int_least40_t;
typedef unsigned short		uint_least40_t;
#elif	__Q8_IW >= 40
typedef int			int_least40_t;
typedef unsigned int		uint_least40_t;
#elif	__Q8_LW >= 40
typedef long			int_least40_t;
typedef unsigned long		uint_least40_t;
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
typedef __Q8_QT			int_least40_t;
typedef unsigned __Q8_QT	uint_least40_t;
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 64 && defined(__Q8_SC)
typedef __Q8_SC			int_least64_t;
typedef unsigned char		uint_least64_t;
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 64
typedef short			int_least64_t;
typedef unsigned short		uint_least64_t;
#elif	__Q8_IW >= 64
typedef int			int_least64_t;
typedef unsigned int		uint_least64_t;
#elif	__Q8_LW >= 64
typedef long			int_least64_t;
typedef unsigned long		uint_least64_t;
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
typedef __Q8_QT		int_least64_t;
typedef unsigned __Q8_QT	uint_least64_t;
#endif

/*
	7.18.1.3	Fastest minimum-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.

	"Fastest" is hard to determine; if "int" qualifies, it is chosen.
*/

typedef int			int_fast8_t;
typedef unsigned int		uint_fast8_t;
typedef int			int_fast16_t;
typedef unsigned int		uint_fast16_t;
#if	__Q8_IW >= 32
typedef int			int_fast32_t;
typedef unsigned int		uint_fast32_t;
#else
typedef long			int_fast32_t;
typedef unsigned long		uint_fast32_t;
#endif
#if	__Q8_IW >= 40
typedef int			int_fast40_t;
typedef unsigned int		uint_fast40_t;
#elif	__Q8_LW >= 40
typedef long			int_fast40_t;
typedef unsigned long		uint_fast40_t;
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
typedef __Q8_QT			int_fast40_t;
typedef unsigned __Q8_QT	uint_fast40_t;
#endif
#if	__Q8_IW >= 64
typedef int			int_fast64_t;
typedef unsigned int		uint_fast64_t;
#elif	__Q8_LW >= 64
typedef long			int_fast64_t;
typedef unsigned long		uint_fast64_t;
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
typedef __Q8_QT			int_fast64_t;
typedef unsigned __Q8_QT	uint_fast64_t;
#endif

/*
	7.18.1.4	Integer types capable of holding object pointers

	Theoretically, these tests might not work (e.g., the implementation
	can limit the interconvertible type to one that is not the smallest
	possible), but I'm unaware of any platform where they fail.
*/

#if	defined(__Q8_PW)
#if	__Q8_IW >= __Q8_PW
typedef int			intptr_t;
typedef unsigned int		uintptr_t;
#elif	__Q8_LW >= __Q8_PW
typedef long			intptr_t;
typedef unsigned long		uintptr_t;
#elif	__Q8_QW >= __Q8_PW
typedef __Q8_QT			intptr_t;
typedef unsigned __Q8_QT	uintptr_t;
#elif	__Q8_MW >= __Q8_PW
typedef __Q8_MT			intptr_t;
typedef unsigned __Q8_MT	uintptr_t;
#endif
#endif

/*
	7.18.1.5	Greatest-width integer types
*/

typedef __Q8_MT			intmax_t;
typedef unsigned __Q8_MT	uintmax_t;

#if	!defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)

/*
	7.18.2.1	Limits of exact-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.
*/

#if	__Q8_CW == 8 && defined(__Q8_SC)
#define	INT8_MAX		__Q8_TI(__Q8_CW)
#define	INT8_MIN		__Q8_BI(__Q8_CW)
#define	UINT8_MAX		__Q8_UI(__Q8_CW)
#endif
#if	__Q8_CW == 16 && defined(__Q8_SC)
#define	INT16_MAX		__Q8_TI(__Q8_CW)
#define	INT16_MIN		__Q8_BI(__Q8_CW)
#define	UINT16_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW == 16
#define	INT16_MAX		__Q8_TI(__Q8_SW)
#define	INT16_MIN		__Q8_BI(__Q8_SW)
#define	UINT16_MAX		__Q8_UI(__Q8_SW)
#endif
#if	__Q8_CW == 32 && defined(__Q8_SC)
#define	INT32_MAX		__Q8_TI(__Q8_CW)
#define	INT32_MIN		__Q8_BI(__Q8_CW)
#define	UINT32_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW == 32
#define	INT32_MAX		__Q8_TI(__Q8_SW)
#define	INT32_MIN		__Q8_BI(__Q8_SW)
#define	UINT32_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW == 32
#define	INT32_MAX		__Q8_TI(__Q8_IW)
#define	INT32_MIN		__Q8_BI(__Q8_IW)
#define	UINT32_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW == 32
#define	INT32_MAX		__Q8_TL
#define	INT32_MIN		__Q8_BL
#define	UINT32_MAX		__Q8_UL
#endif
#if	__Q8_CW == 40 && defined(__Q8_SC)
#define	INT40_MAX		__Q8_TI(__Q8_CW)
#define	INT40_MIN		__Q8_BI(__Q8_CW)
#define	UINT40_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW == 40
#define	INT40_MAX		__Q8_TI(__Q8_SW)
#define	INT40_MIN		__Q8_BI(__Q8_SW)
#define	UINT40_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW == 40
#define	INT40_MAX		__Q8_TI(__Q8_IW)
#define	INT40_MIN		__Q8_BI(__Q8_IW)
#define	UINT40_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW == 40
#define	INT40_MAX		__Q8_TL
#define	INT40_MIN		__Q8_BL
#define	UINT40_MAX		__Q8_UL
#endif
#if	__Q8_CW == 64 && defined(__Q8_SC)
#define	INT64_MAX		__Q8_TI(__Q8_CW)
#define	INT64_MIN		__Q8_BI(__Q8_CW)
#define	UINT64_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW == 64
#define	INT64_MAX		__Q8_TI(__Q8_SW)
#define	INT64_MIN		__Q8_BI(__Q8_SW)
#define	UINT64_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW == 64
#define	INT64_MAX		__Q8_TI(__Q8_IW)
#define	INT64_MIN		__Q8_BI(__Q8_IW)
#define	UINT64_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW == 64
#define	INT64_MAX		__Q8_TL
#define	INT64_MIN		__Q8_BL
#define	UINT64_MAX		__Q8_UL
#elif	__Q8_QW == 64
#define	INT64_MAX		__Q8_TQ
#define	INT64_MIN		__Q8_BQ
#define	UINT64_MAX		__Q8_UQ
#endif

/*
	7.18.2.2	Limits of minimum-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.
*/
#if	__Q8_CW < __Q8_IW && defined(__Q8_SC)
#define	INT_LEAST8_MAX		__Q8_TI(__Q8_CW)
#define	INT_LEAST8_MIN		__Q8_BI(__Q8_CW)
#define	UINT_LEAST8_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW < __Q8_IW
#define	INT_LEAST8_MAX		__Q8_TI(__Q8_SW)
#define	INT_LEAST8_MIN		__Q8_BI(__Q8_SW)
#define	UINT_LEAST8_MAX		__Q8_UI(__Q8_SW)
#else
#define	INT_LEAST8_MAX		__Q8_TI(__Q8_IW)
#define	INT_LEAST8_MIN		__Q8_BI(__Q8_IW)
#define	UINT_LEAST8_MAX		__Q8_UI(__Q8_IW)
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 16 && defined(__Q8_SC)
#define	INT_LEAST16_MAX		__Q8_TI(__Q8_CW)
#define	INT_LEAST16_MIN		__Q8_BI(__Q8_CW)
#define	UINT_LEAST16_MAX	__Q8_UI(__Q8_CW)
#elif	__Q8_SW < __Q8_IW
#define	INT_LEAST16_MAX		__Q8_TI(__Q8_SW)
#define	INT_LEAST16_MIN		__Q8_BI(__Q8_SW)
#define	UINT_LEAST16_MAX	__Q8_UI(__Q8_SW)
#else
#define	INT_LEAST16_MAX		__Q8_TI(__Q8_IW)
#define	INT_LEAST16_MIN		__Q8_BI(__Q8_IW)
#define	UINT_LEAST16_MAX	__Q8_UI(__Q8_IW)
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 32 && defined(__Q8_SC)
#define	INT_LEAST32_MAX		__Q8_TI(__Q8_CW)
#define	INT_LEAST32_MIN		__Q8_BI(__Q8_CW)
#define	UINT_LEAST32_MAX	__Q8_UI(__Q8_CW)
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 32
#define	INT_LEAST32_MAX		__Q8_TI(__Q8_SW)
#define	INT_LEAST32_MIN		__Q8_BI(__Q8_SW)
#define	UINT_LEAST32_MAX	__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= 32
#define	INT_LEAST32_MAX		__Q8_TI(__Q8_IW)
#define	INT_LEAST32_MIN		__Q8_BI(__Q8_IW)
#define	UINT_LEAST32_MAX	__Q8_UI(__Q8_IW)
#else
#define	INT_LEAST32_MAX		__Q8_TL
#define	INT_LEAST32_MIN		__Q8_BL
#define	UINT_LEAST32_MAX	__Q8_UL
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 40 && defined(__Q8_SC)
#define	INT_LEAST40_MAX		__Q8_TI(__Q8_CW)
#define	INT_LEAST40_MIN		__Q8_BI(__Q8_CW)
#define	UINT_LEAST40_MAX	__Q8_UI(__Q8_CW)
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 40
#define	INT_LEAST40_MAX		__Q8_TI(__Q8_SW)
#define	INT_LEAST40_MIN		__Q8_BI(__Q8_SW)
#define	UINT_LEAST40_MAX	__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= 40
#define	INT_LEAST40_MAX		__Q8_TI(__Q8_IW)
#define	INT_LEAST40_MIN		__Q8_BI(__Q8_IW)
#define	UINT_LEAST40_MAX	__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= 40
#define	INT_LEAST40_MAX		__Q8_TL
#define	INT_LEAST40_MIN		__Q8_BL
#define	UINT_LEAST40_MAX	__Q8_UL
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
#define	INT_LEAST40_MAX		__Q8_TQ
#define	INT_LEAST40_MIN		__Q8_BQ
#define	UINT_LEAST40_MAX	__Q8_UQ
#endif
#if	__Q8_CW < __Q8_IW && __Q8_CW >= 64 && defined(__Q8_SC)
#define	INT_LEAST64_MAX		__Q8_TI(__Q8_CW)
#define	INT_LEAST64_MIN		__Q8_BI(__Q8_CW)
#define	UINT_LEAST64_MAX	__Q8_UI(__Q8_CW)
#elif	__Q8_SW < __Q8_IW && __Q8_SW >= 64
#define	INT_LEAST64_MAX		__Q8_TI(__Q8_SW)
#define	INT_LEAST64_MIN		__Q8_BI(__Q8_SW)
#define	UINT_LEAST64_MAX	__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= 64
#define	INT_LEAST64_MAX		__Q8_TI(__Q8_IW)
#define	INT_LEAST64_MIN		__Q8_BI(__Q8_IW)
#define	UINT_LEAST64_MAX	__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= 64
#define	INT_LEAST64_MAX		__Q8_TL
#define	INT_LEAST64_MIN		__Q8_BL
#define	UINT_LEAST64_MAX	__Q8_UL
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
#define	INT_LEAST64_MAX		__Q8_TQ
#define	INT_LEAST64_MIN		__Q8_BQ
#define	UINT_LEAST64_MAX	__Q8_UQ
#endif

/*
	7.18.2.3	Limits of fastest minimum-width integer types

	The optional 40-bit type is supported by the TMS320C6xxx DSP.
*/

#define	INT_FAST8_MAX		__Q8_TI(__Q8_IW)
#define	INT_FAST8_MIN		__Q8_BI(__Q8_IW)
#define	UINT_FAST8_MAX		__Q8_UI(__Q8_IW)
#define	INT_FAST16_MAX		__Q8_TI(__Q8_IW)
#define	INT_FAST16_MIN		__Q8_BI(__Q8_IW)
#define	UINT_FAST16_MAX		__Q8_UI(__Q8_IW)
#if	__Q8_IW >= 32
#define	INT_FAST32_MAX		__Q8_TI(__Q8_IW)
#define	INT_FAST32_MIN		__Q8_BI(__Q8_IW)
#define	UINT_FAST32_MAX		__Q8_UI(__Q8_IW)
#else
#define	INT_FAST32_MAX		__Q8_TL
#define	INT_FAST32_MIN		__Q8_BL
#define	UINT_FAST32_MAX		__Q8_UL
#endif
#if	__Q8_IW >= 40
#define	INT_FAST40_MAX		__Q8_TI(__Q8_IW)
#define	INT_FAST40_MIN		__Q8_BI(__Q8_IW)
#define	UINT_FAST40_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= 40
#define	INT_FAST40_MAX		__Q8_TL
#define	INT_FAST40_MIN		__Q8_BL
#define	UINT_FAST40_MAX		__Q8_UL
#elif	__Q8_QW >= 40			/* (will be 0 if not defined) */
#define	INT_FAST40_MAX		__Q8_TQ
#define	INT_FAST40_MIN		__Q8_BQ
#define	UINT_FAST40_MAX		__Q8_UQ
#endif
#if	__Q8_IW >= 64
#define	INT_FAST64_MAX		__Q8_TI(__Q8_IW)
#define	INT_FAST64_MIN		__Q8_BI(__Q8_IW)
#define	UINT_FAST64_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= 64
#define	INT_FAST64_MAX		__Q8_TL
#define	INT_FAST64_MIN		__Q8_BL
#define	UINT_FAST64_MAX		__Q8_UL
#elif	__Q8_QW >= 64			/* (will be 0 if not defined) */
#define	INT_FAST64_MAX		__Q8_TQ
#define	INT_FAST64_MIN		__Q8_BQ
#define	UINT_FAST64_MAX		__Q8_UQ
#endif

/*
	7.18.2.4	Limits of integer types
				capable of holding object pointers
*/

#if	defined(__Q8_PW)
#if	__Q8_IW >= __Q8_PW
#define	INTPTR_MAX		__Q8_TI(__Q8_IW)
#define	INTPTR_MIN		__Q8_BI(__Q8_IW)
#define	UINTPTR_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= __Q8_PW
#define	INTPTR_MAX		__Q8_TL
#define	INTPTR_MIN		__Q8_BL
#define	UINTPTR_MAX		__Q8_UL
#elif	__Q8_QW >= __Q8_PW
#define	INTPTR_MAX		__Q8_TQ
#define	INTPTR_MIN		__Q8_BQ
#define	UINTPTR_MAX		__Q8_UQ
#elif	__Q8_MW >= __Q8_PW
#define	INTPTR_MAX		__Q8_TM
#define	INTPTR_MIN		__Q8_BM
#define	UINTPTR_MAX		__Q8_UM
#endif
#endif

/*
	7.18.2.5	Limits of greatest-width integer types
*/

#define	INTMAX_MAX		__Q8_TM
#define	INTMAX_MIN		__Q8_BM
#define	UINTMAX_MAX		__Q8_UM

/*
	7.18.3		Limits of other integer types

	XXX --	These ought to be moved into <Q8defs.h> along with
		the corresponding type definitions.
*/

#if	__Q8_CW >= __Q8_DW && defined(__Q8_SC)
#define	PTRDIFF_MAX		__Q8_TI(__Q8_CW)
#define	PTRDIFF_MIN		__Q8_BI(__Q8_CW)
#elif	__Q8_SW >= __Q8_DW
#define	PTRDIFF_MAX		__Q8_TI(__Q8_SW)
#define	PTRDIFF_MIN		__Q8_BI(__Q8_SW)
#elif	__Q8_IW >= __Q8_DW
#define	PTRDIFF_MAX		__Q8_TI(__Q8_IW)
#define	PTRDIFF_MIN		__Q8_BI(__Q8_IW)
#elif	__Q8_LW >= __Q8_DW
#define	PTRDIFF_MAX		__Q8_TL
#define	PTRDIFF_MIN		__Q8_BL
#elif	__Q8_QW >= __Q8_DW
#define	PTRDIFF_MAX		__Q8_TQ
#define	PTRDIFF_MIN		__Q8_BQ
#else
#define	PTRDIFF_MAX		__Q8_TM
#define	PTRDIFF_MIN		__Q8_BM
#endif

#ifdef	__Q8_AU

#if	__Q8_CW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_UL
#elif	__Q8_QW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_UQ
#else
#define	SIG_ATOMIC_MAX		__Q8_UM
#endif

#define	SIG_ATOMIC_MIN		0

#else	/* !defined(__Q8_AU) */

#if	__Q8_CW >= __Q8_AW && defined(__Q8_SC)
#define	SIG_ATOMIC_MAX		__Q8_TI(__Q8_CW)
#define	SIG_ATOMIC_MIN		__Q8_BI(__Q8_CW)
#elif	__Q8_SW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_TI(__Q8_SW)
#define	SIG_ATOMIC_MIN		__Q8_BI(__Q8_SW)
#elif	__Q8_IW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_TI(__Q8_IW)
#define	SIG_ATOMIC_MIN		__Q8_BI(__Q8_IW)
#elif	__Q8_LW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_TL
#define	SIG_ATOMIC_MIN		__Q8_BL
#elif	__Q8_QW >= __Q8_AW
#define	SIG_ATOMIC_MAX		__Q8_TQ
#define	SIG_ATOMIC_MIN		__Q8_BQ
#else
#define	SIG_ATOMIC_MAX		__Q8_TM
#define	SIG_ATOMIC_MIN		__Q8_BM
#endif

#endif	/* defined(__Q8_AU) */

#if	__Q8_CW >= __Q8_ZW
#define	SIZE_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW >= __Q8_ZW
#define	SIZE_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= __Q8_ZW
#define	SIZE_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= __Q8_ZW
#define	SIZE_MAX		__Q8_UL
#elif	__Q8_QW >= __Q8_ZW
#define	SIZE_MAX		__Q8_UQ
#else
#define	SIZE_MAX		__Q8_UM
#endif

#ifdef	__Q8_WU

#if	__Q8_CW >= __Q8_WW
#define	WCHAR_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW >= __Q8_WW
#define	WCHAR_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= __Q8_WW
#define	WCHAR_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= __Q8_WW
#define	WCHAR_MAX		__Q8_UL
#elif	__Q8_QW >= __Q8_WW
#define	WCHAR_MAX		__Q8_UQ
#else
#define	WCHAR_MAX		__Q8_UM
#endif

#define	WCHAR_MIN		0

#else	/* !defined(__Q8_WU) */

#if	__Q8_CW >= __Q8_WW && defined(__Q8_SC)
#define	WCHAR_MAX		__Q8_TI(__Q8_CW)
#define	WCHAR_MIN		__Q8_BI(__Q8_CW)
#elif	__Q8_SW >= __Q8_WW
#define	WCHAR_MAX		__Q8_TI(__Q8_SW)
#define	WCHAR_MIN		__Q8_BI(__Q8_SW)
#elif	__Q8_IW >= __Q8_WW
#define	WCHAR_MAX		__Q8_TI(__Q8_IW)
#define	WCHAR_MIN		__Q8_BI(__Q8_IW)
#elif	__Q8_LW >= __Q8_WW
#define	WCHAR_MAX		__Q8_TL
#define	WCHAR_MIN		__Q8_BL
#elif	__Q8_QW >= __Q8_WW
#define	WCHAR_MAX		__Q8_TQ
#define	WCHAR_MIN		__Q8_BQ
#else
#define	WCHAR_MAX		__Q8_TM
#define	WCHAR_MIN		__Q8_BM
#endif

#endif	/* defined(__Q8_WU) */

#ifdef	__Q8_XU

#if	__Q8_CW >= __Q8_XW
#define	WINT_MAX		__Q8_UI(__Q8_CW)
#elif	__Q8_SW >= __Q8_XW
#define	WINT_MAX		__Q8_UI(__Q8_SW)
#elif	__Q8_IW >= __Q8_XW
#define	WINT_MAX		__Q8_UI(__Q8_IW)
#elif	__Q8_LW >= __Q8_XW
#define	WINT_MAX		__Q8_UL
#elif	__Q8_QW >= __Q8_XW
#define	WINT_MAX		__Q8_UQ
#else
#define	WINT_MAX		__Q8_UM
#endif

#define	WINT_MIN		0

#else	/* !defined(__Q8_XU) */

#if	__Q8_CW >= __Q8_XW && defined(__Q8_SC)
#define	WINT_MAX		__Q8_TI(__Q8_CW)
#define	WINT_MIN		__Q8_BI(__Q8_CW)
#elif	__Q8_SW >= __Q8_XW
#define	WINT_MAX		__Q8_TI(__Q8_SW)
#define	WINT_MIN		__Q8_BI(__Q8_SW)
#elif	__Q8_IW >= __Q8_XW
#define	WINT_MAX		__Q8_TI(__Q8_IW)
#define	WINT_MIN		__Q8_BI(__Q8_IW)
#elif	__Q8_LW >= __Q8_XW
#define	WINT_MAX		__Q8_TL
#define	WINT_MIN		__Q8_BL
#elif	__Q8_QW >= __Q8_XW
#define	WINT_MAX		__Q8_TQ
#define	WINT_MIN		__Q8_BQ
#else
#define	WINT_MAX		__Q8_TM
#define	WINT_MIN		__Q8_BM
#endif

#endif	/* defined(__Q8_XU) */

#endif	/* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */

#if	!defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)

/*
	7.18.4.1	Macros for minimum-width integer constants

	The optional 40-bit type is supported by the TMS320C6xxx DSP.

	This spec was changed in ISO/IEC 9899:1999 TC1; in ISO/IEC
	9899:1999 as initially published, the expansion was required
	to be an integer constant of precisely matching type, which
	is impossible to accomplish for the shorter types on most
	platforms, because C99 provides no standard way to designate
	an integer constant with width less than that of type int.
	TC1 changed this to require just an integer constant
	*expression* with *promoted* type.

	The trick used to get the right type is due to Clive Feather.
*/

#define	INT8_C(c)	(INT_LEAST8_MAX-INT_LEAST8_MAX+(c))
#define	UINT8_C(c)	(UINT_LEAST8_MAX-UINT_LEAST8_MAX+(c))
#define	INT16_C(c)	(INT_LEAST16_MAX-INT_LEAST16_MAX+(c))
#define	UINT16_C(c)	(UINT_LEAST16_MAX-UINT_LEAST16_MAX+(c))
#define	INT32_C(c)	(INT_LEAST32_MAX-INT_LEAST32_MAX+(c))
#define	UINT32_C(c)	(UINT_LEAST32_MAX-UINT_LEAST32_MAX+(c))
#ifdef	INT_LEAST40_MAX
#define	INT40_C(c)	(INT_LEAST40_MAX-INT_LEAST40_MAX+(c))
#define	UINT40_C(c)	(UINT_LEAST40_MAX-UINT_LEAST40_MAX+(c))
#endif
#ifdef	INT_LEAST64_MAX
#define	INT64_C(c)	(INT_LEAST64_MAX-INT_LEAST64_MAX+(c))
#define	UINT64_C(c)	(UINT_LEAST64_MAX-UINT_LEAST64_MAX+(c))
#endif

/*
	7.18.4.2	Macros for greatest-width integer constants
*/

#define	INTMAX_C(c)	(INTMAX_MAX-INTMAX_MAX+(c))
#define	UINTMAX_C(c)	(UINTMAX_MAX-UINTMAX_MAX+(c))

#endif	/* !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) */
END OF stdint.h
echo 'wchar.h' 1>&2
cat >'wchar.h' <<'END OF wchar.h'
/*
	wchar.h -- extended multibyte and wide character utilities

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclause 7.24 of ISO/IEC 9899:1999 (E).

	Unfortunately, it is NOT QUITE CONFORMING, because it #includes
	<stddef.h> to obtain the definitions for wchar_t and size_t,
	<stdint.h> for WCHAR_MIN and WCHAR_MAX, <stdio.h> for FILE, and
	<time.h> for struct tm.  If you plan to include this header in
	a conforming C implementation, you must fix this.  (FILE should
	*not* be defined by this header, although it is needed in the
	declarations!)
*/

#if	!defined(_WCHAR_H) && !defined(_INC_WCHAR)	/* usual lock names */
#define	_WCHAR_H			/* idempotency lock (section 7.1.2) */
#define	_INC_WCHAR

#include	<stddef.h>		/* XXX -- for wchar_t and size_t */
#include	<stdio.h>		/* XXX -- for FILE (def of __Q8_FILE) */
#include	<time.h>		/* XXX -- for struct tm */

#include	<Q8defs.h>		/* defines the __Q8_* symbols */
#include	<stdint.h>		/* XXX -- for WCHAR_MIN and WCHAR_MAX */

#ifdef	__cplusplus
extern	"C"	{
#endif

/*
	7.24.1	Introduction
*/

#ifndef	__Q8_MBSTATE_T_DEFINED
#define	__Q8_MBSTATE_T_DEFINED		/* idempotency lock */
typedef __Q8_MBSTATE_T	mbstate_t;
#endif
#ifndef	__Q8_SIZE_T_DEFINED
#define	__Q8_SIZE_T_DEFINED		/* idempotency lock */
/* typedef __Q8_SIZE_T	size_t;		/* XXX -- conflicts with native hdrs */
#endif
#ifndef	__Q8_STRUCT_TM_DEFINED
#define	__Q8_STRUCT_TM_DEFINED	/* idempotency lock */
/* XXX -- need to work on this */
#endif
#ifndef	__Q8_WCHAR_T_DEFINED
#define	__Q8_WCHAR_T_DEFINED		/* idempotency lock */
/* typedef __Q8_WCHAR_T	wchar_t;	/* XXX -- conflicts with native hdrs */
#endif
#ifndef	__Q8_WINT_T_DEFINED
#define	__Q8_WINT_T_DEFINED		/* idempotency lock */
typedef __Q8_WINT_T	wint_t;
#endif

#ifndef	NULL				/* to protect against native defs */
#define	NULL		__Q8_NULL
#endif

#if 0	/* XXX -- these __Q8_* symbols are not yet defined */
#ifndef	WCHAR_MAX			/* to protect against native defs */
#define	WCHAR_MAX	__Q8_WCHAR_MAX
#endif

#ifndef	WCHAR_MIN			/* to protect against native defs */
#define	WCHAR_MIN	__Q8_WCHAR_MIN
#endif
#endif	/* XXX */

#ifndef	WEOF				/* to protect against native defs */
#define	WEOF		__Q8_WEOF
#endif

/*
	7.24.2	Formatted wide character input/output functions
*/

extern int	fwprintf __Q8_PARAMS((__Q8_FILE * __Q8_RESTRICT __stream,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format, ...));
extern int	fwscanf __Q8_PARAMS((__Q8_FILE * __Q8_RESTRICT __stream,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format, ...));
extern int	swprintf __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s, size_t __n,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format, ...));
extern int	swscanf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __s,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format, ...));
extern int	vfwprintf __Q8_PARAMS((__Q8_FILE * __Q8_RESTRICT __stream,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format,
			__va_list __arg));
extern int	vfwscanf __Q8_PARAMS((__Q8_FILE * __Q8_RESTRICT __stream,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format,
			__va_list __arg));
extern int	vswprintf __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s, size_t __n,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format,
			__va_list __arg));
extern int	vswscanf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __s,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format,
			__va_list __arg));
extern int	vwprintf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT
			__format, __va_list __arg));
extern int	vwscanf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT
			__format, __va_list __arg));
extern int	wprintf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT
			__format, ...));
extern int	wscanf __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT
			__format, ...));

/*
	7.24.3	Wide character input/output functions
*/

extern wint_t	fgetwc __Q8_PARAMS((__Q8_FILE * __stream));
extern wchar_t	*fgetws __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s, int __n,
			__Q8_FILE * __Q8_RESTRICT __stream));
extern wint_t	fputwc __Q8_PARAMS((wchar_t __c, __Q8_FILE * __stream));
extern int	fputws __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s,
			__Q8_FILE * __Q8_RESTRICT __stream));
extern int	fwide __Q8_PARAMS((__Q8_FILE * __stream, int __mode));
extern wint_t	getwc __Q8_PARAMS((__Q8_FILE * __stream));
extern wint_t	getwchar __Q8_PARAMS((void));
extern wint_t	putwc __Q8_PARAMS((wchar_t __c, __Q8_FILE * __stream));
extern wint_t	putwchar __Q8_PARAMS((wchar_t __c));
extern wint_t	ungetwc __Q8_PARAMS((wint_t __c, __Q8_FILE * __stream));

/*
	7.24.4	General wide string utilities
*/

extern double	wcstod __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr));
extern float	wcstof __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr));
#ifdef	__Q8_GT
extern __Q8_GT
		wcstold __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr));
#endif
extern long	wcstol __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr, int __base));
extern unsigned long
		wcstoul __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr, int __base));
#ifdef	__Q8_QT
extern __Q8_QT
		wcstoll __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr, int __base));
extern unsigned __Q8_QT
		wcstoull __Q8_PARAMS((__Q8_CONST wchar_t * __Q8_RESTRICT __nptr,
			wchar_t ** __Q8_RESTRICT __endptr, int __base));
#endif
extern wchar_t *wcscpy __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2));
extern wchar_t *wcsncpy __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2, size_t __n));
extern wchar_t *wmemcpy __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2, size_t __n));
extern wchar_t *wmemmove __Q8_PARAMS((wchar_t * __s1, __Q8_CONST wchar_t * __s2,
			size_t __n));
extern wchar_t *wcscat __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2));
extern wchar_t *wcsncat __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2, size_t __n));
extern int	wcscmp __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern int	wcscoll __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern int	wcsncmp __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2, size_t __n));
extern size_t	wcsxfrm __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2, size_t __n));
extern int	wmemcmp __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2, size_t __n));
extern wchar_t *wcschr __Q8_PARAMS((__Q8_CONST wchar_t * __s, wchar_t __c));
extern size_t	wcscspn __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern wchar_t *wcspbrk __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern wchar_t *wcsrchr __Q8_PARAMS((__Q8_CONST wchar_t * __s, wchar_t __c));
extern size_t	wcsspn __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern wchar_t *wcsstr __Q8_PARAMS((__Q8_CONST wchar_t * __s1,
			__Q8_CONST wchar_t * __s2));
extern wchar_t *wcstok __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s1,
			__Q8_CONST wchar_t * __Q8_RESTRICT __s2,
			wchar_t ** __Q8_RESTRICT __ptr));
extern wchar_t *wmemchr __Q8_PARAMS((__Q8_CONST wchar_t * __s, wchar_t __c,
			size_t __n));
extern size_t	wcslen __Q8_PARAMS((__Q8_CONST wchar_t * __s));
extern wchar_t *wmemset __Q8_PARAMS((wchar_t * __s, wchar_t __c, size_t __n));

/*
	7.24.5	Wide character time conversion functions
*/

extern size_t	wcsftime __Q8_PARAMS((wchar_t * __Q8_RESTRICT __s,
			size_t __maxsize,
			__Q8_CONST wchar_t * __Q8_RESTRICT __format,
			__Q8_CONST struct tm * __Q8_RESTRICT __timeptr));

/*
	7.24.6	Extended multibyte/wide character conversion utilities
*/

extern wint_t	btowc __Q8_PARAMS((int __c));
extern int	wctob __Q8_PARAMS((wint_t __c));
extern int	mbsinit __Q8_PARAMS((__Q8_CONST mbstate_t *__ps));
extern size_t	mbrlen __Q8_PARAMS((__Q8_CONST char * __Q8_RESTRICT __s,
			size_t __n, mbstate_t * __Q8_RESTRICT __ps));
extern size_t	mbrtowc __Q8_PARAMS((wchar_t * __Q8_RESTRICT __pwc,
			__Q8_CONST char * __Q8_RESTRICT __s, size_t __n,
			mbstate_t * __Q8_RESTRICT __ps));
extern size_t	wcrtomb __Q8_PARAMS((char * __Q8_RESTRICT __s, wchar_t __wc,
			mbstate_t * __Q8_RESTRICT __ps));
extern size_t	mbsrtowcs __Q8_PARAMS((wchar_t * __Q8_RESTRICT __dst,
			__Q8_CONST char ** __Q8_RESTRICT __src, size_t __len,
			mbstate_t * __Q8_RESTRICT __ps));
extern size_t	wcsrtombs __Q8_PARAMS((char * __Q8_RESTRICT __dst,
			__Q8_CONST wchar_t ** __Q8_RESTRICT __src, size_t __len,
			mbstate_t * __Q8_RESTRICT __ps));

#ifdef	__cplusplus
		}
#endif

#endif	/* !defined(_WCHAR_H) && !defined(_INC_WCHAR) */
END OF wchar.h
echo 'wctype.h' 1>&2
cat >'wctype.h' <<'END OF wctype.h'
/*
	wctype.h -- wide character classification and mapping utilities

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclause 7.25 of ISO/IEC 9899:1999 (E).
*/

#if	!defined(_WCTYPE_H) && !defined(_INC_WCTYPE)	/* usual lock names */
#define	_WCTYPE_H			/* idempotency lock (section 7.1.2) */
#define	_INC_WCTYPE

#include	<Q8defs.h>		/* defines the __Q8_* symbols */

#ifdef	__cplusplus
extern	"C"	{
#endif

/*
	7.25.1	Introduction
*/

#ifndef	__Q8_WINT_T_DEFINED
#define	__Q8_WINT_T_DEFINED		/* idempotency lock */
typedef __Q8_WINT_T	wint_t;
#endif
#ifndef	__Q8_WCTRANS_T_DEFINED
#define	__Q8_WCTRANS_T_DEFINED		/* idempotency lock */
typedef unsigned int	wctrans_t;	/* this type works nearly everywhere */
#endif
#ifndef	__Q8_WCTYPE_T_DEFINED
#define	__Q8_WCTYPE_T_DEFINED		/* idempotency lock */
typedef int		wctype_t;	/* this type works nearly everywhere */
#endif

#ifndef	WEOF				/* to protect against native defs */
#define	WEOF		__Q8_WEOF
#endif

/*
	7.25.2	Wide character classification utilities
*/

extern int	iswalnum __Q8_PARAMS((wint_t __wc));
extern int	iswalpha __Q8_PARAMS((wint_t __wc));
extern int	iswblank __Q8_PARAMS((wint_t __wc));
extern int	iswcntrl __Q8_PARAMS((wint_t __wc));
extern int	iswdigit __Q8_PARAMS((wint_t __wc));
extern int	iswgraph __Q8_PARAMS((wint_t __wc));
extern int	iswlower __Q8_PARAMS((wint_t __wc));
extern int	iswprint __Q8_PARAMS((wint_t __wc));
extern int	iswpunct __Q8_PARAMS((wint_t __wc));
extern int	iswspace __Q8_PARAMS((wint_t __wc));
extern int	iswupper __Q8_PARAMS((wint_t __wc));
extern int	iswxdigit __Q8_PARAMS((wint_t __wc));
extern int	iswctype __Q8_PARAMS((wint_t __wc, wctype_t __desc));
extern wctype_t	wctype __Q8_PARAMS((__Q8_CONST char *__property));

/*
	7.25.3	Wide character case mapping utilities
*/

extern wint_t	towlower __Q8_PARAMS((wint_t __wc));
extern wint_t	towupper __Q8_PARAMS((wint_t __wc));
extern wint_t	towctrans __Q8_PARAMS((wint_t __wc, wctrans_t __desc));
extern wctrans_t
		wctrans __Q8_PARAMS((__Q8_CONST char *__property));

#ifdef	__cplusplus
		}
#endif

#endif	/* !defined(_WCTYPE_H) && !defined(_INC_WCTYPE) */
END OF wctype.h
echo 'inttypes.c' 1>&2
cat >'inttypes.c' <<'END OF inttypes.c'
/*
	inttypes -- format conversion of integer types
			(standard library functions declared by <inttypes.h>)

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.8.2 of ISO/IEC 9899:1999 (E).

	This particular implementation requires the matching <inttypes.h>.
	It also assumes that character codes for A..Z and a..z are in
	contiguous ascending order; this is true for ASCII but not EBCDIC.
*/

#include	<ctype.h>
#include	<errno.h>
#include	<stdlib.h>

#include	<stdbool.h>
#include	<inttypes.h>		/* defines various __Q8_* symbols */
#include	<wchar.h>
#include	<wctype.h>

/*	helper macros:	*/

/* convert digit character to number, in any base */
#define ToNumber(c)	(isdigit(c) ? (c) - '0' : \
			 isupper(c) ? (c) - 'A' + 10 : \
			 islower(c) ? (c) - 'a' + 10 : \
			 -1		/* "invalid" flag */ \
			)
#define ToWNumber(c)	(iswdigit(c) ? (c) - L'0' : \
			 iswupper(c) ? (c) - L'A' + 10 : \
			 iswlower(c) ? (c) - L'a' + 10 : \
			 -1		/* "invalid" flag */ \
			)

/* validate converted digit character for specific base */
#define valid(n, b)	((n) >= 0 && (n) < (b))

/*
	7.8.2	Functions for greatest-width integer types
*/

intmax_t
imaxabs(j)
	intmax_t	j;
	{
	return	j >= 0 ? j : -j;
	}

imaxdiv_t
imaxdiv(numer, denom)
	intmax_t	numer, denom;
	{
	imaxdiv_t	result;

	result.quot = numer / denom;
	result.rem = numer % denom;
	return result;
	}

intmax_t
strtoimax(nptr, endptr, base)
	register __Q8_CONST char *__Q8_RESTRICT	nptr;
	char **__Q8_RESTRICT			endptr;
	register int				base;
	{
	register uintmax_t	accum;	/* accumulates converted value */
	register int		n;	/* numeral from digit character */
	bool			minus;	/* set iff minus sign seen */
	bool			toobig;	/* set iff value overflows */

	if ( endptr != NULL )
		*endptr = (char *)nptr;	/* in case no conversion's performed */

	if ( base < 0 || base == 1 || base > 36 )
		{
		errno = EDOM;
		return 0;		/* unspecified behavior */
		}

	/* skip initial, possibly empty sequence of white-space characters */

	while ( isspace(*nptr) )
		++nptr;

	/* process subject sequence: */

	/* optional sign */
	if ( (minus = *nptr == '-') || *nptr == '+' )
		++nptr;

	if ( base == 0 )
		if ( *nptr == '0' )
			if ( nptr[1] == 'X' || nptr[1] == 'x' )
				base = 16;
			else
				base = 8;
		else
				base = 10;

	/* optional "0x" or "0X" for base 16 */

	if ( base == 16 && *nptr == '0' && (nptr[1] == 'X' || nptr[1] == 'x') )
		nptr += 2;		/* skip past this prefix */

	/* check whether there is at least one valid digit */

	n = ToNumber(*nptr);
	++nptr;

	if ( !valid(n, base) )
		return 0;		/* subject seq. not of expected form */

	accum = n;

	for ( toobig = false; n = ToNumber(*nptr), valid(n, base); ++nptr )
		if ( accum > INTMAX_MAX / base + 2 )	/* major wrap-around */
			toobig = true;	/* but keep scanning */
		else
			accum = base * accum + n;

	if ( endptr != NULL )
		*endptr = (char *)nptr;	/* points to first not-valid-digit */

#ifdef	__Q8_TC				/* twos-complement representation */
	if ( minus )
		{
		if ( accum > (uintmax_t)INTMAX_MAX + 1 )
			toobig = true;
		}
	else
#endif
	if ( accum > (uintmax_t)INTMAX_MAX )
		toobig = true;

	if ( toobig )
		{
		errno = ERANGE;
		return minus ? INTMAX_MIN : INTMAX_MAX;
		}
	else
		return (intmax_t)(minus ? -accum : accum);
	}

uintmax_t
strtoumax(nptr, endptr, base)
	register __Q8_CONST char *__Q8_RESTRICT	nptr;
	char **__Q8_RESTRICT			endptr;
	register int				base;
	{
	register uintmax_t	accum;	/* accumulates converted value */
	register uintmax_t	next;	/* for computing next value of accum */
	register int		n;	/* numeral from digit character */
	bool			minus;	/* set iff minus sign seen (yes!) */
	bool			toobig;	/* set iff value overflows */

	if ( endptr != NULL )
		*endptr = (char *)nptr;	/* in case no conversion's performed */

	if ( base < 0 || base == 1 || base > 36 )
		{
		errno = EDOM;
		return 0;		/* unspecified behavior */
		}

	/* skip initial, possibly empty sequence of white-space characters */

	while ( isspace(*nptr) )
		++nptr;

	/* process subject sequence: */

	/* optional sign (yes!) */

	if ( (minus = *nptr == '-') || *nptr == '+' )
		++nptr;

	if ( base == 0 )
		if ( *nptr == '0' )
			if ( nptr[1] == 'X' || nptr[1] == 'x' )
				base = 16;
			else
				base = 8;
		else
				base = 10;

	/* optional "0x" or "0X" for base 16 */

	if ( base == 16 && *nptr == '0' && (nptr[1] == 'X' || nptr[1] == 'x') )
		nptr += 2;		/* skip past this prefix */

	/* check whether there is at least one valid digit */

	n = ToNumber(*nptr);
	++nptr;

	if ( !valid(n, base) )
		return 0;		/* subject seq. not of expected form */

	accum = n;

	for ( toobig = false; n = ToNumber(*nptr), valid(n, base); ++nptr )
		if ( accum > UINTMAX_MAX / base + 1	/* major wrap-around */
		  || (next = base * accum + n) < accum	/* minor wrap-around */
		   )
			toobig = true;	/* but keep scanning */
		else
			accum = next;

	if ( endptr != NULL )
		*endptr = (char *)nptr;	/* points to first not-valid-digit */

	if ( toobig )
		{
		errno = ERANGE;
		return UINTMAX_MAX;
		}
	else
		return minus ? -accum : accum;	/* (yes!) */
	}

intmax_t
wcstoimax(nptr, endptr, base)
	register __Q8_CONST wchar_t *__Q8_RESTRICT	nptr;
	wchar_t **__Q8_RESTRICT				endptr;
	register int					base;
	{
	register uintmax_t	accum;	/* accumulates converted value */
	register int		n;	/* numeral from digit character */
	bool			minus;	/* set iff minus sign seen */
	bool			toobig;	/* set iff value overflows */

	if ( endptr != NULL )
		*endptr = (wchar_t *)nptr;	/* in case no conv performed */

	if ( base < 0 || base == 1 || base > 36 )
		{
		errno = EDOM;
		return 0;		/* unspecified behavior */
		}

	/* skip initial, possibly empty sequence of white-space w.characters */

	while ( iswspace(*nptr) )
		++nptr;

	/* process subject sequence: */

	/* optional sign */

	if ( (minus = *nptr == L'-') || *nptr == L'+' )
		++nptr;

	if ( base == 0 )
		if ( *nptr == L'0' )
			if ( nptr[1] == L'X' || nptr[1] == L'x' )
				base = 16;
			else
				base = 8;
		else
				base = 10;

	/* optional "0x" or "0X" for base 16 */

	if ( base == 16 && *nptr == L'0'
	  && (nptr[1] == L'X' || nptr[1] == L'x')
	   )
		nptr += 2;		/* skip past this prefix */

	/* check whether there is at least one valid digit */

	n = ToWNumber(*nptr);
	++nptr;

	if ( !valid(n, base) )
		return 0;		/* subject seq. not of expected form */

	accum = n;

	for ( toobig = false; n = ToWNumber(*nptr), valid(n, base); ++nptr )
		if ( accum > INTMAX_MAX / base + 2 )	/* major wrap-around */
			toobig = true;	/* but keep scanning */
		else
			accum = base * accum + n;

	if ( endptr != NULL )
		*endptr = (wchar_t *)nptr;	/* -> first not-valid-digit */

#ifdef	__Q8_TC				/* twos-complement representation */
	if ( minus )
		{
		if ( accum > (uintmax_t)INTMAX_MAX + 1 )
			toobig = true;
		}
	else
#endif
	if ( accum > (uintmax_t)INTMAX_MAX )
		toobig = true;

	if ( toobig )
		{
		errno = ERANGE;
		return minus ? INTMAX_MIN : INTMAX_MAX;
		}
	else
		return (intmax_t)(minus ? -accum : accum);
	}

uintmax_t
wcstoumax(nptr, endptr, base)
	register __Q8_CONST wchar_t *__Q8_RESTRICT	nptr;
	wchar_t **__Q8_RESTRICT				endptr;
	register int					base;
	{
	register uintmax_t	accum;	/* accumulates converted value */
	register uintmax_t	next;	/* for computing next value of accum */
	register int		n;	/* numeral from digit character */
	bool			minus;	/* set iff minus sign seen (yes!) */
	bool			toobig;	/* set iff value overflows */

	if ( endptr != NULL )
		*endptr = (wchar_t *)nptr;	/* in case no conv performed */

	if ( base < 0 || base == 1 || base > 36 )
		{
		errno = EDOM;
		return 0;		/* unspecified behavior */
		}

	/* skip initial, possibly empty sequence of white-space w.characters */

	while ( iswspace(*nptr) )
		++nptr;

	/* process subject sequence: */

	/* optional sign */

	if ( (minus = *nptr == L'-') || *nptr == L'+' )
		++nptr;

	if ( base == 0 )
		if ( *nptr == L'0' )
			if ( nptr[1] == L'X' || nptr[1] == L'x' )
				base = 16;
			else
				base = 8;
		else
				base = 10;

	/* optional "0x" or "0X" for base 16 */

	if ( base == 16 && *nptr == L'0'
	  && (nptr[1] == L'X' || nptr[1] == L'x')
	   )
		nptr += 2;		/* skip past this prefix */

	/* check whether there is at least one valid digit */

	n = ToWNumber(*nptr);
	++nptr;

	if ( !valid(n, base) )
		return 0;		/* subject seq. not of expected form */

	accum = n;

	for ( toobig = false; n = ToWNumber(*nptr), valid(n, base); ++nptr )
		if ( accum > UINTMAX_MAX / base + 1	/* major wrap-around */
		  || (next = base * accum + n) < accum	/* minor wrap-around */
		   )
			toobig = true;	/* but keep scanning */
		else
			accum = next;

	if ( endptr != NULL )
		*endptr = (wchar_t *)nptr;	/* -> first not-valid-digit */

	if ( toobig )
		{
		errno = ERANGE;
		return UINTMAX_MAX;
		}
	else
		return minus ? -accum : accum;	/* (yes!) */
	}
END OF inttypes.c
echo 'locale.c' 1>&2
cat >'locale.c' <<'END OF locale.c'
/*
	localeconv() -- numeric formatting convention inquiry
	setlocale() -- locale control function

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclauses 7.11.1.1 & 7.11.2.1 of ISO/IEC 9899:1999 (E).

	This is a minimal implementation for environments where
	internationalization is not considered important.

	XXX -- UNTESTED -- XXX
*/

#include	<limits.h>		/* for CHAR_MAX */

#include	<locale.h>

static char	empty[] = "";

static struct lconv	c_lconv =	/* lconv for "C" locale */
	{
	/* WARNING: The following order must match the header! */
	".",				/* decimal_point */
	empty,				/* thousands_sep */
	empty,				/* grouping */
	empty,				/* int_curr_symbol */
	empty,				/* currency_symbol */
	empty,				/* mon_decimal_point */
	empty,				/* mon_thousands_sep */
	empty,				/* mon_grouping */
	empty,				/* positive_sign */
	empty,				/* negative_sign */
	CHAR_MAX,			/* int_frac_digits */
	CHAR_MAX,			/* frac_digits */
	CHAR_MAX,			/* p_cs_precedes */
	CHAR_MAX,			/* p_sep_by_space */
	CHAR_MAX,			/* n_cs_precedes */
	CHAR_MAX,			/* n_sep_by_space */
	CHAR_MAX,			/* p_sign_posn */
	CHAR_MAX,			/* n_sign_posn */
	CHAR_MAX,			/* int_p_cs_precedes */
	CHAR_MAX,			/* int_p_sep_by_space */
	CHAR_MAX,			/* int_n_cs_precedes */
	CHAR_MAX,			/* int_n_sep_by_space */
	CHAR_MAX,			/* int_p_sign_posn */
	CHAR_MAX,			/* int_n_sign_posn */
	};

struct lconv *
localeconv()
	{
	return &c_lconv;
	}

char *
setlocale(category, locale)
	int		category;
	const char	*locale;
	{
	switch ( category )
		{
	case LC_ALL:
	case LC_COLLATE:
	case LC_CTYPE:
	case LC_MONETARY:
	case LC_NUMERIC:
	case LC_TIME:
		return empty;		/* native "" == "C" == "POSIX" */
		/* The string doesn't have to be the same as the argument. */

	default:
		return NULL;		/* unsupported category */
		}
	}
END OF locale.c
echo 'signal.c' 1>&2
cat >'signal.c' <<'END OF signal.c'
/*
	signal -- specify signal handling
	raise -- send signal

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/08/20	gwyn@arl.mil

	Implements subclauses 7.14.1 & 7.14.2 of ISO/IEC 9899:1999 (E).

	These are minimally functional versions, solely for systems that don't
	already provide signal() (such as the TMS320C6xxx DSP's compiler).

	XXX -- UNTESTED -- XXX
*/

#include	<errno.h>
#include	<stdlib.h>		/* for abort() */

#include	<Q8defs.h>		/* for __Q8_PARAMS */
#include	<signal.h>
#include	<stdbool.h>

#define	NSIG	(SIGTERM+1)		/* max. supported signal number + 1 */

static void	(*handler[NSIG])__Q8_PARAMS((int));	/* current handlers */

static bool	inited = false;		/* for initializing above */

/* dummy functions for unique address */
void	__sig_err(sig) int sig; { }
void	__sig_ign(sig) int sig; { }

/*
	7.14.1 -- specify signal handling
*/

void	(*
signal(sig, func)
	)__Q8_PARAMS((int))		/* returns previous handler */
	register int	sig;
	void		(*func)__Q8_PARAMS((int));
	{
	register void	(*retval)__Q8_PARAMS((int));	/* previous handler */

	if ( sig <= 0 || sig >= NSIG )	/* safety check */
		{
		errno = EDOM;
		return SIG_ERR;
		}

	/* C language provides no good way to initialize handler[] */
	if ( !inited )			/* once only */
		{
		register int	i;

		for ( i = 0; i < NSIG; ++i )
			handler[i] = SIG_DFL;	/* initialize */

		inited = true;
		}

	retval = handler[sig - 1];	/* previous state */
	handler[sig - 1] = func;	/* new state */

	return retval;			/* previous handler */
	}

/*
	7.14.2 -- send signal
*/

int
raise(sig)
	int		sig;
	{
	register void	(*func)__Q8_PARAMS((int));	/* handler value */

	if ( sig <= 0 || sig >= NSIG )	/* safety check */
		{
		errno = EDOM;
		return 1;		/* indicate failure */
		}

	func = handler[sig - 1];

	if ( func == SIG_IGN )
		return 0;		/* indicate success */

	if ( func == SIG_DFL )
		{
		abort();		/* (an arbitrary decision) */
		return 1;		/* just in case, indicate failure */
		}

	handler[sig - 1] = SIG_DFL;	/* classic UNIX behavior */
	(*func)(sig);

	return 0;			/* indicate success */
	}
END OF signal.c
echo 'sitest.c' 1>&2
cat >'sitest.c' <<'END OF sitest.c'
/*
	sitest -- exercise features of C99 <stdint.h> and <inttypes.h>

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Tries to accommodate pre-C99 versions of <inttypes.h>.

	Takes advantage of __Q8_* symbols defined by a particular
	implementation of <stdint.h>, but doesn't require them.

	NOTE:	This is not a thorough validation test of the facilities.
*/

#include	<errno.h>
#include	<limits.h>		/* for CHAR_BIT */
#include	<stdio.h>
#include	<stddef.h>		/* for ptrdiff_t */
#include	<stdlib.h>
#include	<string.h>

#include	<inttypes.h>		/* embeds <stdint.h> */
#include	<signal.h>		/* for sig_atomic_t */
#if	defined(INTMAX_MAX)		/* <inttypes.h> has C99 features */
#include	<wchar.h>
#endif

#include	<inttypes.h>		/* test idempotency */

#if	__STDC_VERSION__ >= 199901
#ifndef	__Q8_QT
#define	__Q8_QT	long long
#endif
#endif

#ifdef	PRIdMAX
#define	HAVE_PRIdMAX
#ifndef	__Q8_MT
#define	__Q8_MT	intmax_t
#endif
#else
#ifdef	PRIdLEAST64
#ifndef	__Q8_MT
#define	__Q8_MT	int_least64_t
#endif
#define	PRIdMAX	PRIdLEAST64
#else
#ifndef	__Q8_MT
#define	__Q8_MT	long
#endif
#define	PRIdMAX	"ld"
#endif
#endif

#ifdef	PRIuMAX
#define	HAVE_PRIuMAX
#define	U__Q8_MT	uintmax_t
#else
#ifdef	PRIuLEAST64
#define	U__Q8_MT	uint_least64_t
#define	PRIuMAX	PRIuLEAST64
#else
#define	U__Q8_MT	unsigned long
#define	PRIuMAX	"lu"
#endif
#endif

#define	STR_SUB(s)	# s
#define	STRINGIZE(s)	STR_SUB(s)	/* extra level to expand argument */

#if	defined(SCNo32) || defined(PRIo32)
static int32_t		int32;
#endif
static int_least16_t	intl16;
static uint_least16_t	uintl16;
static uint_fast16_t	uintf16;
static intmax_t		intmax;
static uintmax_t	uintmax;

int
main()	{
	int	status = 0;		/* exit status to be returned */

	/* <stdint.h> features: */

	printf("CHAR_BIT=%u\n", (unsigned)CHAR_BIT );
	printf("sizeof(char)=%u\n", (unsigned)sizeof(char));	/* s.b. 1 */
	printf("sizeof(short)=%u\n", (unsigned)sizeof(short));
	printf("sizeof(int)=%u\n", (unsigned)sizeof(int));
	printf("sizeof(long)=%u\n", (unsigned)sizeof(long));
#ifdef	__Q8_QT
	printf("sizeof(long long)=%u\n", (unsigned)sizeof(__Q8_QT));
#endif
	printf("sizeof(intmax_t)=%u\n", (unsigned)sizeof(intmax_t));
	printf("sizeof(ptrdiff_t)=%u\n", (unsigned)sizeof(ptrdiff_t));
	printf("sizeof(size_t)=%u\n", (unsigned)sizeof(size_t));
	printf("sizeof(sig_atomic_t)=%u\n", (unsigned)sizeof(sig_atomic_t));
	printf("sizeof(wchar_t)=%u\n", (unsigned)sizeof(wchar_t));
#if	defined(WINT_MAX) || __STDC_VERSION__ >= 199901
	printf("sizeof(wint_t)=%u\n", (unsigned)sizeof(wint_t));
#else
	printf("*** wint_t isn't defined ***\n");
	status = EXIT_FAILURE;
#endif
#ifdef	INT8_MAX
	printf("sizeof(int8_t)=%u\n", (unsigned)sizeof(int8_t));
	printf("sizeof(uint8_t)=%u\n", (unsigned)sizeof(uint8_t));
#endif
#ifdef	INT9_MAX
	printf("sizeof(int9_t)=%u\n", (unsigned)sizeof(int9_t));
	printf("sizeof(uint9_t)=%u\n", (unsigned)sizeof(uint9_t));
#endif
#ifdef	INT12_MAX
	printf("sizeof(int12_t)=%u\n", (unsigned)sizeof(int12_t));
	printf("sizeof(uint12_t)=%u\n", (unsigned)sizeof(uint12_t));
#endif
#ifdef	INT16_MAX
	printf("sizeof(int16_t)=%u\n", (unsigned)sizeof(int16_t));
	printf("sizeof(uint16_t)=%u\n", (unsigned)sizeof(uint16_t));
#endif
#ifdef	INT18_MAX
	printf("sizeof(int18_t)=%u\n", (unsigned)sizeof(int18_t));
	printf("sizeof(uint18_t)=%u\n", (unsigned)sizeof(uint18_t));
#endif
#ifdef	INT24_MAX
	printf("sizeof(int24_t)=%u\n", (unsigned)sizeof(int24_t));
	printf("sizeof(uint24_t)=%u\n", (unsigned)sizeof(uint24_t));
#endif
#ifdef	INT32_MAX
	printf("sizeof(int32_t)=%u\n", (unsigned)sizeof(int32_t));
	printf("sizeof(uint32_t)=%u\n", (unsigned)sizeof(uint32_t));
#endif
#ifdef	INT36_MAX
	printf("sizeof(int36_t)=%u\n", (unsigned)sizeof(int36_t));
	printf("sizeof(uint36_t)=%u\n", (unsigned)sizeof(uint36_t));
#endif
#ifdef	INT40_MAX
	printf("sizeof(int40_t)=%u\n", (unsigned)sizeof(int40_t));
	printf("sizeof(uint40_t)=%u\n", (unsigned)sizeof(uint40_t));
#endif
#ifdef	INT48_MAX
	printf("sizeof(int48_t)=%u\n", (unsigned)sizeof(int48_t));
	printf("sizeof(uint48_t)=%u\n", (unsigned)sizeof(uint48_t));
#endif
#ifdef	INT60_MAX
	printf("sizeof(int60_t)=%u\n", (unsigned)sizeof(int60_t));
	printf("sizeof(uint60_t)=%u\n", (unsigned)sizeof(uint60_t));
#endif
#ifdef	INT64_MAX
	printf("sizeof(int64_t)=%u\n", (unsigned)sizeof(int64_t));
	printf("sizeof(uint64_t)=%u\n", (unsigned)sizeof(uint64_t));
#endif
#ifdef	INT72_MAX
	printf("sizeof(int72_t)=%u\n", (unsigned)sizeof(int72_t));
	printf("sizeof(uint72_t)=%u\n", (unsigned)sizeof(uint72_t));
#endif
#ifdef	INT128_MAX
	printf("sizeof(int128_t)=%u\n", (unsigned)sizeof(int128_t));
	printf("sizeof(uint128_t)=%u\n", (unsigned)sizeof(uint128_t));
#endif
	printf("sizeof(int_least8_t)=%u\n", (unsigned)sizeof(int_least8_t));
	printf("sizeof(uint_least8_t)=%u\n", (unsigned)sizeof(uint_least8_t));
	printf("sizeof(int_least16_t)=%u\n", (unsigned)sizeof(int_least16_t));
	printf("sizeof(uint_least16_t)=%u\n", (unsigned)sizeof(uint_least16_t));
	printf("sizeof(int_least32_t)=%u\n", (unsigned)sizeof(int_least32_t));
	printf("sizeof(uint_least32_t)=%u\n", (unsigned)sizeof(uint_least32_t));
#ifdef	INT_LEAST64_MAX
	printf("sizeof(int_least64_t)=%u\n", (unsigned)sizeof(int_least64_t));
	printf("sizeof(uint_least64_t)=%u\n", (unsigned)sizeof(uint_least64_t));
#else
	printf("*** uint_least64_t isn't defined ***\n");
	status = EXIT_FAILURE;
#endif
#ifdef	INT_LEAST128_MAX
	printf("sizeof(int_least128_t)=%u\n", (unsigned)sizeof(int_least128_t));
	printf("sizeof(uint_least128_t)=%u\n",
		(unsigned)sizeof(uint_least128_t));
#endif
	printf("sizeof(int_fast8_t)=%u\n", (unsigned)sizeof(int_fast8_t));
	printf("sizeof(uint_fast8_t)=%u\n", (unsigned)sizeof(uint_fast8_t));
	printf("sizeof(int_fast16_t)=%u\n", (unsigned)sizeof(int_fast16_t));
	printf("sizeof(uint_fast16_t)=%u\n", (unsigned)sizeof(uint_fast16_t));
	printf("sizeof(int_fast32_t)=%u\n", (unsigned)sizeof(int_fast32_t));
	printf("sizeof(uint_fast32_t)=%u\n", (unsigned)sizeof(uint_fast32_t));
#ifdef	INT_FAST64_MAX
	printf("sizeof(int_fast64_t)=%u\n", (unsigned)sizeof(int_fast64_t));
	printf("sizeof(uint_fast64_t)=%u\n", (unsigned)sizeof(uint_fast64_t));
#else
	printf("*** int_fast64_t isn't defined ***\n");
	status = EXIT_FAILURE;
#endif
#ifdef	INT_FAST128_MAX
	printf("sizeof(int_fast128_t)=%u\n", (unsigned)sizeof(int_fast128_t));
	printf("sizeof(uint_fast128_t)=%u\n", (unsigned)sizeof(uint_fast128_t));
#endif
#if	defined(INTPTR_MAX)
	printf("sizeof(intptr_t)=%u\n", (unsigned)sizeof(intptr_t));
#if	defined(UINTPTR_MAX)
	printf("sizeof(uintptr_t)=%u\n", (unsigned)sizeof(uintptr_t));
#else
	printf("*** intptr_t is defined but uintptr_t isn't ***\n");
	status = EXIT_FAILURE;
#endif
#elif	defined(UINTPTR_MAX)
	printf("sizeof(uintptr_t)=%u\n", (unsigned)sizeof(uintptr_t));
	printf("*** uintptr_t is defined but intptr_t isn't ***\n");
	status = EXIT_FAILURE;
#else
	printf("*** neither intptr_t nor uintptr_t is defined ***\n");
	status = EXIT_FAILURE;
#endif
#ifdef	INTMAX_MAX
	printf("sizeof(intmax_t)=%u\n", (unsigned)sizeof(intmax_t));
	printf("sizeof(uintmax_t)=%u\n", (unsigned)sizeof(uintmax_t));
#else
	printf("*** intmax_t isn't defined ***\n");
	status = EXIT_FAILURE;
#endif

#ifdef	INT8_MAX
	printf("INT8_MIN=%"PRIdMAX"\n", (__Q8_MT)INT8_MIN);
	printf("INT8_MAX=%"PRIdMAX"\n", (__Q8_MT)INT8_MAX);
	printf("UINT8_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT8_MAX);
#endif
#ifdef	INT9_MAX
	printf("INT9_MIN=%"PRIdMAX"\n", (__Q8_MT)INT9_MIN);
	printf("INT9_MAX=%"PRIdMAX"\n", (__Q8_MT)INT9_MAX);
	printf("UINT9_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT9_MAX);
#endif
#ifdef	INT12_MAX
	printf("INT12_MIN=%"PRIdMAX"\n", (__Q8_MT)INT12_MIN);
	printf("INT12_MAX=%"PRIdMAX"\n", (__Q8_MT)INT12_MAX);
	printf("UINT12_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT12_MAX);
#endif
#ifdef	INT16_MAX
	printf("INT16_MIN=%"PRIdMAX"\n", (__Q8_MT)INT16_MIN);
	printf("INT16_MAX=%"PRIdMAX"\n", (__Q8_MT)INT16_MAX);
	printf("UINT16_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT16_MAX);
#endif
#ifdef	INT18_MAX
	printf("INT18_MIN=%"PRIdMAX"\n", (__Q8_MT)INT18_MIN);
	printf("INT18_MAX=%"PRIdMAX"\n", (__Q8_MT)INT18_MAX);
	printf("UINT18_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT18_MAX);
#endif
#ifdef	INT24_MAX
	printf("INT24_MIN=%"PRIdMAX"\n", (__Q8_MT)INT24_MIN);
	printf("INT24_MAX=%"PRIdMAX"\n", (__Q8_MT)INT24_MAX);
	printf("UINT24_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT24_MAX);
#endif
#ifdef	INT32_MAX
	printf("INT32_MIN=%"PRIdMAX"\n", (__Q8_MT)INT32_MIN);
	printf("INT32_MAX=%"PRIdMAX"\n", (__Q8_MT)INT32_MAX);
	printf("UINT32_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT32_MAX);
#endif
#ifdef	INT36_MAX
	printf("INT36_MIN=%"PRIdMAX"\n", (__Q8_MT)INT36_MIN);
	printf("INT36_MAX=%"PRIdMAX"\n", (__Q8_MT)INT36_MAX);
	printf("UINT36_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT36_MAX);
#endif
#ifdef	INT40_MAX
	printf("INT40_MIN=%"PRIdMAX"\n", (__Q8_MT)INT40_MIN);
	printf("INT40_MAX=%"PRIdMAX"\n", (__Q8_MT)INT40_MAX);
	printf("UINT40_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT40_MAX);
#endif
#ifdef	INT48_MAX
	printf("INT48_MIN=%"PRIdMAX"\n", (__Q8_MT)INT48_MIN);
	printf("INT48_MAX=%"PRIdMAX"\n", (__Q8_MT)INT48_MAX);
	printf("UINT48_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT48_MAX);
#endif
#ifdef	INT60_MAX
	printf("INT60_MIN=%"PRIdMAX"\n", (__Q8_MT)INT60_MIN);
	printf("INT60_MAX=%"PRIdMAX"\n", (__Q8_MT)INT60_MAX);
	printf("UINT60_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT60_MAX);
#endif
#ifdef	INT64_MAX
	printf("INT64_MIN=%"PRIdMAX"\n", (__Q8_MT)INT64_MIN);
	printf("INT64_MAX=%"PRIdMAX"\n", (__Q8_MT)INT64_MAX);
	printf("UINT64_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT64_MAX);
#endif
#ifdef	INT72_MAX
	printf("INT72_MIN=%"PRIdMAX"\n", (__Q8_MT)INT72_MIN);
	printf("INT72_MAX=%"PRIdMAX"\n", (__Q8_MT)INT72_MAX);
	printf("UINT72_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT72_MAX);
#endif
#ifdef	INT128_MAX
	printf("INT128_MIN=%"PRIdMAX"\n", (__Q8_MT)INT128_MIN);
	printf("INT128_MAX=%"PRIdMAX"\n", (__Q8_MT)INT128_MAX);
	printf("UINT128_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT128_MAX);
#endif
	printf("INT_LEAST8_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST8_MIN);
	printf("INT_LEAST8_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST8_MAX);
	printf("UINT_LEAST8_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_LEAST8_MAX);
	printf("INT_LEAST16_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST16_MIN);
	printf("INT_LEAST16_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST16_MAX);
	printf("UINT_LEAST16_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_LEAST16_MAX);
	printf("INT_LEAST32_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST32_MIN);
	printf("INT_LEAST32_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST32_MAX);
	printf("UINT_LEAST32_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_LEAST32_MAX);
#ifdef	INT_LEAST64_MAX
	printf("INT_LEAST64_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST64_MIN);
	printf("INT_LEAST64_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST64_MAX);
	printf("UINT_LEAST64_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT_LEAST64_MAX);
#endif
#ifdef	INT_LEAST128_MAX
	printf("INT_LEAST128_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST128_MIN);
	printf("INT_LEAST128_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_LEAST128_MAX);
	printf("UINT_LEAST128_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT_LEAST128_MAX);
#endif
	printf("INT_FAST8_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_FAST8_MIN);
	printf("INT_FAST8_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_FAST8_MAX);
	printf("UINT_FAST8_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_FAST8_MAX);
	printf("INT_FAST16_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_FAST16_MIN);
	printf("INT_FAST16_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_FAST16_MAX);
	printf("UINT_FAST16_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_FAST16_MAX);
	printf("INT_FAST32_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_FAST32_MIN);
	printf("INT_FAST32_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_FAST32_MAX);
	printf("UINT_FAST32_MAX=%"PRIuMAX"\n",
		(U__Q8_MT)UINT_FAST32_MAX);
#ifdef	INT_FAST64_MAX
	printf("INT_FAST64_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_FAST64_MIN);
	printf("INT_FAST64_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_FAST64_MAX);
	printf("UINT_FAST64_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT_FAST64_MAX);
#endif
#ifdef	INT_FAST128_MAX
	printf("INT_FAST128_MIN=%"PRIdMAX"\n", (__Q8_MT)INT_FAST128_MIN);
	printf("INT_FAST128_MAX=%"PRIdMAX"\n", (__Q8_MT)INT_FAST128_MAX);
	printf("UINT_FAST128_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINT_FAST128_MAX);
#endif
#ifdef	INTPTR_MAX
	printf("INTPTR_MIN=%"PRIdMAX"\n", (__Q8_MT)INTPTR_MIN);
	printf("INTPTR_MAX=%"PRIdMAX"\n", (__Q8_MT)INTPTR_MAX);
#endif
#ifdef	UINTPTR_MAX
	printf("UINTPTR_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINTPTR_MAX);
#endif
#ifdef	INTMAX_MAX
	printf("INTMAX_MIN=%"PRIdMAX"\n", (__Q8_MT)INTMAX_MIN);
	printf("INTMAX_MAX=%"PRIdMAX"\n", (__Q8_MT)INTMAX_MAX);
	printf("UINTMAX_MAX=%"PRIuMAX"\n", (U__Q8_MT)UINTMAX_MAX);
#endif
#ifdef	PTRDIFF_MAX
	printf("PTRDIFF_MIN=%"PRIdMAX"\n", (__Q8_MT)PTRDIFF_MIN);
	printf("PTRDIFF_MAX=%"PRIdMAX"\n", (__Q8_MT)PTRDIFF_MAX);
#endif
#ifdef	SIG_ATOMIC_MAX
#if	SIG_ATOMIC_MIN < 0
	printf("SIG_ATOMIC_MIN=%"PRIdMAX"\n", (__Q8_MT)SIG_ATOMIC_MIN);
	printf("SIG_ATOMIC_MAX=%"PRIdMAX"\n", (__Q8_MT)SIG_ATOMIC_MAX);
#else
	printf("SIG_ATOMIC_MIN=%"PRIuMAX"\n", (U__Q8_MT)SIG_ATOMIC_MIN);
	printf("SIG_ATOMIC_MAX=%"PRIuMAX"\n", (U__Q8_MT)SIG_ATOMIC_MAX);
#endif
#endif
#ifdef	SIZE_MAX
	printf("SIZE_MAX=%"PRIuMAX"\n", (U__Q8_MT)SIZE_MAX);
#endif

#ifdef	WCHAR_MAX
#if	WCHAR_MIN < 0
	printf("WCHAR_MIN=%"PRIdMAX"\n", (__Q8_MT)WCHAR_MIN);
	printf("WCHAR_MAX=%"PRIdMAX"\n", (__Q8_MT)WCHAR_MAX);
#else
	printf("WCHAR_MIN=%"PRIuMAX"\n", (U__Q8_MT)WCHAR_MIN);
	printf("WCHAR_MAX=%"PRIuMAX"\n", (U__Q8_MT)WCHAR_MAX);
#endif
#endif
#ifdef	WINT_MAX
#if	WINT_MIN < 0
	printf("WINT_MIN=%"PRIdMAX"\n", (__Q8_MT)WINT_MIN);
	printf("WINT_MAX=%"PRIdMAX"\n", (__Q8_MT)WINT_MAX);
#else
	printf("WINT_MIN=%"PRIuMAX"\n", (U__Q8_MT)WINT_MIN);
	printf("WINT_MAX=%"PRIuMAX"\n", (U__Q8_MT)WINT_MAX);
#endif
#endif

	/*
		7.18.4	Macros for integer constants
	*/

	/* INTn_C for n=8 and 16 were at one point unimplementable
	   on most platforms, so they're treated as "optional": */
#ifdef	INT8_C
	if ( INT8_C(-123) != -123 )
		printf("*** INT8_C(-123) produced %"PRIdMAX" ***\n",
		       (__Q8_MT)INT8_C(-123)
		      );
	if ( UINT8_C(123) != 123 )
		printf("*** UINT8_C(123) produced %"PRIuMAX" ***\n",
		       (U__Q8_MT)UINT8_C(123)
		      );
#endif
#ifdef	INT16_C
	if ( INT16_C(-12345) != -12345 )
		printf("*** INT16_C(-12345) produced %"PRIdMAX" ***\n",
		       (__Q8_MT)INT16_C(-12345)
		      );
	if ( UINT16_C(12345) != 12345 )
		printf("*** UINT16_C(12345) produced %"PRIuMAX" ***\n",
		       (U__Q8_MT)UINT16_C(12345)
		      );
#endif
	if ( INT32_C(-123456789) != -123456789 )
		printf("*** INT32_C(-123456789) produced %"PRIdMAX" ***\n",
		       (__Q8_MT)INT32_C(-123456789)
		      );
	if ( UINT32_C(123456789) != 123456789 )
		printf("*** UINT32_C(123456789) produced %"PRIuMAX" ***\n",
		       (U__Q8_MT)UINT32_C(123456789)
		      );
#ifdef	INT_LEAST64_MAX
	if ( INT64_C(-1234567890123456789) != -1234567890123456789 )
		printf("*** INT64_C(-1234567890123456789) produced %"PRIdMAX
		       " ***\n",
		       (__Q8_MT)INT64_C(-1234567890123456789)
		      );
	if ( UINT64_C(1234567890123456789) != 1234567890123456789 )
		printf("*** UINT64_C(1234567890123456789) produced %"PRIuMAX
		       " ***\n",
		       (U__Q8_MT)UINT64_C(1234567890123456789)
		      );
#endif
#ifdef	INTMAX_MAX
	if ( INTMAX_C(-1234567890123456789) != -1234567890123456789 )
		printf("*** INTMAX_C(-1234567890123456789) produced %"PRIdMAX
		       " ***\n",
		       (__Q8_MT)INTMAX_C(-1234567890123456789)
		      );
	if ( UINTMAX_C(1234567890123456789) != 1234567890123456789 )
		printf("*** UINTMAX_C(1234567890123456789) produced %"PRIuMAX
		       " ***\n",
		       (U__Q8_MT)UINTMAX_C(1234567890123456789)
		      );
#endif

	/* <inttypes.h> features: */

#if	__STDC_VERSION__ >= 199901
	printf("sizeof(imaxdiv_t)=%u\n", (unsigned)sizeof(imaxdiv_t));
#endif

	/*
		7.8.1	Macros for format specifiers
	*/

	{
	/* scanf these strings */
	static const char	in_dn[] = "Z119bZ";
	static const char	in_dmo[] = "Z-0119bZ";
	static const char	in_dspx[] = "Z \t\n +0X119bZ";
	static const char	in_dsmx[] = "Z \t\n -0x119bZ";
	static const char	in_dsn[] = "Z \t\n 119bZ";
	static const char	in_dp[] = "Z+119bZ";
	static const char	in_dpx[] = "Z+0X119bz";

	/* sprintf into this */
	static char		buffer[1024];

#define	SCAN(buf,fs,var,exp)	if ( sscanf(buf, "Z%" fs, &var) != 1 ) \
					{ \
					printf("*** " #fs "=" STR_SUB(fs) \
					       " failed ***\n" \
					      ); \
					status = EXIT_FAILURE; \
					} \
				else if ( var != (exp) ) \
					{ \
					printf("*** " #fs "="  STR_SUB(fs) \
					       " should be: " STR_SUB(exp) \
					       ", was: %" fs " ***\n", var \
					      ); \
					status = EXIT_FAILURE; \
					} \
				else	/* for trailing semicolon */

#define	PRINT(fs,var,exp)	if ( sprintf(buffer, "%" fs, var ) <= 0 ) \
					{ \
					printf("*** " #fs "=" STR_SUB(fs) \
					       " failed ***\n" \
					      ); \
					status = EXIT_FAILURE; \
					} \
				else if ( strcmp(buffer, STR_SUB(exp)) != 0 ) \
					{ \
					printf("*** " #fs "="  STR_SUB(fs) \
					       " should be: " STR_SUB(exp) \
					       ", was: %s ***\n", buffer \
					      ); \
					status = EXIT_FAILURE; \
					} \
				else	/* for trailing semicolon */

#ifdef	SCNo32
	SCAN(in_dn, SCNo32, int32, 9);
#endif
#ifdef	PRIo32
	PRINT(PRIo32, int32, 11);
#endif
	SCAN(in_dmo, SCNiLEAST16, intl16, -9);
	SCAN(in_dspx, SCNdLEAST16, intl16, 0);
	SCAN(in_dsmx, SCNiLEAST16, intl16, -4507);
	PRINT(PRIdLEAST16, intl16, -4507);
	PRINT(PRIiLEAST16, intl16, -4507);
	SCAN(in_dsn, SCNxLEAST16, uintl16, 4507);
	PRINT(PRIoLEAST16, uintl16, 10633);
	PRINT(PRIuLEAST16, uintl16, 4507);
	PRINT(PRIxLEAST16, uintl16, 119b);
	PRINT(PRIXLEAST16, uintl16, 119B);
	SCAN(in_dp, SCNxFAST16, uintf16, 4507);
	PRINT(PRIxFAST16, uintf16, 119b);
#ifdef	SCNdMAX
	SCAN(in_dp, SCNdMAX, intmax, 119);
#endif
#ifdef	PRIiMAX
	PRINT(PRIiMAX, intmax, 119);
#endif
#ifdef	SCNoMAX
	SCAN(in_dpx, SCNoMAX, uintmax, 0);
#endif
#ifdef	PRIxMAX
	PRINT(PRIxMAX, uintmax, 0);
#endif
	/* Obviously there should be a much larger battery of such tests. */
	}

#if	defined(INTMAX_MAX)		/* <inttypes.h> has C99 features */
	/*
		7.8.2	Functions for greatest-width integer types
	*/

	{
	static struct
		{
		intmax_t	input;
		intmax_t	expect;
		}	abs_data[] =
		{
#ifdef	INT8_MAX
		INT8_MAX,		INT8_MAX,
		-INT8_MAX,		INT8_MAX,
		UINT8_MAX,		UINT8_MAX,
#endif
#ifdef	INT16_MAX
		INT16_MAX,		INT16_MAX,
		-INT16_MAX,		INT16_MAX,
		UINT16_MAX,		UINT16_MAX,
#endif
#ifdef	INT32_MAX
		INT32_MAX,		INT32_MAX,
		-INT32_MAX,		INT32_MAX,
#ifdef	INT_LEAST64_MAX			/* else might support only 32 bits */
		UINT32_MAX,		UINT32_MAX,
#endif
#endif
#ifdef	INT64_MAX
		INT64_MAX,		INT64_MAX,
		-INT64_MAX,		INT64_MAX,
#endif
		INT_LEAST8_MAX,		INT_LEAST8_MAX,
		-INT_LEAST8_MAX,	INT_LEAST8_MAX,
		UINT_LEAST8_MAX,	UINT_LEAST8_MAX,
		INT_LEAST16_MAX,	INT_LEAST16_MAX,
		-INT_LEAST16_MAX,	INT_LEAST16_MAX,
		UINT_LEAST16_MAX,	UINT_LEAST16_MAX,
		INT_LEAST32_MAX,	INT_LEAST32_MAX,
		-INT_LEAST32_MAX,	INT_LEAST32_MAX,
#ifdef	INT_LEAST64_MAX
		UINT_LEAST32_MAX,	UINT_LEAST32_MAX,
		INT_LEAST64_MAX,	INT_LEAST64_MAX,
		-INT_LEAST64_MAX,	INT_LEAST64_MAX,
#endif
		INT_FAST8_MAX,		INT_FAST8_MAX,
		-INT_FAST8_MAX,	INT_FAST8_MAX,
		UINT_FAST8_MAX,	UINT_FAST8_MAX,
		INT_FAST16_MAX,	INT_FAST16_MAX,
		-INT_FAST16_MAX,	INT_FAST16_MAX,
		UINT_FAST16_MAX,	UINT_FAST16_MAX,
		INT_FAST32_MAX,	INT_FAST32_MAX,
		-INT_FAST32_MAX,	INT_FAST32_MAX,
#ifdef	INT_FAST64_MAX
		UINT_FAST32_MAX,	UINT_FAST32_MAX,
		INT_FAST64_MAX,	INT_FAST64_MAX,
		-INT_FAST64_MAX,	INT_FAST64_MAX,
#endif
#ifdef	INTPTR_MAX
		INTPTR_MAX,		INTPTR_MAX,
		-INTPTR_MAX,		INTPTR_MAX,
#endif
#ifdef	UINTPTR_MAX
		UINTPTR_MAX,		UINTPTR_MAX,
#endif
		INTMAX_MAX,		INTMAX_MAX,
#ifdef	PTRDIFF_MAX
		PTRDIFF_MAX,		PTRDIFF_MAX,
#endif
#ifdef	SIG_ATOMIC_MAX
		SIG_ATOMIC_MAX,		SIG_ATOMIC_MAX,
#if	SIG_ATOMIC_MIN < 0
		-SIG_ATOMIC_MAX,	SIG_ATOMIC_MAX,
#endif
#endif
#ifdef	SIZE_MAX
		SIZE_MAX,		SIZE_MAX,
#endif
#ifdef	WCHAR_MAX
		WCHAR_MAX,		WCHAR_MAX,
#if	WCHAR_MIN < 0
		-WCHAR_MAX,		WCHAR_MAX,
#endif
#endif
#ifdef	WINT_MAX
		WINT_MAX,		WINT_MAX,
#if	WINT_MIN < 0
		-WINT_MAX,		WINT_MAX,
#endif
#endif
		127,				127,
		-127,				127,
		128,				128,
		-127-1,				128,
		255,				255,
		-256+1,				255,
		256,				256,
		-256,				256,
		32767,				32767,
		-32767,				32767,
		32768,				32768,
		-32767-1,			32768,
		65535,				65535,
		-65536+1,			65535,
		65536,				65536,
		-65536,				65536,
		2147483647,			2147483647,
		-2147483647,			2147483647,
		2147483648,			2147483648,
		-2147483647-1,			2147483648,
#ifdef	INT_LEAST64_MAX			/* else might support only 32 bits */
		4294967295,			4294967295,
		-4294967296+1,			4294967295,
		4294967296,			4294967296,
		-4294967296,			4294967296,
		9223372036854775807,		9223372036854775807,
		-9223372036854775807,		9223372036854775807,
		1234567890123456789,		1234567890123456789,
		-1234567890123456789,		1234567890123456789,
#endif
		1,				1,
		-1,				1,
		2,				2,
		-2,				2,
		10,				10,
		-10,				10,
		16,				16,
		-16,				16,
		/* Other test cases can be added here. */
		0,		0	/* terminates the list */
		},	*adp = abs_data;

	do	if ( (intmax = imaxabs(adp->input)) != adp->expect )
			{
			printf("*** imaxabs(%"PRIdMAX") failed; should be: %"
			       PRIdMAX", was: %"PRIdMAX" ***\n",
			       adp->input, adp->expect, intmax
			      );
			status = EXIT_FAILURE;
			}
	while ( adp++->input != 0 );
	}

	{
	imaxdiv_t	result;
	static struct
		{
		intmax_t	numer;
		intmax_t	denom;
		intmax_t	exp_quot;
		intmax_t	exp_rem;
		}	div_data[] =
		{
		0, 1,				0, 0,
		0, -1,				0, 0,
		0, 2,				0, 0,
		0, -2,				0, 0,
		0, 5,				0, 0,
		0, -5,				0, 0,
		1, 1,				1, 0,
		1, -1,				-1, 0,
		1, 2,				0, 1,
		1, -2,				0, 1,
		1, 5,				0, 1,
		1, -5,				0, 1,
		-1, 1,				-1, 0,
		-1, -1,				1, 0,
		-1, 2,				0, -1,
		-1, -2,				0, -1,
		-1, 5,				0, -1,
		-1, -5,				0, -1,
		2, 1,				2, 0,
		2, -1,				-2, 0,
		2, 2,				1, 0,
		2, -2,				-1, 0,
		2, 5,				0, 2,
		2, -5,				0, 2,
		-2, 1,				-2, 0,
		-2, -1,				2, 0,
		-2, 2,				-1, 0,
		-2, -2,				1, 0,
		-2, 5,				0, -2,
		-2, -5,				0, -2,
		17, 5,				3, 2,
		-17, -5,			3, -2,
		17, -5,				-3, 2,
		-17, 5,				-3, -2,
		2147483647, 1,			2147483647, 0,
		-2147483647, 1,			-2147483647, 0,
		2147483648, 1,			2147483648, 0,
		-2147483647-1, 1,		-2147483647-1, 0,
		2147483647, 2,			1073741823, 1,
		-2147483647, 2,			-1073741823, -1,
		2147483648, 2,			1073741824, 0,
		-2147483647-1, 2,		-1073741824, 0,
#ifdef	INT_LEAST64_MAX			/* else might support only 32 bits */
		4294967295, 1,			4294967295, 0,
		-4294967296+1, 1,		-4294967296+1, 0,
		4294967296, 1,			4294967296, 0,
		-4294967296, 1,			-4294967296, 0,
		4294967295, -1,			-4294967296+1, 0,
		-4294967296+1, -1,		4294967295, 0,
		4294967296, -1,			-4294967296, 0,
		-4294967296, -1,		4294967296, 0,
		4294967295, 2,			2147483647, 1,
		-4294967296+1, 2,		-2147483647, -1,
		4294967296, 2,			2147483648, 0,
		-4294967296, 2,			-2147483647-1, 0,
		4294967295, 2147483647,		2, 1,
		-4294967296+1, 2147483647,	-2, -1,
		4294967296, 2147483647,		2, 2,
		-4294967296, 2147483647,	-2, -2,
		4294967295, -2147483647,	-2, 1,
		-4294967296+1, -2147483647,	2, -1,
		4294967296, -2147483647,	-2, 2,
		-4294967296, -2147483647,	2, -2,
		4294967295, 2147483648,		1, 2147483647,
		-4294967296+1, 2147483648,	-1, -2147483647,
		4294967296, 2147483648,		2, 0,
		-4294967296, 2147483648,	-2, 0,
		4294967295, -2147483647-1,	-1, 2147483647,
		-4294967296+1, -2147483647-1,	1, -2147483647,
		4294967296, -2147483647-1,	-2, 0,
		-4294967296, -2147483647-1,	2, 0,
		9223372036854775807, 1,		9223372036854775807, 0,
		-9223372036854775807, 1,	-9223372036854775807, 0,
		9223372036854775807, 2,		4611686018427387903, 1,
		-9223372036854775807, 2,	-4611686018427387903, -1,
#endif
		/* There should be a much larger battery of such tests. */
		0, 0,		0, 0	/* 0 denom terminates the list */
		},	*ddp;

	for ( ddp = div_data; ddp->denom != 0; ++ddp )
		if ( (result = imaxdiv(ddp->numer, ddp->denom)).quot
		     != ddp->exp_quot || result.rem != ddp->exp_rem
		   )	{
			printf("*** imaxdiv(%"PRIdMAX",%"PRIdMAX
			       ") failed; should be: (%"PRIdMAX",%"PRIdMAX
			       "), was: (%"PRIdMAX",%"PRIdMAX") ***\n",
			       ddp->numer, ddp->denom, ddp->exp_quot,
			       ddp->exp_rem, result.quot, result.rem
			      );
			status = EXIT_FAILURE;
			}
	}

	{
	char		*endptr;
	wchar_t		*wendptr;
	static char	saved[64];	/* holds copy of input string */
	static wchar_t	wnptr[64];	/* holds wide copy of test string */
	static int	warned;		/* "warned for null endptr" flag */
	register int	i;
	static struct
		{
		char *		nptr;
		int		base;
		intmax_t	exp_val;
		int		exp_len;
		}	str_data[] =
		{
		"", 0,				0, 0,
		"", 2,				0, 0,
		"", 8,				0, 0,
		"", 9,				0, 0,
		"", 10,				0, 0,
		"", 16,				0, 0,
		"", 36,				0, 0,
		"0", 0,				0, 1,
		"0", 2,				0, 1,
		"0", 8,				0, 1,
		"0", 9,				0, 1,
		"0", 10,			0, 1,
		"0", 16,			0, 1,
		"0", 36,			0, 1,
		"+0", 0,			0, 2,
		"+0", 2,			0, 2,
		"+0", 8,			0, 2,
		"+0", 9,			0, 2,
		"+0", 10,			0, 2,
		"+0", 16,			0, 2,
		"+0", 36,			0, 2,
		"-0", 0,			0, 2,
		"-0", 2,			0, 2,
		"-0", 8,			0, 2,
		"-0", 9,			0, 2,
		"-0", 10,			0, 2,
		"-0", 16,			0, 2,
		"-0", 36,			0, 2,
		"Inf", 0,			0, 0,
		"Inf", 2,			0, 0,
		"Inf", 8,			0, 0,
		"Inf", 9,			0, 0,
		"Inf", 10,			0, 0,
		"Inf", 16,			0, 0,
		"Inf", 36,			24171, 3,
		"+Inf", 0,			0, 0,
		"+Inf", 2,			0, 0,
		"+Inf", 8,			0, 0,
		"+Inf", 9,			0, 0,
		"+Inf", 10,			0, 0,
		"+Inf", 16,			0, 0,
		"+Inf", 36,			24171, 4,
		"-Inf", 0,			0, 0,
		"-Inf", 2,			0, 0,
		"-Inf", 8,			0, 0,
		"-Inf", 9,			0, 0,
		"-Inf", 10,			0, 0,
		"-Inf", 16,			0, 0,
		"-Inf", 36,			-24171, 4,
		"inf", 0,			0, 0,
		"inf", 2,			0, 0,
		"inf", 8,			0, 0,
		"inf", 9,			0, 0,
		"inf", 10,			0, 0,
		"inf", 16,			0, 0,
		"inf", 36,			24171, 3,
		"+inf", 0,			0, 0,
		"+inf", 2,			0, 0,
		"+inf", 8,			0, 0,
		"+inf", 9,			0, 0,
		"+inf", 10,			0, 0,
		"+inf", 16,			0, 0,
		"+inf", 36,			24171, 4,
		"-inf", 0,			0, 0,
		"-inf", 2,			0, 0,
		"-inf", 8,			0, 0,
		"-inf", 9,			0, 0,
		"-inf", 10,			0, 0,
		"-inf", 16,			0, 0,
		"-inf", 36,			-24171, 4,
		"119b8Z", 0,			119, 3,
		"119bZ", 0,			119, 3,
		"-0119bZ", 0,			-9, 4,
		" \t\n 0X119bZ", 0,		4507, 10,
		" \t\n +0X119bZ", 0,		4507, 11,
		" \t\n -0x119bZ", 0,		-4507, 11,
		" \t\n 119bZ", 0,		119, 7,
		"+119bZ", 0,			119, 4,
		"+0X119bz", 0,			4507, 7,
		"119b8Z", 2,			3, 2,
		"119bZ", 2,			3, 2,
		"-0119bZ", 2,			-3, 4,
		" \t\n 0X119bZ", 2,		0, 5,
		" \t\n +0X119bZ", 2,		0, 6,
		" \t\n -0x119bZ", 2,		0, 6,
		" \t\n 119bZ", 2,		3, 6,
		"+119bZ", 2,			3, 3,
		"+0X119bz", 2,			0, 2,
		"119b8Z", 8,			9, 2,
		"119bZ", 8,			9, 2,
		"-0119bZ", 8,			-9, 4,
		" \t\n 0X119bZ", 8,		0, 5,
		" \t\n +0X119bZ", 8,		0, 6,
		" \t\n -0x119bZ", 8,		0, 6,
		" \t\n 119bZ", 8,		9, 6,
		"+119bZ", 8,			9, 3,
		"+0X119bz", 8,			0, 2,
		"119b8Z", 9,			10, 2,
		"119bZ", 9,			10, 2,
		"-0119bZ", 9,			-10, 4,
		" \t\n 0X119bZ", 9,		0, 5,
		" \t\n +0X119bZ", 9,		0, 6,
		" \t\n -0x119bZ", 9,		0, 6,
		" \t\n 119bZ", 9,		10, 6,
		"+119bZ", 9,			10, 3,
		"+0X119bz", 9,			0, 2,
		"119b8Z", 10,			119, 3,
		"119bZ", 10,			119, 3,
		"-0119bZ", 10,			-119, 5,
		" \t\n 0X119bZ", 10,		0, 5,
		" \t\n +0X119bZ", 10,		0, 6,
		" \t\n -0x119bZ", 10,		0, 6,
		" \t\n 119bZ", 10,		119, 7,
		"+119bZ", 10,			119, 4,
		"+0X119bz", 10,			0, 2,
		"119b8Z", 16,			72120, 5,
		"119bZ", 16,			4507, 4,
		"-0119bZ", 16,			-4507, 6,
		" \t\n 0X119bZ", 16,		4507, 10,
		" \t\n +0X119bZ", 16,		4507, 11,
		" \t\n -0x119bZ", 16,		-4507, 11,
		" \t\n 119bZ", 16,		4507,8,
		"+119bZ", 16,			4507, 5,
		"+0X119bz", 16,			4507, 7,
		"119b8Z", 36,			62580275, 6,
		"119bZ", 36,			1738367, 5,
		"-0119bZ", 36,			-1738367, 7,
		" \t\n 0X119bZ", 36,		1997122175, 11,
		" \t\n +0X119bZ", 36,		1997122175, 12,
		" \t\n -0x119bZ", 36,		-1997122175, 12,
		" \t\n 119bZ", 36,		1738367, 9,
		"+119bZ", 36,			1738367, 6,
		"+0X119bz", 36,			1997122175, 8,
		/* There should be a much larger battery of such tests. */
		"127", 0,			127, 3,
		"-127", 0,			-127, 4,
		"128", 0,			128, 3,
		"-128", 0,			-127-1, 4,
		"255", 0,			255, 3,
		"-255", 0,			-255, 4,
		"256", 0,			256, 3,
		"-256", 0,			-255-1, 4,
		"32767", 0,			32767, 5,
		"-32767", 0,			-32767, 6,
		"32768", 0,			32768, 5,
		"-32768", 0,			-32767-1, 6,
		"65535", 0,			65535, 5,
		"-65535", 0,			-65536+1, 6,
		"65536", 0,			65536, 5,
		"-65536", 0,			-65536, 6,
		"2147483647", 0,		2147483647, 10,
		"-2147483647", 0,		-2147483647, 11,
		"2147483648", 0,		2147483648, 10,
		"-2147483648", 0,		-2147483647-1, 11,
		"4294967295", 0,		4294967295, 10,
		"-4294967295", 0,		-4294967296+1, 11,
		"4294967296", 0,		4294967296, 10,
		"-4294967296", 0,		-4294967296, 11,
		"9223372036854775807", 0,	9223372036854775807, 19,
		"-9223372036854775807", 0,	-9223372036854775807, 20,
		"1234567890123456789", 0,	1234567890123456789, 19,
		"-1234567890123456789", 0,	-1234567890123456789, 20,
		"1", 0,				1, 1,
		"-1", 0,			-1, 2,
		"2", 0,				2, 1,
		"-2", 0,			-2, 2,
		"10", 0,			10, 2,
		"-10", 0,			-10, 3,
		"16", 0,			16, 2,
		"-16", 0,			-16, 3,
		/* Other test cases can be added here. */
		NULL, 0,	0, 0	/* terminates the list */
		},	*sdp;

	for ( sdp = str_data; sdp->nptr != NULL ; ++sdp )
		{
		/*
			7.8.2.3	The strtoimax and strtoumax functions
		*/

		strcpy(saved, sdp->nptr);

		errno = 0;		/* shouldn't be changed */

		if ( (intmax = strtoimax(sdp->nptr, &endptr, sdp->base))
		  != sdp->exp_val
		   )	{
			int	save = errno;

			printf("*** strtoimax(%s,,%d) failed; should be: %"
			       PRIdMAX", was: %"PRIdMAX" ***\n", sdp->nptr,
			       sdp->base, sdp->exp_val, intmax
			      );
			status = EXIT_FAILURE;
			errno = save;
			}
		else if ( endptr != sdp->nptr + sdp->exp_len )
			{
			int	save = errno;

			printf("*** strtoimax(%s,,%d) returned wrong endptr"
			       " ***\n", sdp->nptr, sdp->base
			      );
			status = EXIT_FAILURE;
			errno = save;
			}

		if ( errno != 0 )
			{
			printf("*** strtoimax modified errno ***\n");
			status = EXIT_FAILURE;
			}

		if ( strcmp(sdp->nptr, saved) != 0 )
			{
			printf("*** strtoimax modified its input ***\n");
			status = EXIT_FAILURE;
			strcpy(saved, sdp->nptr);
			}

		if ( sdp->exp_val >= 0 )	/* else some sign extension */
			{
			errno = 0;	/* shouldn't be changed */

			if ( (uintmax = strtoumax(sdp->nptr, &endptr, sdp->base
						 )
			     ) != sdp->exp_val
			   )	{
				int	save = errno;

				printf("*** strtoumax(%s,,%d) failed; "
				       "should be: %"PRIuMAX", was: %"PRIuMAX
				       " ***\n", sdp->nptr, sdp->base,
				       sdp->exp_val, uintmax
				      );
				status = EXIT_FAILURE;
				errno = save;
				}
			else if ( endptr != sdp->nptr + sdp->exp_len )
				{
				int	save = errno;

				printf("*** strtoumax(%s,,%d) returned wrong "
				       "endptr ***\n", sdp->nptr, sdp->base
				      );
				status = EXIT_FAILURE;
				errno = save;
				}

			if ( errno != 0 )
				{
				printf("*** strtoumax modified errno ***\n");
				status = EXIT_FAILURE;
				}

			if ( strcmp(sdp->nptr, saved) != 0 )
				{
				printf("*** strtoumax"
				       " modified its input ***\n"
				      );
				status = EXIT_FAILURE;
				strcpy(saved, sdp->nptr);
				}
			}

		/* tests for null endptr */

#define	WARN()	if (!warned) warned = 1, printf("*** Using null endptr: ***\n")

		warned = 0;
		errno = 0;		/* shouldn't be changed */

		if ( (intmax = strtoimax(sdp->nptr, (char **)NULL, sdp->base))
		  != sdp->exp_val
		   )	{
			int	save = errno;

			WARN();
			printf("*** strtoimax(%s,NULL,%d) failed; "
			       "should be: %"PRIdMAX", was: %"PRIdMAX" ***\n",
			       sdp->nptr, sdp->base, sdp->exp_val, intmax
			      );
			status = EXIT_FAILURE;
			errno = save;
			}

		if ( errno != 0 )
			{
			WARN();
			printf("*** strtoimax modified errno ***\n");
			status = EXIT_FAILURE;
			}

		if ( strcmp(sdp->nptr, saved) != 0 )
			{
			WARN();
			printf("*** strtoimax modified its input ***\n");
			status = EXIT_FAILURE;
			strcpy(saved, sdp->nptr);
			}

		if ( sdp->exp_val >= 0 )	/* else some sign extension */
			{
			errno = 0;	/* shouldn't be changed */

			if ( (uintmax = strtoumax(sdp->nptr, (char **)NULL,
						  sdp->base
						 )
			     ) != sdp->exp_val
			   )	{
				int	save = errno;

				WARN();
				printf("*** strtoumax(%s,NULL,%d) failed; "
				       "should be: %"PRIuMAX", was: %"PRIuMAX
				       " ***\n", sdp->nptr, sdp->base,
				       sdp->exp_val, uintmax
				      );
				status = EXIT_FAILURE;
				errno = save;
				}

			 if ( errno != 0 )
				{
				WARN();
				printf("*** strtoumax modified errno ***\n");
				status = EXIT_FAILURE;
				}

			 if ( strcmp(sdp->nptr, saved) != 0 )
				{
				WARN();
				printf("*** strtoumax"
				       " modified its input ***\n"
				      );
				status = EXIT_FAILURE;
				strcpy(saved, sdp->nptr);
				}
			}

		/*
			7.8.2.4	The wcstoimax and wcstoumax functions
		*/

		for ( i = 0; i < 64; ++i )
			if ( (wnptr[i] = sdp->nptr[i]) == '\0' )
				break;

		errno = 0;		/* shouldn't be changed */

		if ( (intmax = wcstoimax(wnptr, &wendptr, sdp->base))
		  != sdp->exp_val
		   )	{
			int	save = errno;

			printf("*** wcstoimax(%s,,%d) failed; should be: %"
			       PRIdMAX", was: %"PRIdMAX" ***\n", sdp->nptr,
			       sdp->base, sdp->exp_val, intmax
			      );
			status = EXIT_FAILURE;
			errno = save;
			}
		else if ( wendptr != wnptr + sdp->exp_len )
			{
			int	save = errno;

			printf("*** wcstoimax(%s,,%d) returned wrong endptr"
			       " ***\n", sdp->nptr, sdp->base
			      );
			status = EXIT_FAILURE;
			errno = save;
			}

		if ( errno != 0 )
			{
			printf("*** wcstoimax modified errno ***\n");
			status = EXIT_FAILURE;
			}

		for ( i = 0; i < 64; ++i )
			if ( wnptr[i] != sdp->nptr[i] )
				{
				printf("*** wcstoimax modified its input ***\n"
				      );
				status = EXIT_FAILURE;

				for ( ; i < 64; ++i )
					if ( (wnptr[i] = sdp->nptr[i]) == '\0' )
						break;

				break;
				}
			else if ( wnptr[i] == '\0' )
				break;

		if ( sdp->exp_val >= 0 )	/* else some sign extension */
			{
			errno = 0;	/* shouldn't be changed */

			if ( (uintmax = wcstoumax(wnptr, &wendptr, sdp->base)
			     ) != sdp->exp_val
			   )	{
				int	save = errno;

				printf("*** wcstoumax(%s,,%d) failed; "
				       "should be: %"PRIuMAX", was: %"PRIuMAX
				       " ***\n", sdp->nptr, sdp->base,
				       sdp->exp_val, uintmax
				      );
				status = EXIT_FAILURE;
				errno = save;
				}
			else if ( wendptr != wnptr + sdp->exp_len )
				{
				int	save = errno;

				printf("*** wcstoumax(%s,,%d) returned wrong "
				       "endptr ***\n", sdp->nptr, sdp->base
				      );
				status = EXIT_FAILURE;
				errno = save;
				}

			if ( errno != 0 )
				{
				printf("*** wcstoumax modified errno ***\n");
				status = EXIT_FAILURE;
				}

			for ( i = 0; i < 64; ++i )
				if ( wnptr[i] != sdp->nptr[i] )
					{
					printf("*** wcstoumax"
					       " modified its input ***\n"
					      );
					status = EXIT_FAILURE;

					for ( ; i < 64; ++i )
						if ( (wnptr[i] = sdp->nptr[i])
						  == '\0'
						   )
							break;

					break;
					}
				else if ( wnptr[i] == '\0' )
					break;
			}

		/* tests for null endptr */

		warned = 0;
		errno = 0;		/* shouldn't be changed */

		if ( (intmax = wcstoimax(wnptr, (wchar_t **)NULL, sdp->base))
		  != sdp->exp_val
		   )	{
			int	save = errno;

			WARN();
			printf("*** wcstoimax(%s,NULL,%d) failed; should be: %"
			       PRIdMAX", was: %"PRIdMAX" ***\n", sdp->nptr,
			       sdp->base, sdp->exp_val, intmax
			      );
			status = EXIT_FAILURE;
			errno = save;
			}

		if ( errno != 0 )
			{
			WARN();
			printf("*** wcstoimax modified errno ***\n");
			status = EXIT_FAILURE;
			}

		for ( i = 0; i < 64; ++i )
			if ( wnptr[i] != sdp->nptr[i] )
				{
				WARN();
				printf("*** wcstoimax modified its input ***\n"
				      );
				status = EXIT_FAILURE;

				for ( ; i < 64; ++i )
					if ( (wnptr[i] = sdp->nptr[i])
					  == '\0'
					   )
						break;

				break;
				}
			else if ( wnptr[i] == '\0' )
				break;

		if ( sdp->exp_val >= 0 )	/* else some sign extension */
			{
			errno = 0;	/* shouldn't be changed */

			if ( (uintmax = wcstoumax(wnptr, (wchar_t **)NULL,
						  sdp->base
						 )
			     ) != sdp->exp_val
			   )	{
				int	save = errno;

				WARN();
				printf("*** wcstoumax(%s,NULL,%d) failed; "
				       "should be: %"PRIuMAX", was: %"PRIuMAX
				       " ***\n", sdp->nptr, sdp->base,
				       sdp->exp_val, uintmax
				      );
				status = EXIT_FAILURE;
				errno = save;
				}

			 if ( errno != 0 )
				{
				WARN();
				printf("*** wcstoumax modified errno ***\n");
				status = EXIT_FAILURE;
				}

			for ( i = 0; i < 64; ++i )
				if ( wnptr[i] != sdp->nptr[i] )
					{
					WARN();
					printf("*** wcstoumax"
					       " modified its input ***\n"
					      );
					status = EXIT_FAILURE;

					for ( ; i < 64; ++i )
						if ( (wnptr[i] = sdp->nptr[i])
						  == '\0'
						   )
							break;

					break;
					}
				else if ( wnptr[i] == '\0' )
					break;
			}
		}

	/*
		7.8.2.3	The strtoimax and strtoumax functions (continued)
	*/

	if ( (intmax = strtoimax("1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != INTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** strtoimax failed overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (intmax = strtoimax("+1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != INTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** strtoimax failed +overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (intmax = strtoimax("-1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != INTMAX_MIN || errno != ERANGE
	   )	{
		printf("*** strtoimax failed -overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = strtoumax("1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** strtoumax failed overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = strtoumax("+1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** strtoumax failed +overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = strtoumax("-1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890"
				 "1234567890123456789012345678901234567890",
				 &endptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** strtoumax failed -overflow test ***\n");
		status = EXIT_FAILURE;
		}

	/*
		7.8.2.4	The wcstoimax and wcstoumax functions (continued)
	*/

	if ( (intmax = wcstoimax(L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != INTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** wcstoimax failed overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (intmax = wcstoimax(L"+1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != INTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** wcstoimax failed +overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (intmax = wcstoimax(L"-1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != INTMAX_MIN || errno != ERANGE
	   )	{
		printf("*** wcstoimax failed -overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = wcstoumax(L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** wcstoumax failed overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = wcstoumax(L"+1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** wcstoumax failed +overflow test ***\n");
		status = EXIT_FAILURE;
		}

	if ( (uintmax = wcstoumax(L"-1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890"
				 L"1234567890123456789012345678901234567890",
				 &wendptr, 0
				)
	     ) != UINTMAX_MAX || errno != ERANGE
	   )	{
		printf("*** wcstoumax failed -overflow test ***\n");
		status = EXIT_FAILURE;
		}
	}
#endif	/* defined(INTMAX_MAX) */

	if ( status != 0 )
		fprintf(stderr, "sitest failed; see stdout for details\n");

	return status;
	}
END OF sitest.c
echo 'wchar.c' 1>&2
cat >'wchar.c' <<'END OF wchar.c'
/*
	wchar -- extended multibyte and wide character utilities

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.24 of ISO/IEC 9899:1999 (E).

	This is a minimal implementation for environments where
	internationalization is not considered important.

	It supports an encoding where all char codes are mapped
	to the *same* code values within a wchar_t or wint_t,
	so long as no other wchar_t codes are used by the program.

	This implementation is already compatible with Clive
	Feather's proposed changes detailed in WG14/N898 (DR#212).

	XXX -- UNTESTED -- XXX
*/

#include	<errno.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include	<time.h>
#ifdef	__STDC__
#include	<stdarg.h>
#else
#include	<varargs.h>
#endif

#include	<Q8defs.h>		/* defines several __Q8_* symbols */
#include	<stdbool.h>
#include	<wchar.h>

#ifndef	EILSEQ
#define	EILSEQ		ERANGE
#endif

#ifndef	MB_CUR_MAX
#define	MB_CUR_MAX	1
#endif

/*	helper functions:	*/

static char	x_format[BUFSIZ];
static char	x_s[BUFSIZ];

static bool
shrink(src, dst)
	register __Q8_CONST wchar_t * __Q8_RESTRICT	src;
	register char * __Q8_RESTRICT			dst;
	{
	register int					i;

	for ( i = 0; i < BUFSIZ; ++i )
		if ( (dst[i] = src[i]) == 0 )
			return true;

	errno = EDOM;
	return false;			/* doesn't fit into buffer */
	}

static bool
expand(src, dst)
	register __Q8_CONST char * __Q8_RESTRICT	src;
	register wchar_t * __Q8_RESTRICT		dst;
	{
	register int					i;

	for ( i = 0; i < BUFSIZ; ++i )
		if ( (dst[i] = src[i]) == 0 )
			return true;

	errno = EDOM;
	return false;			/* doesn't fit into buffer */
	}

/*
	7.24.2	Formatted wide character input/output functions
*/

/* VARARGS */
int
fwprintf(__Q8_T(__Q8_FILE * __Q8_RESTRICT		stream)
	 __Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
	 __Q8_AList
	)
	__Q8_Dcl
	{
	__Q8_D(__Q8_FILE	*stream)
	__Q8_D(wchar_t		*format)
	__Q8_List(		ap)
	int			ret;	/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, __Q8_FILE *, stream)
	__Q8_I(ap, wchar_t *, format)

	ret = vfwprintf(stream, format, ap);

	__Q8_End( ap )
	return ret;
	}

/* VARARGS */
int
fwscanf(__Q8_T(__Q8_FILE * __Q8_RESTRICT		stream)
	__Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
	__Q8_AList
       )__Q8_Dcl
	{
	__Q8_D(__Q8_FILE	*stream)
	__Q8_D(wchar_t		*format)
	__Q8_List(		ap)
	int			ret;	/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, __Q8_FILE *, stream)
	__Q8_I(ap, wchar_t *, format)

	ret = vfwscanf(stream, format, ap);

	__Q8_End( ap )
	return ret;
	}

/* VARARGS */
int
swprintf(__Q8_T(wchar_t * __Q8_RESTRICT			s)
	 __Q8_T(size_t					n)
	 __Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
	 __Q8_AList
	)
	__Q8_Dcl
	{
	__Q8_D(wchar_t	*s)
	__Q8_D(size_t	n)
	__Q8_D(wchar_t	*format)
	__Q8_List(	ap)
	int		ret;		/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, wchar_t *, s)
	__Q8_I(ap, size_t, n)
	__Q8_I(ap, wchar_t *, format)

	ret = vswprintf(s, n, format, ap);

	__Q8_End( ap )
	return ret;
	}

/* VARARGS */
int
swscanf(__Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	s)
	__Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
	__Q8_AList
       )__Q8_Dcl
	{
	__Q8_D(__Q8_CONST wchar_t	*s)
	__Q8_D(wchar_t			*format)
	__Q8_List(			ap)
	int				ret;	/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, wchar_t *, s)
	__Q8_I(ap, wchar_t *, format)

	ret = vswscanf(s, format, ap);

	__Q8_End( ap )
	return ret;
	}

int
vfwprintf(stream, format, arg)
	__Q8_FILE * __Q8_RESTRICT		stream;
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	if ( ! shrink(format, x_format) )
		return -1;

	return vfprintf(stream, x_format, arg);
	}

int
vfwscanf(stream, format, arg)
	__Q8_FILE * __Q8_RESTRICT		stream;
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	if ( ! shrink(format, x_format) )
		return -1;

	return vfscanf(stream, x_format, arg);
	}

int
vswprintf(s, n, format, arg)
	wchar_t * __Q8_RESTRICT			s;
	size_t					n;
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	int	ret;			/* saved return value */

	if ( n > sizeof x_s )		/* too dangerous to proceed */
		{
		errno = EDOM;
		return -1;
		}

	if ( ! shrink(format, x_format) )
		return -1;

	ret = vsnprintf(x_s, n, x_format, arg);

	if ( ! expand(x_s, s) )
		return -1;

	return ret;
	}

int
vswscanf(s, format, arg)
	__Q8_CONST wchar_t * __Q8_RESTRICT	s;
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	int	ret;			/* saved return value */

	if ( ! shrink(format, x_format) )
		return -1;

	ret = vsscanf(x_s, x_format, arg);

	if ( ! expand(x_s, s) )		/* Risky Business */
		return -1;

	return ret;
	}

int
vwprintf(format, arg)
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	return vfwprintf(stdout, format, arg);
	}

int
vwscanf(format, arg)
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	va_list					arg;
	{
	return vfwscanf(stdin, format, arg);
	}

/* VARARGS */
int
wprintf(__Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
	__Q8_AList
       )__Q8_Dcl
	{
	__Q8_D(wchar_t		*format)
	__Q8_List(		ap)
	int			ret;	/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, wchar_t *, format)

	ret = vwprintf(format, ap);

	__Q8_End( ap )
	return ret;
	}

/* VARARGS */
int
wscanf(__Q8_T(__Q8_CONST wchar_t * __Q8_RESTRICT	format)
       __Q8_AList
      )	__Q8_Dcl
	{
	__Q8_D(wchar_t		*format)
	__Q8_List(		ap)
	int			ret;	/* saved return value */

	__Q8_Start(ap, format)
	__Q8_I(ap, wchar_t *, format)

	ret = vwscanf(format, ap);

	__Q8_End( ap )
	return ret;
	}

/*
	7.24.3	Wide character input/output functions
*/

wint_t
fgetwc(stream)
	__Q8_FILE	*stream;
	{
	int		ret;		/* saved return value */

	ret = getc(stream);		/* faster than fgetc */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

wchar_t *
fgetws(s, n, stream)
	wchar_t * __Q8_RESTRICT		s;
	int				n;
	__Q8_FILE * __Q8_RESTRICT	stream;
	{
	char				*ret;	/* saved return value */

	if ( n > sizeof x_s )		/* too dangerous to proceed */
		{
		errno = EDOM;
		return NULL;
		}

	ret = fgets(x_s, n, stream);

	if ( ! expand(x_s, s) )
		return NULL;

	return ret == x_s ? s : NULL;
	}

wint_t
fputwc(c, stream)
	wchar_t		c;
	__Q8_FILE	*stream;
	{
	int		ret;		/* saved return value */

	ret = putc(c, stream);		/* faster than fputc */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

int
fputws(s, stream)
	wchar_t * __Q8_RESTRICT		s;
	__Q8_FILE * __Q8_RESTRICT	stream;
	{
	int				ret;	/* saved return value */

	if ( ! shrink(s, x_s) )
		return -1;

	return fputs(x_s, stream);
	}

/*ARGSUSED*/
int
fwide(stream, mode)
	__Q8_FILE	*stream;
	int		mode;
	{
	return -1;			/* limited to byte orientation */
	}

wint_t
getwc(stream)
	__Q8_FILE	*stream;
	{
	int		ret;		/* saved return value */

	ret = getc(stream);		/* faster than fgetc */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

wint_t
getwchar()
	{
	int		ret;		/* saved return value */

	ret = getchar();		/* faster than fgetchar */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

wint_t
putwc(c, stream)
	wchar_t		c;
	__Q8_FILE	*stream;
	{
	int		ret;		/* saved return value */

	ret = putc(c, stream);		/* faster than fputc */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

wint_t
putwchar(c)
	wchar_t	c;
	{
	int	ret;			/* saved return value */

	ret = putchar(c);		/* faster than fputchar */
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

wint_t
ungetwc(c, stream)
	wchar_t		c;
	__Q8_FILE	*stream;
	{
	int		ret;		/* saved return value */

	ret = ungetc(c, stream);
	return ret == EOF ? WEOF : ret;	/* EOF, WEOF values may differ */
	}

/*
	7.24.4	General wide string utilities
*/

double
wcstod(nptr, endptr)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	{
	double					ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0.0;

	ret = strtod(x_s, &x_end);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}

float
wcstof(nptr, endptr)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	{
	float					ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0.0;

	ret = strtof(x_s, &x_end);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}

#if	!defined(__Q8_GT)
__Q8_GT
wcstold(nptr, endptr)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	{
	__Q8_GT					ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0.0;

	ret = strtold(x_s, &x_end);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}
#endif	/* !defined(__Q8_GT) */

long
wcstol(nptr, endptr, base)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	int					base;
	{
	long					ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0;

	ret = strtol(x_s, &x_end, base);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}

unsigned long
wcstoul(nptr, endptr, base)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	int					base;
	{
	unsigned long				ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0;

	ret = strtoul(x_s, &x_end, base);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}

#if	!defined(__Q8_QT)
__Q8_QT
wcstoll(nptr, endptr, base)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	int					base;
	{
	__Q8_QT					ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0;

	ret = strtoll(x_s, &x_end, base);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}

unsigned __Q8_QT
wcstoull(nptr, endptr, base)
	__Q8_CONST wchar_t * __Q8_RESTRICT	nptr;
	wchar_t ** __Q8_RESTRICT		endptr;
	int					base;
	{
	unsigned __Q8_QT			ret;	/* saved return value */
	char					*x_end;

	if ( ! shrink(nptr, x_s) )
		return 0;

	ret = strtoull(x_s, &x_end, base);
	*endptr = (wchar_t *)nptr + (x_end - x_s);
	return ret;
	}
#endif	/* !defined(__Q8_QT) */

/* The following don't map via shrink/expand because that's much too slow. */

wchar_t *
wcscpy(s1, s2)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	{
	wchar_t						*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL )
		return orig_s1;		/* robust */

	while ( (*s1++ = *s2++) != 0 )
		;

	return orig_s1;
	}

wchar_t *
wcsncpy(s1, s2, n)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	register size_t					n;
	{
	wchar_t						*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL || n == 0 )
		return orig_s1;		/* robust */

	for ( ; n > 0; --n )
		if ( (*s1++ = *s2++) == 0 )
			{
			--n;		/* not really necessary */
			break;
			}

	for ( ; n > 0; --n )
		*s1++ = 0;

	return orig_s1;
	}

wchar_t *
wmemcpy(s1, s2, n)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	register size_t					n;
	{
	wchar_t						*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL || n == 0 )
		return orig_s1;		/* robust */

	for ( ; n > 0; --n )
		*s1++ = *s2++;

	return orig_s1;
	}

wchar_t *
wmemmove(s1, s2, n)
	register wchar_t		*s1;
	register __Q8_CONST wchar_t	*s2;
	register size_t			n;
	{
	wchar_t				*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL || n == 0 )
		return orig_s1;		/* robust */

	/* XXX -- The following test works only within a flat address space! */
	if ( s2 >= s1 )
		for ( ; n > 0; --n )
			*s1++ = *s2++;
	else	{
		s1 += n;
		s2 += n;

		for ( ; n > 0; --n )
			*--s1 = *--s2;
		}

	return orig_s1;
	}

wchar_t *
wcscat(s1, s2)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	{
	wchar_t						*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL )
		return orig_s1;

	while ( *s1 != 0 )
		++s1;

	while ( (*s1++ = *s2++) != 0 )
		;

	return orig_s1;
	}

wchar_t *
wcsncat(s1, s2, n)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	register size_t					n;
	{
	wchar_t						*orig_s1 = s1;

	if ( s1 == NULL || s2 == NULL || n == 0 )
		return orig_s1;		/* robust */

	while ( *s1 != 0 )
		++s1;

	for ( ; n > 0; --n )
		if ( (*s1++ = *s2++) == 0 )
			return orig_s1;

	*s1 = 0;			/* if orig. n == 0, this is redundant */
	return orig_s1;
	}

int
wcscmp(s1, s2)
	register __Q8_CONST wchar_t	*s1;
	register __Q8_CONST wchar_t	*s2;
	{
	if ( s1 == s2 )
		return 0;		/* even for NULL pointers */

	if ( (s1 != NULL) != (s2 != NULL) )
		return s2 == NULL ? 1 : -1;	/* robust */

	for ( ; *s1 == *s2; ++s1, ++s2 )
		if ( *s1 == 0 )
			return 0;

	return *s1 - *s2;
	}

int
wcscoll(s1, s2)
	register __Q8_CONST wchar_t	*s1;
	register __Q8_CONST wchar_t	*s2;
	{
	return wcscmp(s1, s2);
	}

int
wcsncmp(s1, s2, n)
	register __Q8_CONST wchar_t	*s1;
	register __Q8_CONST wchar_t	*s2;
	size_t				n;
	{
	if ( n == 0 || s1 == s2 )
		return 0;		/* even for NULL pointers */

	if ( (s1 != NULL) != (s2 != NULL) )
		return s2 == NULL ? 1 : -1;	/* robust */

	for ( ; n > 0; ++s1, ++s2, --n )
		if ( *s1 != *s2 )
			return *s1 - *s2;
		else if ( *s1 == 0 )
			return 0;

	return 0;
	}

size_t
wcsxfrm(s1, s2, n)
	register wchar_t * __Q8_RESTRICT		s1;
	register __Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	register size_t					n;
	{
	if ( s1 == NULL || s2 == NULL || n == 0 )
		{
		if ( s1 != NULL )
			*s1 = 0;

		return 0;		/* robust */
		}

	wcsncpy(s1, s2, n);
	return wcslen(s1);		/* not very efficient */
	}

int
wmemcmp(s1, s2, n)
	register __Q8_CONST wchar_t	*s1;
	register __Q8_CONST wchar_t	*s2;
	size_t				n;
	{
	if ( n == 0 || s1 == s2 )
		return 0;		/* even for NULL pointers */

	if ( (s1 != NULL) != (s2 != NULL) )
		return s2 == NULL ? 1 : -1;	/* robust */

	for ( ; n > 0; ++s1, ++s2, --n )
		if ( *s1 != *s2 )
			return *s1 - *s2;

	return 0;
	}

wchar_t *
wcschr(s, c)
	__Q8_CONST wchar_t	*s;
	wchar_t			c;
	{
	if ( s != NULL )
		for ( ; *s != c; ++s )
			if ( *s == 0 )
				return NULL;

	return (wchar_t *)s;
	}

size_t
wcscspn(s1, s2)
	__Q8_CONST wchar_t		*s1;
	__Q8_CONST wchar_t		*s2;
	{
	register __Q8_CONST wchar_t	*s1p;
	register __Q8_CONST wchar_t	*s2p;

	if ( s1 == NULL || s2 == NULL )
		return wcslen(s1);	/* robust */

	for ( s1p = s1; *s1p != 0 ; ++s1p )
		for ( s2p = s2; *s2p != 0; ++s2p )
			if ( *s2p == *s1p )
				return s1p - s1;

	return s1p - s1;
	}

wchar_t *
wcspbrk(s1, s2)
	register __Q8_CONST wchar_t	*s1;
	__Q8_CONST wchar_t		*s2;
	{
	register __Q8_CONST wchar_t	*s2p;

	if ( s1 == NULL || s2 == NULL )
		return NULL;		/* robust */

	for ( ; *s1 != 0 ; ++s1 )
		for ( s2p = s2; *s2p != 0; ++s2p )
			if ( *s2p == *s1 )
				return (wchar_t *)s1;

	return NULL;
	}

wchar_t *
wcsrchr(s, c)
	register __Q8_CONST wchar_t	*s;
	register wchar_t		c;
	{
	register __Q8_CONST wchar_t	*ret = NULL;

	if ( s != NULL )
		/* do-while is necessary to handle the case c==0 */
		do
			if ( *s == c )
				ret = s;
		while ( *s++ != 0 );

	return (wchar_t *)ret;
	}

size_t
wcsspn(s1, s2)
	__Q8_CONST wchar_t		*s1;
	__Q8_CONST wchar_t		*s2;
	{
	register __Q8_CONST wchar_t	*s1p;
	register __Q8_CONST wchar_t	*s2p;

	if ( s1 == NULL || s2 == NULL )
		return 0;		/* robust */

	for ( s1p = s1; *s1p != 0 ; ++s1p )
		for ( s2p = s2; *s2p != *s1p; ++s2p )
			if ( *s2p == 0 )
				return s1p - s1;

	return s1p - s1;
	}

/*
	My usual strstr() (based on Sunday's variation of Boyer-Moore)
	unfortunately requires an inordinately large shift table for
	wide characters.  In order not to trip you up should that
	occasion arise, I substituted a fine-tuned brute-force search.
	It's still much faster than most implementations one encounters.
*/

wchar_t *
wcsstr(s1, s2)
	register __Q8_CONST wchar_t	*s1;
	__Q8_CONST wchar_t		*s2;
	{
	register __Q8_CONST wchar_t	*t;
	register __Q8_CONST wchar_t	*s2p = s2;

	if ( s2p == NULL || *s2p == 0 || s1 == NULL )
		return (wchar_t *)s1;	/* robust special cases */

	for ( ; *s1 != 0; ++s1 )
		{
		if ( *s2p == *s1 )	/* quick initial-match test */
			{
			/* Although it is tempting, we cannot omit the test
			   for 0 in the loop, because the match may occur
			   at the very end of s1[], in which case we'd keep
			   on going past the end of both arrays.
			*/
			for ( t = s1; *++s2p == *++t; )
				if ( *s2p == 0 )	/* match at end */
					return (wchar_t *)s1;

			if ( *s2p == 0 )
				return (wchar_t *)s1;	/* match elsewhere */

			s2p = s2;	/* reset pattern for next iteration */
			}
		}

	return NULL;			/* no match (and s2 isn't empty) */
	}

wchar_t *
wcstok(s1, s2, ptr)
	register wchar_t * __Q8_RESTRICT	s1;
	__Q8_CONST wchar_t * __Q8_RESTRICT	s2;
	wchar_t ** __Q8_RESTRICT		ptr;
	{
	register wchar_t			*etok;

	if ( s1 != NULL )
		*ptr = s1;		/* save for later continued use */
	else if ( (s1 = *ptr) == NULL )	/* try to continue scan */
		return NULL;		/* no more tokens */

	s1 += wcsspn(s1, s2);		/* skip over separators */

	if ( *s1 == 0 )
		return NULL;		/* no more tokens; preserve ptr */

	/* valid token starts at current s1 */

	if ( (etok = wcspbrk(s1, s2)) == NULL )	/* find end of token */
		*ptr = NULL;		/* this is the last token */
	else	{
		*etok = 0;		/* terminate token wide string */
		*ptr = etok + 1;	/* next time start just past token */
		}

	return s1;			/* start of valid token */
	}

wchar_t *
wmemchr(s, c, n)
	register __Q8_CONST wchar_t	*s;
	register wchar_t		c;
	register size_t			n;
	{
	if ( s != NULL )
		for ( ; n > 0; ++s, --n )
			if ( *s == c )
				return (wchar_t *)s;

	return NULL;
	}

size_t
wcslen(s)
	register __Q8_CONST wchar_t	*s;
	{
	__Q8_CONST wchar_t		*orig_s = s;

	if ( s == NULL )
		return 0;

	while ( *s != 0 )
		++s;

	return s - orig_s;
	}

wchar_t *
wmemset(s, c, n)
	register wchar_t	*s;
	register wchar_t	c;
	register size_t		n;
	{
	wchar_t			*orig_s = s;

	if ( s != NULL )
		for ( ; n > 0; --n )
			*s++ = c;

	return orig_s;
	}

/*
	7.24.5	Wide character time conversion functions
*/

size_t
wcsftime(s, maxsize, format, timeptr)
	wchar_t * __Q8_RESTRICT			s;
	size_t					maxsize;
	__Q8_CONST wchar_t * __Q8_RESTRICT	format;
	__Q8_CONST struct tm * __Q8_RESTRICT	timeptr;
	{
	int					ret;	/* saved return value */

	if ( maxsize > sizeof x_s )	/* too dangerous to proceed */
		{
		errno = EDOM;
		return 0;
		}

	if ( ! shrink(format, x_format) )
		return 0;

	ret = strftime(x_s, maxsize, x_format, timeptr);

	if ( ! expand(x_s, s) )
		return 0;

	return ret;
	}

/*
	7.24.6	Extended multibyte/wide character conversion utilities

	In this *minimal implementation*, all single-byte values are valid,
	except possibly for EOF on platforms where sizeof(char)==sizeof(int).
*/

wint_t
btowc(c)
	int	c;
	{
	if ( c == EOF || (unsigned char)c != (unsigned int)c )	/* knothole */
		return WEOF;
	else
		return (wint_t)(unsigned char)c;
	}

int
wctob(c)
	wint_t	c;
	{							/* knothole: */
	if ( c == WEOF || (unsigned char)c != (unsigned __Q8_MT)c )
		return EOF;
	else
		return (int)(unsigned char)c;
	}

int
mbsinit(ps)
	__Q8_CONST mbstate_t *ps;
	{
	return 1;			/* don't have shift states */
	}

size_t
mbrlen(s, n, ps)
	__Q8_CONST char * __Q8_RESTRICT	s;
	size_t				n;
	mbstate_t * __Q8_RESTRICT	ps;
	{
	return mbrtowc((wchar_t *)NULL, s, n, ps);	/* ps ignored */
	}

size_t
mbrtowc(pwc, s, n, ps)
	wchar_t * __Q8_RESTRICT		pwc;
	__Q8_CONST char * __Q8_RESTRICT	s;
	size_t				n;
	mbstate_t * __Q8_RESTRICT	ps;		/* ignored */
	{
	if ( s == NULL )
		{
		pwc = NULL;
		s = (__Q8_CONST char *)"";
		n = 1;
		}

	if ( n == 0 )
		return (size_t)-2;

	if ( pwc != NULL )
		*pwc = (wchar_t)(unsigned char)*s;

	return *s == 0 ? 0 : 1;
	}

size_t
wcrtomb(s, wc, ps)
	char * __Q8_RESTRICT		s;
	wchar_t				wc;
	mbstate_t * __Q8_RESTRICT	ps;		/* ignored */
	{
	register int			c;
	char				dummy;

	if ( s == NULL )
		{
		s = &dummy;
		wc = 0;
		}

	if ( (c = wctob(wc)) == EOF )
		{
		errno = EILSEQ;
		return (size_t)-1;
		}

	*(unsigned char *)s = (unsigned char)c;
	return 1;
	}

size_t
mbsrtowcs(dst, src, len, ps)
	wchar_t * __Q8_RESTRICT			dst;
	__Q8_CONST char ** __Q8_RESTRICT	src;
	size_t					len;
	mbstate_t * __Q8_RESTRICT		ps;
	{
	register size_t				ret;	/* from mbrtowc */
	register size_t				n = 0;	/* # converted */

	if ( src == NULL || *src == NULL )	/* undefined behavior */
		return 0;

	while ( n < len
	     && (ret = mbrtowc(dst, *src, dst == NULL ? MB_CUR_MAX : len - n, ps
			      )				/* ps ignored */
		) != 0
	     && ret != (size_t)-2 && ret != (size_t)-1
	      )	{
		++dst;

		if ( *src != NULL )
			*src += ret;

		n += ret;
		}

	if ( dst != NULL && n < len && ret == 0 )
		*src = (char *)NULL;

	return n;
	}

size_t
wcsrtombs(dst, src, len, ps)
	char * __Q8_RESTRICT			dst;
	__Q8_CONST wchar_t ** __Q8_RESTRICT	src;
	size_t					len;
	mbstate_t * __Q8_RESTRICT		ps;
	{
	register size_t				ret;	/* from mbrtowc */
	register size_t				n = 0;	/* # converted */

	if ( src == NULL || *src == NULL )	/* undefined behavior */
		return 0;

	while ( n < len
	     && (ret = wcrtomb(dst, **src, ps)) != 0	/* ps ignored */
	     && ret != (size_t)-2 && ret != (size_t)-1
	      )	{
		++dst;

		if ( *src != NULL )
			*src += ret;

		n += ret;
		}

	if ( dst != NULL && n < len && ret == 0 )
		*src = (wchar_t *)NULL;

	return n;
	}
END OF wchar.c
echo 'wctype.c' 1>&2
cat >'wctype.c' <<'END OF wctype.c'
/*
	wctype -- wide character classification and mapping utilities

	This source code has been placed into the PUBLIC DOMAIN by its author.

	last edit:	1999/11/05	gwyn@arl.mil

	Implements subclause 7.25 of ISO/IEC 9899:1999 (E).

	This particular implementation requires the matching <wctype.h>.

	This is a minimal implementation for environments where
	internationalization is not considered important.

	It supports an encoding where all char codes are mapped
	to the *same* code values within a wchar_t or wint_t,
	so long as no other wchar_t codes are used by the program.

	XXX -- UNTESTED -- XXX
*/

#include	<ctype.h>
#include	<errno.h>
#include	<string.h>

#include	<wctype.h>		/* defines __Q8_CONST and __Q8_PARAMS */

/*
	7.25.2	Wide character classification utilities
*/

int
iswalnum(wc)
	wint_t	wc;
	{
	return isalnum((int)(unsigned char)wc);
	}

int
iswalpha(wc)
	wint_t	wc;
	{
	return isalpha((int)(unsigned char)wc);
	}

int
iswblank(wc)
	wint_t	wc;
	{
	return isblank((int)(unsigned char)wc);
	}

int
iswcntrl(wc)
	wint_t	wc;
	{
	return iscntrl((int)(unsigned char)wc);
	}

int
iswdigit(wc)
	wint_t	wc;
	{
	return isdigit((int)(unsigned char)wc);
	}

int
iswgraph(wc)
	wint_t	wc;
	{
	return isgraph((int)(unsigned char)wc);
	}

int
iswlower(wc)
	wint_t	wc;
	{
	return islower((int)(unsigned char)wc);
	}

int
iswprint(wc)
	wint_t	wc;
	{
	return isprint((int)(unsigned char)wc);
	}

int
iswpunct(wc)
	wint_t	wc;
	{
	return ispunct((int)(unsigned char)wc);
	}

int
iswspace(wc)
	wint_t	wc;
	{
	return isspace((int)(unsigned char)wc);
	}

int
iswupper(wc)
	wint_t	wc;
	{
	return isupper((int)(unsigned char)wc);
	}

int
iswxdigit(wc)
	wint_t	wc;
	{
	return isxdigit((int)(unsigned char)wc);
	}

/*
	wctype() usually encodes properties as ORed bit combinations;
	for this *minimal implementation* I can take a lazy approach.	
*/

static struct
	{
	__Q8_CONST char	*name;
	int		(*func)__Q8_PARAMS((int));
	}	cmap[] =
	{
	"alnum",	iswalnum,
	"alpha",	iswalpha,
	"blank",	iswblank,
	"cntrl",	iswcntrl,
	"digit",	iswdigit,
	"graph",	iswgraph,
	"lower",	iswlower,
	"print",	iswprint,
	"punct",	iswpunct,
	"space",	iswspace,
	"upper",	iswupper,
	"xdigit",	iswxdigit
	};
#define	NCMAP	(sizeof cmap / sizeof cmap[0])

int
iswctype(wc, desc)
	wint_t		wc;
	wctype_t	desc;
	{
	register int	i;

	if ( desc <= 0 || desc > NCMAP )	/* undefined behavior */
		{
		errno = EDOM;	
		return 0;		/* a form of not having the property */
		}

	return cmap[desc-1].func(wc);
	}

wctype_t				/* returns map index + 1 */
wctype(property)
	__Q8_CONST char	*property;
	{
	register int	i;

	for ( i = 0; i < NCMAP; ++i )
		if ( strcmp(property, cmap[i].name) == 0 )
			return i+1;

	return 0;			/* indicates "not valid" */
	}

/*
	7.25.3	Wide character case mapping utilities
*/

wint_t
towlower(wc)
	wint_t	wc;
	{
	return tolower((int)(unsigned char)wc);
	}

wint_t
towupper(wc)
	wint_t	wc;
	{
	return toupper((int)(unsigned char)wc);
	}

/*
	For this *minimal implementation* I can take a lazy approach.	
*/

static struct
	{
	__Q8_CONST char	*name;
	int		(*func)__Q8_PARAMS((int));
	}	tmap[] =
	{
	"lower",	towlower,
	"upper",	towupper
	};
#define	NTMAP	(sizeof tmap / sizeof tmap[0])

wint_t
iswctrans(wc, desc)
	wint_t		wc;
	wctrans_t	desc;
	{
	register int	i;

	if ( desc <= 0 || desc > NTMAP )	/* undefined behavior */
		{
		errno = EDOM;	
		return 0;		/* a form of not having the property */
		}

	return tmap[desc-1].func(wc);
	}

wctrans_t				/* returns map index + 1 */
wctrans(property)
	__Q8_CONST char	*property;
	{
	register int	i;

	for ( i = 0; i < NTMAP; ++i )
		if ( strcmp(property, tmap[i].name) == 0 )
			return i+1;

	return 0;			/* indicates "not valid" */
	}
END OF wctype.c

