<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995, 1996 by Steve Summit. -->
<!-- This material may be freely redistributed and used -->
<!-- but may not be republished or sold without permission. -->
<html>
<head>
<link rev="owner" href="mailto:scs@eskimo.com">
<link rev="made" href="mailto:scs@eskimo.com">
<title>Chapter 4: Functions and Program Structure</title>
<link href="sx6h.html" rev=precedes>
<link href="sx7a.html" rel=precedes>
<link href="top.html" rev=subdocument>
</head>
<body>
<H1>Chapter 4: Functions and Program Structure</H1>

page 67
<p>Deep paragraph:
<blockquote>Functions break large computing tasks into smaller ones,
and enable people to build on what others have done
instead of starting over from scratch.
Appropriate functions hide details of operation
from parts of the program that don't need to know about them,
thus clarifying the whole,
and easing the pain of making changes.
</blockquote>Functions are probably the most important weapon
in our battle against software complexity.
You'll want to learn when it's appropriate
to break processing out into functions
(and also when it's not),
and <em>how</em> to set up function interfaces
to best achieve the qualities mentioned above:
reusability,
information hiding,
clarity,
and
maintainability.
</p><p>The quoted sentences above
show that a function does more than just save typing:
a well-defined function can be re-used later,
and eases the mental burden of thinking about a complex program
by freeing us from having to worry about all of it at once.
For a well-designed function,
at any one time,
we should either have to think about:
<OL><li>that function's internal implementation
(when we're writing or maintaining it);
or
<li>a particular call to the function
(when we're working with code which uses it).
</OL>But we should <em>not</em> have to
think about the internals when we're calling it,
or
about the callers when we're implementing the internals.
(We should perhaps think about the callers just enough to 
ensure that the function we're designing will be easy to call,
and that
we aren't accidentally setting things up
so that callers will have to think about any internal details.)
</p><p>Sometimes,
we'll write a function which we only call once,
just because breaking it out into a function
makes things clearer and easier.
</p><p>Deep sentence:
<blockquote>C has been designed to make functions efficient and easy to use;
C programs generally consist of many small functions
rather than a few big ones.
</blockquote>Some people worry about ``function call overhead,''
that is,
the work that a computer has to do to set up and return from a function call,
as opposed to simply doing the function's statements in-line.
It's a risky thing to worry about,
though,
because as soon as you start worrying about it,
you have a bit of a disincentive to use functions.
If you're reluctant to use functions,
your programs will probably be
bigger and more complicated and harder to maintain
(and perhaps, for various reasons, actually <em>less</em> efficient).
</p><p>The authors choose not to get involved with
the system-specific aspects of separate compilation,
but we'll take a stab at it here.
We'll cover two possibilities,
depending on whether you're using a traditional command-line compiler
or a newer integrated development environment (IDE)
or other graphical user interface (GUI) compiler.
</p><p>When using a command-line compiler,
there are usually two main steps involved
in building an executable program
from one or more source files.
First,
each source file is compiled,
resulting in an <dfn>object file</dfn>
containing the machine instructions
(generated by the compiler)
corresponding to the code in that source file.
Second,
the various object files are <dfn>linked</dfn> together,
with each other and with <dfn>libraries</dfn>
containing code for functions which you did not write

(such as <TT>printf</TT>),
to produce a final, executable program.
</p><p>Under Unix, the <TT>cc</TT> command can perform one or both steps.
So far, we've been using extremely simple invocations of 
<TT>cc</TT> such as
<pre>	cc hello.c
</pre>(section 1.1, page 6).
This invocation compiles a single source file,
links it,
and places the executable
(somewhat inconveniently)
in a file named <TT>a.out</TT>.
</p><p>Suppose we have a program which we're trying to build
from three separate source files,
<TT>x.c</TT>, <TT>y.c</TT>, and <TT>z.c</TT>.
We could compile all three of them,
and link them together,
all at once,
with the command
<pre>	cc x.c y.c z.c
</pre>(see also page 70).
Alternatively,
we could compile them separately:
the <TT>-c</TT> option to <TT>cc</TT> tells it to compile only,
but not to link.
Instead of building an executable,
it merely creates an object file,
with a name ending in <TT>.o</TT>,
for each source file compiled.
So the three commands
<pre>	cc -c x.c
	cc -c y.c
	cc -c y.c
</pre>would compile <TT>x.c</TT>, <TT>y.c</TT>, and <TT>z.c</TT>
and create object files <TT>x.o</TT>, <TT>y.o</TT>, and <TT>z.o</TT>.
Then, the three object files could be linked together using
<pre>	cc x.o y.o z.o
</pre>When the <TT>cc</TT> command is given an <TT>.o</TT> file,
it knows that it does not have to compile it
(it's an object file, already compiled);
it just sends it through to the link process.
</p><p>Here we begin to see one of the advantages of separate compilation:
if we later make a change to <TT>y.c</TT>,
only it will need recompiling.
(At some point you may want to learn about a program called <TT>make</TT>,
which keeps track of which parts need recompiling
and issues the appropriate commands for you.)
</p><p>Above we mentioned that the second,
linking step also involves pulling in library functions.
Normally, the functions from the Standard C library are linked 
in automatically.
Occasionally, you must request a library manually;
one common situation under Unix
is that certain math routines are in a separate math library,
which is requested by using <TT>-lm</TT> on the command line.
Since the libraries must typically be searched <em>after</em> 
your program's own object files are linked
(so that the linker knows which library functions your program uses),
any <TT>-l</TT> option must appear
<em>after</em> the names of your files on the command line.
For example,
to link the object file <TT>mymath.o</TT>
(previously compiled with <TT>cc -c mymath.c</TT>)
together with the math library,
you might use
<pre>	cc mymath.o -lm
</pre></p><p>Two final notes on the Unix <TT>cc</TT> command:
if you're tired of using the nonsense name <TT>a.out</TT>
for all of your programs,
you can use <TT>-o</TT> to give another name to the output (executable) file:
<pre>	cc -o hello hello.c
</pre>would create an executable file named <TT>hello</TT>,
not <TT>a.out</TT>.
Finally,
everything we've said about <TT>cc</TT>
also applies to most other Unix C compilers.
Many of you will be using <TT>acc</TT>
(a semistandard name for a version of <TT>cc</TT>
which <em>does</em> accept ANSI Standard C)
or <TT>gcc</TT>
(the FSF's GNU C Compiler,
which also accepts ANSI C and is free).
</p><p>There are command-line compilers for MS-DOS systems which work similarly.
For example, the Microsoft C compiler comes with a <TT>CL</TT> 
(``compile and link'') command,
which works almost the same as Unix <TT>cc</TT>.
You can compile and link in one step:
<pre>	cl hello.c
</pre>or you can compile only:
<pre>	cl /c hello.c
</pre>creating an object file named <TT>hello.obj</TT> which you can link later.

</p><p>The preceding has all been about command-line compilers.
If you're using some kind of integrated development environment,
such as Turbo C or the Microsoft Programmer's Workbench or Think C,
most of the mechanical details are taken care of for you.
(There's also less I can say here about these environments,
because they're all different.)
Typically there's a way to specify the list of files (modules)
which make up your project,
and a single ``build'' button which does whatever's required
to build (and perhaps even execute) your program.
<br></p><p><a href="sx7a.html" rel=subdocument>section 4.1: Basics of Functions</a></p>
<p><a href="sx7b.html" rel=subdocument>section 4.2: Functions Returning Non-Integers</a></p>
<p><a href="sx7c.html" rel=subdocument>section 4.3: External Variables</a></p>
<p><a href="sx7d.html" rel=subdocument>section 4.4: Scope Rules</a></p>
<p><a href="sx7e.html" rel=subdocument>section 4.5: Header Files</a></p>
<p><a href="sx7f.html" rel=subdocument>section 4.6: Static Variables</a></p>
<p><a href="sx7g.html" rel=subdocument>section 4.7: Register Variables</a></p>
<p><a href="sx7h.html" rel=subdocument>section 4.8: Block Structure</a></p>
<p><a href="sx7i.html" rel=subdocument>section 4.9: Initialization</a></p>
<p><a href="sx7j.html" rel=subdocument>section 4.10: Recursion</a></p>
<p><a href="sx7k.html" rel=subdocument>section 4.11: The C Preprocessor</a></p>
<p><a href="sx7l.html" rel=subdocument>section 4.11.1: File Inclusion</a></p>
<p><a href="sx7m.html" rel=subdocument>section 4.11.2: Macro Substitution</a></p>
<p><a href="sx7n.html" rel=subdocument>section 4.11.3: Conditional Inclusion</a></p>
<hr>
<p>
Read sequentially:
<a href="sx6h.html" rev=precedes>prev</a>
<a href="sx7a.html" rel=precedes>next</a>
<a href="top.html" rev=subdocument>up</a>
<a href="top.html">top</a>
</p>
<p>
This page by <a href="../../index.html">Steve Summit</a>
// <a href="copyright.html">Copyright</a> 1995, 1996
// <a href="mailto:scs@eskimo.com">mail feedback</a>
<!-- patched 2023-04-03 per &lt;20230007141207.davidapps3@gmail.com&gt; -->
</p>
</body>
</html>
