<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995, 1996 by Steve Summit. -->
<!-- This material may be freely redistributed and used -->
<!-- but may not be republished or sold without permission. -->
<html>
<head>
<link rev="owner" href="mailto:scs@eskimo.com">
<link rev="made" href="mailto:scs@eskimo.com">
<title>World Wide Web CGI (Common Gateway Interface) Programming in C</title>
</head>
<body>
<p>When the contents of a web page are not static,
but rather are generated on-the-fly
as
the page is fetched,
a program runs to generate the contents.
When that program requires input from the client who is actually
fetching the page
(input such as the selections made when filling out a form)
that input is propagated to the program via the Common Gateway Interface,
or CGI.
</p><p>Programs which generate
web pages
on-the-fly
(commonly called ``CGI programs'')
can be written in any language.
Perl, an interpreted or scripting language,
is currently the language of choice for writing CGI programs
(also called ``CGI scripts''
if they're written in a scripting language),
but it's eminently feasible,
not difficult,
and possibly advantageous to write them in C,
which the rest of this handout will describe how to do.
</p><p>The basic operation of a CGI program is quite simple.
Since its job is to generate
a web page
on the fly,
that's just what it must do,
by ``printing'' text to its standard output.
When we're writing a CGI program in C,
therefore,
we'll be calling <TT>printf</TT> a lot,
to generate the text we want the virtual page
(that is, the one we're building)
to contain.
Some of the <TT>printf</TT> calls will print constant or
``boilerplate'' text;
for example,
the first few lines of almost any C-written CGI program will be
along the lines of
<pre>
	printf("Content-Type: text/html\n\n");
	printf("&lt;html&gt;\n");
	printf("&lt;head&gt;\n");
</pre>
The <TT>&lt;html&gt;</TT> and <TT>&lt;head&gt;</TT> tags are the ones
that appear at the beginning of
any HTML page.
The first line informs the receiving browser that the page
<em>is</em> encoded in HTML.
For static pages,
that line is automatically added by the web server
(often as a function of the file name,
i.e. if it ends in <TT>.html</TT> or perhaps <TT>.htm</TT>),
which is why you never see it in static HTML files.
But since CGI programs are generating pages on the fly,
they must include that line explicitly.
(The content type is almost invariably <TT>text/html</TT>,
unless you're getting really fancy and generating images on the fly.
Notice that the first, <TT>Content-Type:</TT> line
is followed by <em>two</em> newlines,
creating a blank line which separates this ``header''
from the rest of the HTML document.)
</p><p>Of course,
not all of the <TT>printf</TT> calls will print constant text
(or else the resulting page will essentially be static,
and needn't have been generated by a CGI program at all).
Therefore,
many of the <TT>printf</TT> calls
will typically insert some variable text into the output.
For example,
if <TT>title</TT> is a string variable
containing a title which has been generated for the generated page,
one of the next lines in the CGI program might be
<pre>	printf("&lt;title&gt;%s&lt;/title&gt;\n", title);
</pre></p><p>Many of the decisions controlling the output of a particular run
of a CGI program will of course be made based on selections made
by the requesting user (perhaps by having filled out a form).
The most important thing to understand about CGI programming
(in fact,
the very aspect of CGI programming which gives it its name,
that is,
the aspect which the CGI
specification specifies)
is the set of mechanisms by which the user's choices
and other information
are made available to a CGI program.
</p><p>One mechanism
is
by means of
the <dfn>environment</dfn>.
The environment is a set of variables maintained,
not by any one program,
but by the operating system itself,
on behalf of a user or process.
For example, on MS-DOS and Unix systems,
the <TT>PATH</TT> variable contains a list of directories
to be searched for executable programs.
On Unix systems,
other common environment variables are
<TT>HOME</TT> (the user's home directory),
<TT>TERM</TT> (the user's terminal type)
and
<TT>MAIL</TT> (the user's electronic mailbox).
</p><p>Environment variables are completely separate from
the variables used in programs written in typical programming languages,
such as C.
When a C program wishes to access an environment variable,
it does <em>not</em> simply declare a C variable of the same name,
and hope that the value will somehow be magically linked into the program.
Instead, a C program must call the library function <TT>getenv</TT>
to fetch environment variables.
The <TT>getenv</TT> function accepts a string
which is the name of an environment variable to be fetched,
and returns a string which is the contents of the variable.
(Environment variables are always strings.)
If the requested environment variable does not exist,
<TT>getenv</TT> returns a null pointer, instead.
</p><p>For example, here is a scrap of code which would print out
a user's terminal type
(presumably on a Unix system):
<pre>	char *termtype;
	termtype = getenv("TERM");
	if(termtype != NULL)
		printf("your terminal type is \"%s\"\n", termtype);
	else	printf("no terminal type defined\n");
</pre>Two things to be careful of when calling <TT>getenv</TT> are
<OL><li>As already mentioned,
it returns a null pointer if the requested variable doesn't exist,
and this null pointer return must always be checked for;
and
<li>You shouldn't modify
(scribble on)
the string it returns,
that is,
you should treat it as a constant string.
</OL></p><p></p><p>A web daemon (a.k.a. HTTP server or httpd) which supports CGI
passes a host of environment variables to a CGI program.
Many of them are somewhat esoteric,
and this handout will not describe them all.
(See the References at the end.)
The ones which are most likely to be of use to ordinary CGI
programs are:
<UL><li><cw>REQUEST_METHOD</>
The specific request that the client used to fetch the page
(that is, to invoke the CGI program):
usually <TT>GET</TT> or <TT>POST</TT>.
<li><cw>PATH_INFO</>
Any extra path information that appeared <em>after</em> the
program name in the URL that invoked this CGI program.
<li><cw>PATH_TRANSLATED</>
The path information from <TT>PATH_INFO</TT>,
with any ``virtual-to-physical mapping''
performed on it.
<li><cw>SCRIPT_NAME</>
The actual name of the CGI program that is running,
as a URL,
in case
the generated page
needs to reference itself.
<li><cw>QUERY_STRING</>
The query being performed by the user.
In the case of form processing,
the <TT>QUERY_STRING</TT> variable contains encoded information
about each field filled in by the user.
(We'll have <em>much</em> more to say about <TT>QUERY_STRING</TT> in a bit.)
<li><cw>REMOTE_HOST</>
The hostname of the client (if known).
<li><cw>CONTENT_TYPE</>
The HTTP/MIME content type of the attached information,
for queries (such as <TT>POST</TT>) with attached information.
<li><cw>CONTENT_LENGTH</>
The size of the attached information, if any.
<li><cw>HTTP_USER_AGENT</>
An indication of the name and version of the client browser in use.
<li><cw>HTTP_ACCEPT</>
The specification by the client browser of which document types
it will accept.
</UL></p><p>For simple uses of the above-listed variables,
it suffices to call <TT>getenv</TT>
and then inspect the returned string (if any).
For example,
you could generate different output depending on which browser a
user is using with code like this:
<pre>	char *browser = getenv("HTTP_USER_AGENT");
	if(browser != NULL &amp;&amp; strstr(browser, "Mozilla") != NULL)
		printf("I see you're using Netscape, just like everyone else.\n");
	else	printf("Congratulations on your daring choice of browser!\n");
</pre>(However, this is not a terribly good example.
Building knowledge of specific browsers into web pages and servers
is a risky proposition,
as there will always be more browsers out there than you've heard of.
Doing so also flies in the face of the notion of interoperability,
which is one of the very foundations of the Internet.
If the protocols are well designed,
and if all clients and servers implement them properly,
no specific server should ever need to know
what kind of client it's talking to,
or vice versa.)
</p><p>Environment variables are not the only input mechanism available in CGI.
It's also possible for input to arrive via the standard input,
to be read with <TT>getchar</TT> or the like.
In fact, in production CGI programming,
the standard input is heavily used,
because it's where the user's query information arrives
when the retrieval method
(that is, <TT>REQUEST_METHOD</TT>)
is <TT>POST</TT>.
Because it allows essentially unlimited-size requests,
<TT>POST</TT> is strongly recommended as the request method for HTML forms.
It will be a bit easier, however,
to describe and demonstrate the processing of query information
if we restrict ourselves to the environment variables
(specifically, <TT>QUERY_STRING</TT>),
so our examples will use the request method of <TT>GET</TT>
(which causes request information to be sent as a query string
rather than on standard input).
</p><p>For simple queries (such as <TT>&lt;ISINDEX&gt;</TT> searches),
the <TT>QUERY_STRING</TT> environment variable simply contains the
query string
(although it will have been encoded;
see below).
For more complicated queries,
however,
and in particular for queries resulting from filled-out and
submitted HTML forms,
the value of the <TT>QUERY_STRING</TT> variable is a complicated
string,
with substructure,
containing potentially many pieces of information.
The basic syntax of the <TT>QUERY_STRING</TT> string in this case is
<pre>	name=value&amp;name=value&amp;name=value
</pre>The string is a series of <TT>name=value</TT> pairs,
separated by ampersand characters.
Each name is the <TT>name</TT> attribute from one of the
input
elements in the form;
the <TT>value</TT> is either
the text typed by the user
for an element with a <TT>type</TT> attribute of
<TT>text</TT>, <TT>password</TT>, or <TT>textarea</TT>,
or one of the <TT>&lt;option&gt;</TT> values
from a <TT>&lt;select&gt;</TT> element,
or the <TT>value</TT> attribute
of a selected element of type <TT>checkbox</TT> or <TT>radio</TT>
(or ``<TT>on</TT>''
for selected <TT>checkbox</TT> elements without <TT>value</TT> attributes).
</p><p>What if some text typed by the user
(that is, one of the <TT>value</TT>s)
happened to contain an <TT>=</TT> or <TT>&amp;</TT> character?
That would certainly screw up the syntax of the
<TT>QUERY_STRING</TT> string.
To guard against this problem,
and to keep the query string a single string,
it is encoded in two ways:
<OL><li>All spaces are replaced by <TT>+</TT> signs.
<li>All <TT>=</TT> and <TT>&amp;</TT> characters,
and any other special characters
(such as <TT>+</TT> and <TT>%</TT> characters)
are replaced by a percent sign (<TT>%</TT>)
followed by a two-digit hexadecimal number representing the
character's value in ASCII.
For example,
<TT>=</TT> is represented by <TT>%3d</TT>,
<TT>&amp;</TT> is represented by <TT>%26</TT>,
<TT>+</TT> is represented by <TT>%2b</TT>,
<TT>%</TT> is represented by <TT>%25</TT>,
and
<TT>~</TT> is often represented by <TT>%7e</TT>.
</OL>A CGI program must arrange to decode
(that is, undo)
these encodings before attempting to make further use
of the information in the <TT>QUERY_STRING</TT> variable.
</p><p>We're going to write a function
to centralize the parsing of
the <TT>QUERY_STRING</TT> variable,
for three reasons:
<OL><li>Splitting the string into name/value pairs
is a bit of a nuisance,
and is best isolated from the calling code;
<li>Decoding the <TT>+</TT> and <TT>%</TT> encodings
is a bit of a nuisance,
and is best isolated from the calling code;
and
<li>If we do it right,
we can arrange that improving our programs later
to use <TT>POST</TT> instead of <TT>GET</TT>
(that is,
to retrieve query information from the standard input
rather than the <TT>QUERY_STRING</TT> variable)
will require rewriting only this one function,
not the rest of the program.
</OL></p><p>The function we'll write is very simple;
its prototype is
<pre>	char *cgigetval(char *);
</pre>You hand it the <TT>name</TT> of the value you're looking for,
and it either returns the (properly decoded) value,
or a null pointer if no value by that name could be found.
(This might happen
if the program or the calling form were improperly written,
or
if the user hadn't typed anything or selected anything in
the requested input element.)
The strings returned by <TT>cgigetval</TT> are in dynamically-allocated memory,
that is,
<TT>cgigetval</TT> calls <TT>malloc</TT> to get storage
for each string it returns,
and returns a pointer.
This means that
<OL><li>the caller doesn't have to worry about providing a buffer or anything;
<li>the caller can modify the string
(as long as no attempt is made to extend it);
but
<li>the caller is responsible for freeing the memory,
if necessary.
</OL>(In some programs,
the last requirement could be a significant problem;
it might be a real nuisance for the caller to have to remember
to free the returned pointers,
and the program might run out of memory if callers forgot.
In this case, however,
it's not likely that we'll run out of memory in any case--CGI
programs are and should be short-lived--and the advantages of
having <TT>cgigetval</TT> return dynamically-allocated memory will
be real conveniences.)
</p><p>Before presenting the innards of the <TT>cgigetval</TT> function,
let's look at how we'll use it in a
(contrived, but working and illustrative)
real example.
</p><p>Our example CGI program will be called by this web page:
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;CGI test page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="/cgi-bin/sillycgi" method="get"&gt;
&lt;p&gt;
This page demonstrates simple form and CGI processing.
&lt;p&gt;
Enter a line of text here:
&lt;input type="text" name="textfield"&gt;
&lt;p&gt;
Select a transformation to apply to the text:
&lt;br&gt;
&lt;input type="radio" name="edittype" value="reverse"&gt;
Reverse
&lt;br&gt;
&lt;input type="radio" name="edittype" value="upper"&gt;
Upper-case
&lt;br&gt;
&lt;input type="radio" name="edittype" value="lower"&gt;
Lower-case
&lt;p&gt;
Press this button to see the result:
&lt;input type="submit"&gt;
&lt;p&gt;
(Or press this button to clear this form:
&lt;input type="reset"&gt;)
&lt;/form&gt;
&lt;/body&gt;
</pre>The bulk of this page is a form,
with one text input area,
one set of three radio buttons,
a submit button, and a clear button.
The user is supposed to type some text,
select a radio button representing one of three transformations
to be applied to the text,
and finally press the ``Submit'' button.
Notice that the four <TT>&lt;input&gt;</TT> tags all have
<TT>name</TT> attributes;
these are the names we'll retrieve the values by.
(The names of the three radio button elements are the same;
this is how the browser knows to implement the one-of-n
functionality on the group of three.)
</p><p>The form header is
<pre>	&lt;form action="/cgi-bin/sillycgi" method="get"&gt;
</pre>If you try this form out,
you may have to modify the URL in the <TT>action</TT> attribute,
depending on how CGI programs are accessed under your server.
The <TT>method</TT> attribute is specified as ``<TT>get</TT>'',
which means that our CGI program will receive the user's form inputs
in the <TT>QUERY_STRING</TT> variable.
</p><p>Here is the CGI program itself.
It's rather small and simple,
because <TT>cgigetval</TT> does most of the hard work,
which is as it should be.
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

extern char *cgigetval(char *);

main()
{
char *browser;
char *edittype;
char *text;

printf("Content-Type: text/html\n\n");

printf("&lt;html&gt;\n");
printf("&lt;head&gt;\n");
printf("&lt;title&gt;CGI test result&lt;/title&gt;\n");
printf("&lt;/head&gt;\n");
printf("&lt;body&gt;\n");

browser = getenv("HTTP_USER_AGENT");

printf("&lt;p&gt;\n");
printf("Hello, ");
if(browser != NULL &amp;&amp; strstr(browser, "Lynx") != NULL)
	printf("Lynx");
else if(browser != NULL &amp;&amp; strstr(browser, "Mosaic") != NULL)
	printf("Mosaic");
else if(browser != NULL &amp;&amp; strstr(browser, "Mozilla") != NULL)
	printf("Netscape");
else	printf("unknown browser");
printf(" user!\n");

printf("&lt;p&gt;\n");

printf("Here is your modified text:\n");
printf("&lt;br&gt;\n");

text = cgigetval("textfield");
edittype = cgigetval("edittype");

if(text == NULL)
	{
	printf("You didn't enter any text!\n");
	}
else if(edittype != NULL &amp;&amp; strcmp(edittype, "reverse") == 0)
	{
	reverse(text);
	printf("%s\n", text);
	}
else if(edittype != NULL &amp;&amp; strcmp(edittype, "upper") == 0)
	{
	upperstring(text);
	printf("%s\n", text);
	}
else if(edittype != NULL &amp;&amp; strcmp(edittype, "lower") == 0)
	{
	lowerstring(text);
	printf("%s\n", text);
	}
else	{
	printf("You didn't select a transformation!\n");
	}

printf("&lt;/body&gt;\n");
printf("&lt;/html&gt;\n");
}
</pre>Just for fun,
we inspect <TT>HTTP_USER_AGENT</TT>
and print a slightly different greeting
depending on which browser the user seems to be using.
Then, we call <TT>cgigetval</TT> twice,
to retrieve the user's text and radio button selections.
Depending on the radio button selection,
we call one of three different functions to transform the text.
(As we mentioned,
we're allowed to modify the strings returned by
<TT>cgigetval</TT>,
in this case, <TT>text</TT>.)
We also check for either the <TT>textfield</TT> or <TT>edittype</TT>
values coming back as null pointers,
indicating that the user neglected to enter them.
</p><p>Reversing a string in-place simply involves calling the
<TT>reverse</TT> function from assignment 4.
Converting strings to upper- or lower case is also easy;
here are functions to do it:
<pre>#include &lt;ctype.h&gt;

upperstring(char *str)
{
char *p;

for(p = str; *p != '\0'; p++)
	{
	if(islower(*p))
		*p = toupper(*p);
	}
}

lowerstring(char *str)
{
char *p;

for(p = str; *p != '\0'; p++)
	{
	if(isupper(*p))
		*p = tolower(*p);
	}
}
</pre>The <TT>isupper</TT>, <TT>islower</TT>, <TT>toupper</TT>, and
<TT>tolower</TT> functions are all in the standard C library,
and are declared in the header file <TT>&lt;ctype.h&gt;</TT>.
They operate on characters,
with the obvious results.
(Actually, on a modern, ANSI-compatible system,
the calls to <TT>isupper</TT> and <TT>islower</TT> are not required,
but they don't hurt much.
Older systems required them.)
</p><p>Finally,
here is the code for <TT>cgigetval</TT>.
It is somewhat long and involved,
partly because it has a significant amount of work to do,
partly because of some stubborn details of the sort that
sometimes crop up in real-world programs.
<pre>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

char *unescstring(char *, int, char *, int);

char *cgigetval(char *fieldname)
{
int fnamelen;
char *p, *p2, *p3;
int len1, len2;
static char *querystring = NULL;
if(querystring == NULL)
	{
	querystring = getenv("QUERY_STRING");
	if(querystring == NULL)
		return NULL;
	}

if(fieldname == NULL)
	return NULL;

fnamelen = strlen(fieldname);

for(p = querystring; *p != '\0';)
	{
	p2 = strchr(p, '=');
	p3 = strchr(p, '&amp;');
	if(p3 != NULL)
		len2 = p3 - p;
	else	len2 = strlen(p);

	if(p2 == NULL || p3 != NULL &amp;&amp; p2 &gt; p3)
		{
		/* no = present in this field */
		p += len2;
		continue;
		}
	len1 = p2 - p;

	if(len1 == fnamelen &amp;&amp; strncmp(fieldname, p, len1) == 0)
		{
		/* found it */
		int retlen = len2 - len1 - 1;
		char *retbuf = malloc(retlen + 1);
		if(retbuf == NULL)
			return NULL;
		unescstring(p2 + 1, retlen, retbuf, retlen+1);
		return retbuf;
		}

	p += len2;
	if(*p == '&amp;')
		p++;
	}

/* never found it */

return NULL;
}
</pre><TT>cgigetval</TT> presents a perfect example of a topic which
we mentioned in passing but never gave any realistic examples of:
local static variables.
<TT>cgigetval</TT>'s job is to parse the value of
the <TT>QUERY_STRING</TT> environment variable,
but the value of that variable will remain constant over one run
of a program calling <TT>cgigetval</TT>.
Therefore, we only need to call <TT>getenv</TT> once,
the first time <TT>cgigetval</TT> is called.
Thereafter,
we can continue to use the previous value.
<TT>cgigetval</TT> maintains the value of <TT>QUERY_STRING</TT>
in a local static variable, <TT>querystring</TT>.
This variable is initialized to <TT>NULL</TT>,
so the first time <TT>cgigetval</TT> is called,
it notices that <TT>querystring</TT> is null,
and calls <TT>getenv</TT> to properly initialize it.
The whole point of a local static variable is that it retains its
value from call to call,
so on subsequent calls to <TT>cgigetval</TT>,
<TT>querystring</TT> will not be null,
and there will be no need to call <TT>getenv</TT> again.
</p><p>The main loop in <TT>cgigetval</TT> loops over
each name/value pair in the query string,
one pair at a time.
The standard library <TT>strchr</TT> function
(declared in <TT>&lt;string.h&gt;</TT>)
is used to locate
the next <TT>=</TT> and <TT>&amp;</TT> characters in the string.
It would be easier to overwrite the <TT>&amp;</TT> and/or <TT>=</TT>
characters with <TT>'\0'</TT>,
to isolate the name and value substrings as true 0-terminated strings,
but we can't modify <TT>querystring</TT>
(which was obtained from <TT>getenv</TT>,
and which we'll be using again next time we're called).
Instead,
we compute the lengths of
the entire name/value pair we're looking at
and the name within that pair
(in <TT>len2</TT> and <TT>len1</TT> respectively),
and use <TT>strncmp</TT> to compare each name against the name
we're looking for.
(<TT>strncmp</TT> is a standard library function like
<TT>strcmp</TT>,
except that it only compares the first <TT>n</TT> characters.)
</p><p>When (if) we find a matching name,
it's time to decode and return the value.
First,
we call <TT>malloc</TT> to allocate the return buffer,
remembering to add 1 to the length,
to leave room for the terminating <TT>\0</TT>.
We conservatively estimate the size of the buffer we'll need by
using the length of the <em>encoded</em> string.
If there are any <TT>%</TT> encodings,
this means we'll allocate more than we need
(the decoded string will end up shorter than the encoded string),
but it's too hard to figure out in advance <em>exactly</em> how
big a buffer we'd need,
and in this case,
the slight amount of wasted memory should be inconsequential.
</p><p>If we don't find a matching string,
we take another trip through the main loop.
Each trip through the loop,
<TT>p</TT> points at the remainder of the string we're to examine.
After discarding a name/value pair, therefore,
we add <TT>len2</TT> to <TT>p</TT>,
which either moves it to the <TT>&amp;</TT> or to the <TT>\0</TT>
at the very end of <TT>query_string</TT>.
If we're now pointing at an <TT>&amp;</TT>,
we increment <TT>p</TT> by one more so that it points to the first
character of the next name/value pair.
</p><p>Here is the <TT>unescstring</TT> function.
It accepts a pointer to the encoded string,
the length of the encoded string,
a pointer to the location to store the decoded result,
and the maximum size of the decoded result
(so that it can double-check it's not overflowing anything).
We pass the encoded string in as a pointer plus a length,
rather than as a 0-terminated string,
because in most cases it will actually be an unterminated
substring,
and the length we receive will be such that we stop decoding
just before the <TT>&amp;</TT> that separates one name/value pair
from the next.
<pre>static int xctod(int);

char *unescstring(char *src, int srclen, char *dest, int destsize)
{
char *endp = src + srclen;
char *srcp;
char *destp = dest;
int nwrote = 0;

for(srcp = src; srcp &lt; endp; srcp++)
	{
	if(nwrote &gt; destsize)
		return NULL;
	if(*srcp == '+')
		*destp++ = ' ';
	else if(*srcp == '%')
		{
		*destp++ = 16 * xctod(*(srcp+1)) + xctod(*(srcp+2));
		srcp += 2;
		}
	else	*destp++ = *srcp;
	nwrote++;
	}

*destp = '\0';

return dest;
}

static int xctod(int c)
{
if(isdigit(c))
	return c - '0';
else if(isupper(c))
	return c - 'A' + 10;
else if(islower(c))
	return c - 'a' + 10;
else	return 0;
}
</pre>The basic operation is simple:
copy characters one by one from the source to the destination,
converting <TT>+</TT> signs to spaces,
converting <TT>%</TT> sequences,
and passing other characters through unchanged.
It's mildly tricky to convert a <TT>%</TT> sequence to the
equivalent character value.
Here,
we use an auxiliary function <TT>xctod</TT> which converts one
hexadecimal digit to its decimal equivalent.
(<TT>xctod</TT> is declared <TT>static</TT> because it's private
to <TT>unescstring</TT> and to this source file.)
<TT>xctod</TT> converts the digit characters <TT>0</TT>-<TT>9</TT>
to the values 0-9,
and <TT>a</TT>-<TT>f</TT> or <TT>A</TT>-<TT>F</TT>
to the values 10-15.
(It does so by subtracting character constants
which provide the correct offsets,
without our having to know the particular character set values.)
</p><p>It would also be possible
to convert the hexadecimal digits by calling <TT>sscanf</TT>,
and thus dispense with <TT>xctod</TT>.
The code would look like this:
<pre>	else if(*srcp == '%')
		{
		int x;
		sscanf(srcp+1, "%2x", &amp;x);
		*destp++ = x;
		srcp += 2;
		}
</pre>The <TT>%2x</TT> in the <TT>sscanf</TT> format string means to
convert a hexadecimal integer that's exactly two characters long.
</p><p></p><p>And that's our introduction to writing CGI programs in C!
I encourage you to type in the example and play with it
(assuming you have access to a web server where you can install
CGI programs at all, of course.)
If you would like more information on CGI programming,
you can read the page
<a href="http://hoohoo.ncsa.uiuc.edu/cgi/overview.html">http://hoohoo.ncsa.uiuc.edu/cgi/overview.html</a>
(which is where I learned everything I've presented here).
</p><hr>
<p>
This page by <a href="../../index.html">Steve Summit</a>
// <a href="copyright.html">Copyright</a> 1995, 1996
// <a href="mailto:scs@eskimo.com">mail feedback</a>
<!-- patched 2023-04-04 per &lt;20230007141207.davidapps3@gmail.com&gt; -->
</p>
</body>
</html>
