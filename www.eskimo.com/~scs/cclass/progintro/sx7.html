<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995, 1996 by Steve Summit. -->
<!-- This material may be freely redistributed and used -->
<!-- but may not be republished or sold without permission. -->
<html>
<head>
<link rev="owner" href="mailto:scs@eskimo.com">
<link rev="made" href="mailto:scs@eskimo.com">
<title>Compiler Terminology</title>
<link href="sx6.html" rev=precedes>
<link href="top.html" rev=subdocument>
</head>
<body>
<H1>Compiler Terminology</H1>

<p>C is a <dfn>compiled</dfn> language.
This means that the programs you write are translated,
by a program called a compiler,
into executable machine-language programs which you can 
actually run.
Executable machine-language programs are self-contained and run 
very quickly.
Since they are self-contained,
you don't need copies of the source code (the original 
programming-language text you composed) or the compiler in 
order to run them; you can distribute copies of just the 
executable and that's all someone else needs to run it.
Since they run relatively quickly,
they are appropriate for programs which will be written once 
and run many times.
</p><p>A compiler is a special kind of program:
it is a program that builds other programs.
What happens is that you invoke the compiler
(as a program),
and it reads the programming language statements that you have 
written and turns them into a new, executable program.
When the compiler has finished its work,
you then invoke <em>your</em> program
(the one the compiler just built)
to see if it works.
</p><p>The main alternative to a compiled computer language or program
is an interpreted one, such as BASIC.
An interpreted language is interpreted
(by, not surprisingly, a program called an interpreter)
and its actions performed immediately.
If you gave a copy of an interpreted program to someone else, 
they would also need a copy of the interpreter to run it.
No standalone executable machine-language binary program is 
produced.
</p><p>In other words, for each statement that you write,
a compiler translates into a sequence of machine language 
instructions which does the same thing,
while an interpreter simply does it
(where ``it'' is whatever the statement that you wrote is 
supposed to do).
</p><p>The big advantage of an interpreted language is that your 
program runs right away;
you don't have to perform--and wait for--the separate tasks 
of compiling and then running your program.
(Actually,
on a modern computer,
neither compiling nor interpreting takes much time,
so some of these distinctions become less important.)
</p><p>Actually, whether a language is compiled or interpreted is not 
always an inherent part of the language.
There are interpreters for C,
and there are compilers for BASIC.
However, most languages were designed with one or the other 
mechanism in mind, and there are usually a few difficulties 
when trying to compile a language which is traditionally interpreted,
or vice versa.
</p><p>The
distinction between compilation and interpretation,
while it is very significant and can make a big difference,
is not one to get worked up over.
Most of the time,
once you get used to the details of how you get your programs to run,
you don't need to worry about the distinction too much.
But it is a useful distinction to have a basic understanding of,
and to keep in the back of your mind, because it will help you 
understand why certain aspects of computer programming 
(and particular languages)
work the way they do.
</p><p>When you're working with a compiled language,
there are several mechanical details which you'll want to be 
aware of.
You create one or more <dfn>source files</dfn>
which are simple text files
containing your program,
written in whatever language you're using.
You typically use a text editor to work with source files
(typically you don't want to use a full-fledged word processor,
since the compiler won't understand its formatting codes).
You supply each source file
(you may have one, or more than one)
to the compiler, which creates an <dfn>object file</dfn> containing 
machine-language instructions corresponding to your program.
Your program is not ready to run yet, however:
if you called any functions which you didn't write
(such as the standard library functions provided as part of a 
programming language environment),
you must
arrange for them to be inserted
into your program, too.
The task of combining object files together,
while also
locating and inserting
any library functions,
is the job of the <dfn>linker</dfn>.
The linker puts together the object files you give it,
noticing if you call any functions which you haven't supplied 
and which must therefore be library functions.
It then searches one or more <dfn>library files</dfn>
(a library file is simply a collection of object files)
looking for definitions of the still-unresolved functions,
and pulls in any that it finds.
When it's done, it either builds the final, executable file,
or,
if there were any errors
(such as a function called but not defined anywhere)
complains.
</p><p>If you're using some kind of an integrated programming environment,
many of these steps may be taken care of for you
so automatically and seamlessly that you're hardly aware of them.
</p><hr>
<p>
Read sequentially:
<a href="sx6.html" rev=precedes>prev</a>
<a href="top.html" rev=subdocument>up</a>
<a href="top.html">top</a>
</p>
<p>
This page by <a href="../../index.html">Steve Summit</a>
// <a href="copyright.html">Copyright</a> 1995, 1996
// <a href="mailto:scs@eskimo.com">mail feedback</a>
<!-- patched 2023-04-03 per &lt;20230007141207.davidapps3@gmail.com&gt; -->
</p>
</body>
</html>
