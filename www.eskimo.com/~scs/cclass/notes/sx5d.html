<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995, 1996 by Steve Summit. -->
<!-- This material may be freely redistributed and used -->
<!-- but may not be republished or sold without permission. -->
<html>
<head>
<link rev="owner" href="mailto:scs@eskimo.com">
<link rev="made" href="mailto:scs@eskimo.com">
<title>5.4 Separate Compilation--Logistics</title>
<link href="sx5c.html" rev=precedes>
<link href="sx6.html" rel=precedes>
<link href="sx5.html" rev=subdocument>
</head>
<body>
<H2>5.4 Separate Compilation--Logistics</H2>

<p>When a program consists of many functions, it can be convenient
to split them up into several source files.
Among other things, this means that when a change is made, only
the source file containing the change has to be recompiled, not
the whole program.
</p><p>The job of putting the pieces of a program together and
producing the final executable falls to a tool called the
<dfn>linker</dfn>.
(We may or may not need to invoke the linker explicitly;
a compiler often invokes it
automatically,
as needed.)
The linker looks through all of the pieces making up the
program, sorting out the external declarations and
defining instances.
The compiler has noted the definitions made by each source file,
as well as the declarations of things used by each source file
but (presumably) defined elsewhere.
For each thing (global variable or function) used but not
defined by one piece of the program,
the linker looks for another piece which
does define that thing.
</p><p>The logistics of writing a program in several source files,
and then compiling and linking all of the source files together,
depend on the programming environment you're using.
We'll cover two possibilities,
depending on whether you're using a traditional command-line compiler
or a newer integrated development environment (IDE)
or other graphical user interface (GUI) compiler.

</p><p>When using a command-line compiler,
there are usually two main steps involved
in building an executable program
from one or more source files.
First,
each source file is compiled,
resulting in an <dfn>object file</dfn>
containing the machine instructions
(generated by the compiler)
corresponding to just the code in that source file.
Second,
the various object files are <dfn>linked</dfn> together,
with each other and with <dfn>libraries</dfn>
containing code for functions which you did not write

(such as <TT>printf</TT>),
to produce a final, executable program.
</p><p>Under Unix, the <TT>cc</TT>
command can perform one or both steps.
So far, we've been using extremely simple invocations of
<TT>cc</TT> such as
<pre>
	cc -o hello hello.c
</pre>
This invocation compiles a single source file,
<TT>hello.c</TT>,
links it,
and places the executable
in a file named <TT>hello</TT>.
</p><p>Suppose we have a program which we're trying to build
from three separate source files,
<TT>x.c</TT>, <TT>y.c</TT>, and <TT>z.c</TT>.
We could compile all three of them,
and link them together,
all at once,
with the command
<pre>
	cc -o myprog x.c y.c z.c
</pre>
Alternatively,
we could compile them separately:
the <TT>-c</TT> option to <TT>cc</TT> tells it to compile only,
but not to link.
Instead of building an executable,
it merely creates an object file,
with a name ending in <TT>.o</TT>,
for each source file compiled.
So the three commands
<pre>
	cc -c x.c
	cc -c y.c
	cc -c y.c
</pre>
would compile <TT>x.c</TT>, <TT>y.c</TT>, and <TT>z.c</TT>
and create object files <TT>x.o</TT>, <TT>y.o</TT>, and <TT>z.o</TT>.
Then, the three object files could be linked together using
<pre>
	cc -o myprog x.o y.o z.o
</pre>
When the <TT>cc</TT> command is given an <TT>.o</TT> file,
it

knows that it does not have to compile it
(it's an object file, already compiled);
it just sends it through to the link process.
</p><p>Above we mentioned that the second,
linking step also involves pulling in library functions.
Normally, the functions from the Standard C library are linked
in automatically.
Occasionally, you must request a library manually;
one common situation under Unix
is that the math functions tend to be in a separate math library,
which is requested by using <TT>-lm</TT> on the command line.
Since the libraries must typically be searched <em>after</em>
your program's own object files are linked
(so that the linker knows which library functions your program uses),
any <TT>-l</TT> option must appear
<em>after</em> the names of your files on the command line.
For example,
to link the object file <TT>mymath.o</TT>
(previously compiled with <TT>cc -c mymath.c</TT>)
together with the math library,
you might use
<pre>
	cc -o mymathprog mymath.o -lm
</pre>
(The <TT>l</TT> in the <TT>-l</TT> option
is the lower case ell,
for <B>l</B>ibrary;
it is <em>not</em> the digit <TT>1</TT>.)
</p><p>Everything
we've said about <TT>cc</TT>
also applies to most other Unix C compilers.
(Many of you will be using
<TT>gcc</TT>,
the FSF's GNU C Compiler.)
</p><p>There are command-line compilers for MS-DOS systems which work similarly.
For example, the Microsoft C compiler comes with a <TT>CL</TT>
(``compile and link'') command,
which works almost the same as Unix <TT>cc</TT>.
You can compile and link in one step:
<pre>
	cl hello.c
</pre>
or you can compile only:
<pre>
	cl /c hello.c
</pre>
creating an object file named <TT>hello.obj</TT> which you can link later.

</p><p>The preceding has all been about command-line compilers.
If you're using some kind of integrated development environment,
such as
Borland's Turbo C
or
the Microsoft Programmer's Workbench
or
Visual C
or
Think C
or
Codewarrior,
most of the mechanical details are taken care of for you.
(There's also less I can say here about these environments,
because they're all different.)
Typically you define a ``project,''
and there's a way to specify the list of files (modules)
which make up your project.
The modules might be source files which you typed in or
obtained elsewhere,
or they might be source files which you created within the
environment (perhaps by requesting a ``New source file,''
and typing it in).
Typically,
the programming environment has
a single ``build'' button which does whatever's required
to build (and perhaps even execute) your program.
There may also be configuration windows in which you can
specify compiler options
(such as whether you'd like it to accept C or C++).
``See your manual for details.''
</p><hr>
<p>
Read sequentially:
<a href="sx5c.html" rev=precedes>prev</a>
<a href="sx6.html" rel=precedes>next</a>
<a href="sx5.html" rev=subdocument>up</a>
<a href="top.html">top</a>
</p>
<p>
This page by <a href="../../index.html">Steve Summit</a>
// <a href="copyright.html">Copyright</a> 1995, 1996
// <a href="mailto:scs@eskimo.com">mail feedback</a>
</p>
</body>
</html>
