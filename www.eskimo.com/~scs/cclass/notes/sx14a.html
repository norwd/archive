<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!-- This collection of hypertext pages is Copyright 1995-7 by Steve Summit. -->
<!-- This material may be freely redistributed and used -->
<!-- but may not be republished or sold without permission. -->
<html>
<head>
<link rev="owner" href="mailto:scs@eskimo.com">
<link rev="made" href="mailto:scs@eskimo.com">
<title>Types and Declarations</title>
<link href="sx14.html" rev=precedes>
<link href="sx14b.html" rel=precedes>
<link href="sx14.html" rev=subdocument>
</head>
<body>
<H2>Types and Declarations</H2>

<p>We have not talked about the <TT>void</TT>,
<TT>short int</TT>, and <TT>long double</TT> types.
<TT>void</TT> is a type with no values,
used
as a placeholder
to indicate functions that do not return values
or that accept no arguments,
and
in the
``generic'' pointer type <TT>void *</TT>
that can point to anything.

<TT>short int</TT> is an integer type
that might use less space than a plain <TT>int</TT>;
<TT>long double</TT> is a floating-point type
that might have even more range or precision than plain <TT>double</TT>.
</p><p>The <TT>char</TT> type and the various sizes of <TT>int</TT>
also have ``unsigned'' versions,
which are declared using the keyword <TT>unsigned</TT>.
Unsigned types
cannot hold negative values but have guaranteed properties on overflow.
(Whether a plain <TT>char</TT> is signed or unsigned is
implementation-defined;
you can use the keyword <TT>signed</TT>
to force a character type to contain signed characters.)
Unsigned types are also useful when manipulating individual bits and bytes,
when ``sign extension'' might otherwise be a problem.
</p><p>Two additional <dfn>type qualifiers</dfn>
<TT>const</TT> and <TT>volatile</TT> allow you to declare variables
(or pointers to data)
which you promise not to change,
or which might change in unexpected ways behind the program's back.

</p><p>There are user-defined <dfn>structure</dfn> and <dfn>union</dfn> types.
A structure or <TT>struct</TT> is a ``record''
consisting of one or more values of one or more types
concreted together into one entity
which can be manipulated as a whole.
A <TT>union</TT> is a type which,
at any one time,
can hold a value
from one of a
specified
set of types.
</p><p>There are user-defined <dfn>enumeration</dfn> types
(``<TT>enum</TT>'')
which are like integers but
which always contain values from some fixed, predefined set,
and for which the values
are referred to by name instead of by number.
</p><p>Pointers can point to functions as well as to data types.
</p><p>Types can be arbitrarily complicated,
when you start using multiple levels of pointers, arrays,
functions, structures, and/or unions.
Eventually,
it's important to understand the concept of a <dfn>declarator</dfn>:
in the declaration
<pre>
	int i, *ip, *fpi();
</pre>
we have the <dfn>base type</dfn> <TT>int</TT>
and three declarators <TT>i</TT>, <TT>*ip</TT>, and <TT>*fpi()</TT>.
The declarator gives the name of a variable
(or function)
and also indicates whether it is a simple variable
or
a pointer, array, function,
or some more elaborate combination
(array of pointers, function returning pointer, etc.).
In the example,
<TT>i</TT> is declared to be a plain <TT>int</TT>,
<TT>ip</TT> is declared to be a pointer to <TT>int</TT>,
and
<TT>fpi</TT> is declared to be
a function returning pointer to <TT>int</TT>.
(Complicated declarators may also contain parentheses for grouping,
since there's a precedence hierarchy in declarators as well as expressions:
<TT>[]</TT> for arrays and <TT>()</TT> for functions
have higher precedence than <TT>*</TT> for pointers.)
</p><p>We have not said much about pointers to pointers,
or arrays of arrays
(i.e. multidimensional arrays),
or the ramifications of array/pointer equivalence
on multidimensional arrays.
(In particular, a reference to an array of arrays
does <em>not</em> generate a pointer to a pointer;
it generates a pointer to an array.
You cannot pass a multidimensional array
to a function which accepts pointers to pointers.)
</p><p>Variables can be declared with a hint
that they be placed in high-speed CPU registers,
for efficiency.
(These hints are rarely needed or used today,
because modern compilers do a good job of register allocation
by themselves, without hints.)
</p><p>A mechanism called <TT>typedef</TT> allows you to define
user-defined aliases (i.e. new and perhaps more-convenient names)
for other types.
</p><hr>
<p>
Read sequentially:
<a href="sx14.html" rev=precedes>prev</a>
<a href="sx14b.html" rel=precedes>next</a>
<a href="sx14.html" rev=subdocument>up</a>
<a href="top.html">top</a>
</p>
<p>
This page by <a href="../../index.html">Steve Summit</a>
// <a href="copyright.html">Copyright</a> 1995-1997
// <a href="mailto:scs@eskimo.com">mail feedback</a>
</p>
</body>
</html>
