<!DOCTYPE html>

<html>
<head>
<title>Literate Programming - Software Aging</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="title" content="Literate Programming - Software Aging" />
<meta name="robots" content="index,follow" />
<meta name="description" content="Learn about literate programming using the CWEB tool for software development. Download a free CWEB distribution for Microsoft Windows" />
<meta name="keywords" content="literate programming, programming, CWEB, literate, software documentation, documentation, source code, comments, C++ refactoring, public domain; freeware, software development, software, tools, languages, tex, typesetting, ctan, pdftex, postscript, metapost, pdf, desktop publishing" />
<link rel="shortcut icon" href="http://literateprogramming.com/favicon.ico" />
<link href="zerogrid.css" rel="stylesheet" />
<link href="futura.css" rel="stylesheet" />
</head>
<body>

<div class="zerogrid">

<div style="background-color:rgb(188,223,187);border-radius: 5px">
<div class="row">
<div class="col-1-4"><div class="wrap-col">
<ul style="list-style-type:none">
<li><mi><a href="index.html">Literate Programming</a></mi></li>
<li><mi><a href="quotes_sd.html">Software Documentation</a></mi></li>
<li><mi><a href="quotes_dd.html">Design Documentation</a></mi></li>
<li><mi><a href="quotes_ad.html">Agile Documentation</a></mi></li>
<li><mi><a href="quotes_sc.html">Source Code Comments</a></mi></li>
<li><mi><a href="quotes_sa.html">Software Aging</a></mi></li>
</ul>
</div></div>

<div class="col-1-4"><div class="wrap-col">
<ul style="list-style-type:none">
<li><mi><a href="cweb_download.html">CWEB Tool</a></mi></li>
<li><mi><a href="articles.html">PDF Articles</a></mi></li>
<li><mi><a href="tools.html">More Tools</a></mi></li>
<li><mi><a href="links.html">External Links</a></mi></li>
<li><mi><small><a href="lpquotes.html">Quotes - Printer Friendly</a></small></mi></li>
<li><mi><a href="feedback.html">Leave Feedback</a></mi></li>
</ul>
</div></div>

<div class="col-2-4"><div class="wrap-col">
<img src="cweave.jpg" height="83" width="450" alt="CWEAVE and CTANGLE"\>
</div></div>
</div></div>

<div class="row">
<div class="col-1-2"><div class="wrap-col">
<h3>Frederick Brooks. The Mythical Man-Month. Addison-Wesley, 1995, pg. 169.</h3>
<p>A basic principle of data processing teaches the folly of trying to maintain
independent files in synchronism. It is far better to combine them into one file with
each record containing all the information both files held concerning a given key.</p>
<p>Yet our practice in programming documentation violates our own teaching. We typically
attempt to maintain a machine-readable form of a program and an independent set of
human-readable documents, consisting of prose and flow charts.</p>
<p>The results in fact confirm our teachings about the folly of separate files. Program
documentation is notoriously poor, and its maintenance is worse. Changes made in the
program do not promptly, accurately, and invariably appear in the paper.</p>
<p>The solution, I think, is to merge the files, to incorporate the documentation in the
source program. This is at once a powerful incentive toward proper maintenance, and an
insurance that the documentation will always be handy to the program user. Such programs
are called <i>self-documenting</i>.</p>

<h3>David Parnas. "Software Aging" in Software Fundamentals. Addison-Wesley, 2001, pg.
557-558, 563.</h3>
<p>29.7.1 Keeping Records--Documentation. Even when the code is designed so that
changes can be carried out efficiently, the design principles and design decisions are
often not recorded in a form that is useful to future maintainers. Documentation is the
aspect of software engineering most neglected by both academic researchers and
practitioners. It is common to hear a programmer saying that the code is its own
documentation; even highly respected language researchers take this position, arguing
that if you use their latest language, the structure will be explicit and obvious.</p>
<p>When documentation is written, it is usually poorly organized, incomplete, and
imprecise. Often the coverage is random; a programmer or manager decides that a
particular idea is clever and writes a memo about it while other topics, equally
important, are ignored. In other situations, where documentation is a contractual
requirement, a technical writer, who does not understand the system, is hired to write
the documentation. The resulting documentation is ignored by maintenance programmers
because it is not accurate. Some projects keep two sets of books; there is the official
documentation, written as required for the contract, and the real documentation written
informally when specific issues arise.</p>
<p>Documentation that seems clear and adequate to its author is often about as clear as
mud to the programmer who must maintain the code 6 months or 6 years later. Even when the
information is present, the maintenance programmer doesn't know where to look for it. It
is almost as common to find the same topic is covered twice, but that the statements in
the documentation are inconsistent with each other and the code.</p>
<p>Documentation is not an "attractive" research topic. Last year, I suggested to the
leader of an Esprit project who was looking for a topic for a conference, that he focus
on documentation. His answer was that it would not be interesting. I objected, saying
that there were many interesting aspects to this topic. His response was that the problem
was not that the discussions wouldn't be interesting, the topic wouldn't sound
interesting and would not attract an audience.</p>
<p>For the past five or six years my own research, and that of many of my students and
close colleagues, has focused on the problems of documentation. We have shown how
mathematical methods can be used to provide clear, concise, and systematic documentation
of program design. We have invented and illustrated new mathematical notation that is
much more suited to use in documentation, but no less formal. The reaction of academics
and practitioners to this work has been insight-provoking. Both sides fail to recognize
documentation as the subject of our work. Academics keep pointing out that we are
neglecting "proof obligations"; industrial reviewers classify our work as "verification"
which they (often correctly) consider too difficult and theoretical. Neither group can
see documentation as an easier, and in some sense more important topic than verification.
To them, documentation is that "blah blah" that you have to write. In fact, unless we can
solve the documentation problem, the verification work will be a waste of time.</p>
<p>In talking to people developing commercial software we find that documentation is
neglected because it won't speed up the next release. Again, programmers and managers are
so driven by the most imminent deadline, that they cannot plan for the software's old
age. If we recognize that software aging is inevitable and expensive, that the first or
next release of the program is not the end of its development, that the long-term costs
are going to exceed the short term profit, we will start taking documentation more
seriously.</p>
<p>When we start taking documentation more seriously, we will see that just as in other
kinds of engineering documentation, software documentation must be based on mathematics.
Each document will be a representation of one or more mathematical relations. The only
practical way to record the information needed in a proper documentation will be to use
formally defined notation.</p>
<p>29.8.2 Retroactive Documentation. A major step in slowing the aging of older software,
and often rejuvenating it, is to upgrade the quality of the documentation. Often,
documentation is neglected by the maintenance programmers because in their haste to
correct problems reported by customers or to introduce new features demanded by the
market. When they do document their work, it is often by means of a memo that is not
integrated into the previously existing documentation, but simply added to it. If the
software is really valuable, the resulting unstructured documentation can, and should, be
replaced by carefully structured documentation that has been reviewed to be complete and
correct. Often, when such a project is suggested, programmers (who are rarely
enthusiastic about any form of documentation) scoff at the suggestion as impractical.
Their interests are short-term interests, and their work satisfaction comes from running
programs. Nonetheless, there are situations where it is in the owner's best interest to
insist that the product be documented in a form that can serve as a reference for future
maintenance programmers.</p>
<p>29.9.3 If It's Not Documented, It's Not Done. If a product is not documented as it is
designed, using documentation as a design medium, we will save a little today, but pay
far more in the future. It is far harder to recreate design documentation than to create
it as we go along. Documentation that has been created after the design is done, and the
product shipped, is usually not very accurate. Further, such documentation was not
available when (and if) the design was reviewed before coding. As a result, even if the
documentation is as good as it would have been, it has cost more and been worth less.</p>

<h3>Eick et al. "Does Code Decay?", IEEE Transactions on Software Engineering, January 2001.</h3>
<ul>
<li><b>Excessively complex (bloated)</b> code is more complicated than it needs to be to
accomplish its task. If rewritten, bloated code could become easier to understand and
simpler to maintain. The nesting complexity of a line of code is the number of loops and
conditionals enclosing it.</li>
<li>A <b>history of frequent changes</b> also known as code churn, suggests prior repairs
and modifications. If change is inherently risky, then churn signifies decay.</li>
<li>Similarly, code with a <b>history of code faults</b> may be decayed, not only because
of having been changed frequently, but also because fault fixes may not represent the
highest quality programming.</li>
<li><b>Widely dispersed changes</b> are a symptom of decay because changes to
well-engineered, modularized code are local.</li>
<li><b>Kludges</b> in code occur when developers knowingly make changes that could have
been done more elegantly or efficiently. That kludged code will be difficult to change is
almost axiomatic.</li>
<li><b>Numerous interfaces</b> (i.e. entry points) are cited frequently by developers when
they describe their intuitive definition of code decay. As the number of interfaces
increases, increasing attention must be directed to possible side-effects of changes in
other sections of code.</li>
</ul>

</div></div>

<div class="col-1-2"><div class="wrap-col">
<h3>Barry Boehm. Software Cost Estimation with COCOMO II, Prentice Hall, 2000, pg. 23, 28.</h3>
<p>The Maintenance Adjustment Factor (MAF), Equation 2.10, is used to adjust the effective
maintenance size to account for software understanding and unfamiliarity effects, as
with reuse. COCOMO II uses the Software Understanding (SU) and Programmer Unfamiliarity
(UNFM) factors from its reuse model to model the effects of well or poorly
structured/understandable software on maintenance effort.</p>
<center><p>Table 2.5 Rating Scale for Software Understanding Increment (SU)</p></center>
<table border="1">
<tr>
<td></td>
<td>Structure</td>
<td>Application Clarity</td>
<td>Self-Descriptiveness</td>
</tr>

<tr>
<td>Very Low</td>
<td>Very low cohesion, high coupling, spaghetti code.</td>
<td>No match between program and application world-views.</td>
<td>Obscure code; documentation missing, obscure, or obsolete.</td>
</tr>

<tr>
<td>Low</td>
<td>Moderately low cohesion, high coupling.</td>
<td>Some correlation between program and application.</td>
<td>Some code commentary and headers; some useful documentation.</td>
</tr>

<tr>
<td>Nominal</td>
<td>Reasonably well-structured; some weak areas.</td>
<td>Moderate correlation between program and application.</td>
<td>Moderate level of code commentary, headers, documentation.</td>
</tr>

<tr>
<td>High</td>
<td>High cohesion, low coupling.</td>
<td>Good correlation between program and application.</td>
<td>Good code commentary and headers; useful documentation; some weak areas</td>
</tr>

<tr>
<td>Very High</td>
<td>Strong modularity, information hiding in data/control structures.</td>
<td>Clear match between program and application world-views.</td>
<td>Self-descriptive code; documentation up-to-date, well organized, with design rationale.</td>
</tr>

</table>

<h3>Ellen Ullman. <a href="http://www.salon.com/21st/feature/1998/05/13feature.html">"The
Dumbing-down of Programming, Part II"</a></h3>
<p>I used to pass by a large computer system with the feeling that it represented the
summed-up knowledge of human beings. It reassured me to think of all those programs as a
kind of library in which our understanding of the world was recorded in intricate and
exquisite detail. I managed to hold onto this comforting belief even in the face of 20
years in the programming business, where I learned from the beginning what a hard time we
programmers have in maintaining our own code, let alone understanding programs written
and modified over years by untold numbers of other programmers. Programmers come and go;
the core group that once understood the issues has written its code and moved on; new
programmers have come, left their bit of understanding in the code and moved on in turn.
Eventually, no one individual or group knows the full range of the problem behind the
program, the solutions we chose, the ones we rejected and why.</p>
<p>Over time, the only representation of the original knowledge becomes the code itself,
which by now is something we can run but not exactly understand. It has become a process,
something we can operate but no longer rethink deeply. Even if you have the source code
in front of you, there are limits to what a human reader can absorb from thousands of
lines of text designed primarily to function, not to convey meaning.</p>

<h3>Lauren Weinstein. "The Devil You Know". Communications of the ACM, December 2003,
pg 144.</h3>
<p>The underlying problem is obvious. Get past the flashy graphics and fancy user
interfaces, and you frequently descend into a nightmarish realm of twisted spaghetti-like
code that might better belong in a Salvador Dali painting. One recurring type of software
security bug, buffer overflows, dates back to the dawn of computing. ... A plethora of
patches will never be a substitute for true quality software.</p>

<h3>Brian Foote and Joseph Yoder. "Big Ball of Mud", Fourth Conference on Pattern Languages
of Programs, 1997.</h3>
<p>A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape and bailing wire,
spaghetti code jungle. We've all seen them. These systems show unmistakable signs of unregulated
growth, and repeated, expedient repair. Information is shared promiscuously among distant
elements of the system, often to the point where nearly all the important information becomes
global or duplicated. The overall structure of the system may never have been well defined. If it
was, it may have eroded beyond recognition.</p>
<p>What does this muddy code look like to the programmers in the trenches who must
confront it? Data structures may be haphazardly constructed, or even next to
non-existent. Everything talks to everything else. Every shred of important state data
may be global. Where state information is compartmentalized, it may be passed
promiscuously about though Byzantine back channels that circumvent the system's original
structure.</p>
<p>Variable and function names might be uninformative, or even misleading. Functions
themselves may make extensive use of global variables, as well as long lists of poorly
defined parameters. The function themselves are lengthy and convoluted, and perform
several unrelated tasks. Code is duplicated. The flow of control is hard to understand,
and difficult to follow. The programmer's intent is next to impossible to discern. The
code is simply unreadable, and borders on indecipherable. The code exhibits the
unmistakable signs of patch after patch at the hands of multiple maintainers, each of
whom barely understood the consequences of what he or she was doing. Did we mention
documentation? What documentation?</p>

<h3>David Diamond. "For a Friend Assigned to a Maintenance Group" in Datamation, June
1976, pg 134.</h3>
<dl>
<dt>The fellow who designed it</dt>
<dt>is working far away;</dt>
<dt>The spec's not been updated</dt>
<dt>For many a livelong day.</dt>
<dt>The guy who implemented it is</dt>
<dt>Promoted up the line;</dt>
<dt>And some of the enhancements</dt>
<dt>Didn't match to the design</dt>
<dt>They haven't kept the flowcharts,</dt>
<dt>The manual's a mess,</dt>
<dt>And most of what you need to know,</dt>
<dt>You'll simply have to guess.</dt>
</dl>

<h3>Robert Glass. Facts and Fallacies of Software Engineering, Addison Wesley, 2003, pg
120.</h3>
<p>In examining the tasks of software development versus software maintenance, most of
the tasks are the same -- except for the additional maintenance task of "understanding the
existing product." This task consumes roughly 30 percent of total maintenance time and is
the dominant maintenance activity. Thus it is possible to claim that maintenance is a
more difficult task than development.</p>

<h3>David Parnas. "New Year's Resolutions for Software Quality", IEEE Software,
January/February 2004, pg. 13.</h3>
<p>We resolve to keep all program design documentation complete, precise, and up to date.</p>

</div></div>
</div>
</div>

</body>
</html>
