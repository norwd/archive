<HTML>
<HEAD>
<TITLE>Knuth Comments on Code</TITLE>
</HEAD>
<BODY>

<dl>
<dt><b>Knuth Comments on Code</b>
<dt>September 1996 / Bits / Knuth Comments on Code
<dt>Dave Andrews
</dl>

<p>Don Knuth, currently working on volume 4 of his Art of Computer Programming and on
Selected Papers on Computer Science, comments on good programming practices.

<p>BYTE: You recently were awarded a Kyoto Prize, Japan's esteemed private award for
lifetime achievement, for your past contributions to computer science. Looking ahead,
what are some of the critical issues facing programmers?

<p>Knuth: Well, I'm not a very good prophet. My shtick is to promote the idea that
humans, not computers, read programs. Today, humans can create programs that are faster,
better, and more reliable using tools that are getting better all the time. But 98
percent of the world's people are not computer programmers. I ask programmers to think of
themselves as writers, teachers, expositors. When you're programming, the very act of
trying to explain it to another human being forces you to get more clarity. And then
later on, you can maintain, modify, and port your programs to other platforms much more
easily. Even if your only audience is yourself, everything gets better.

<p>BYTE: Judging from the number of bugs that we see in commercial software, vendors seem
to prioritize features over error-free code. Will new tools or new programming techniques
result in more stable software?

<p>Knuth: There is no royal road, and you can't make any complex program totally
failsafe. You can test a program for a year and then someone or something will create a
condition that nobody ever anticipated and then very subtle errors become very visible.
The layers that you place on a program to make it failsafe can themselves fail. I
certainly don't say that we should avoid using techniques like redundancy to increase
the stability of critical programs, or that we should write code and not worry about the
consequences. Computer programs are the most complicated things that humans have ever
created. That's why I say this idea of exposition is the best way of coping with the
complexity. When I'm writing a program, I approach it as if I were writing a short story.
It doesn't take me longer, because the time I spend on organization is more than made up
for in time saved debugging.

<p>BYTE: Do you think programs are coming out too fast today for users to keep up?

<p>Knuth: Steve Jobs once told me in 1980 that he had a vision where every day we'd get a
CD-ROM with a thousand brand new programs on it, and that although each program would
cost just $5, the number of potential users for each program would be high enough that
software developers would get a good return on their work. He didn't think about how we'd
all cope with 1000 programs a day, but I note that controlled growth failed on the other
side of the Iron Curtain. You need uncertainty to foster innovation. A healthy degree of
confusion can serve to keep people creative.

<p>BYTE: In reviewing programming as it has evolved over the past 10 years, do you see
anything that makes you disappointed, for example, in the object computing realm?

<p>Knuth: They haven't yet built a reliable way to reason about these programs, that is,
we still lack the mathematical proofs to ensure a program will work. With object oriented
programs, we have much less of an understanding of how we would ever prove that they
don't have bugs. This is a huge gap. If people can understand OOP, they ought to be able
to prove that the programs are correct.

<p>BYTE: Should companies be more forthcoming about bugs in their products?

<p>Knuth: I think that they are doing OK, the ones that allow you to download corrected
programs from the Web and report bugs. But I don't want it to become fashionable to have
more bugs than the other guy.

<p>BYTE: Will there always be a finite number of outstanding programmers with the rest
being just ordinary? Are we using the top programmers' skills efficiently? Will we have
enough great programmers in the future?

<p>Knuth: We've seen in programming classes that one out of 50 students really grooves on
programming. Very few are really into it as top computer scientists. We find that this
ratio has held steady for 30 years. But if you let the top programmers do all the work,
they're going to design systems that are only good for them. It's better if you can get
them in teams, where you have people who have a peculiar way of thinking in one mode,
getting together with another person who has his or her own way of approaching a problem.
The best way is to have teams and to form bridges between people. I don't look at it as a
matter of one person being better than another. Some people are s imply going to be able
to write much better code, but their code isn't necessarily going to be the better system
for someone who doesn't think like the programmer.

<p>BYTE: In terms of the programming population in the U.S., are we doing a good job of
educating our programmers?

<p>Knuth: I think we're doing OK in the United States. We have enough of a variety of
programmers. There was a time when you had to follow the high priests of programming.
This stifled creativity. But we've recovered from that and now people have different
philosophies. I still think people could be documenting what they write much better. And
a comment is different than writing an essay. The way you write a program for another
human being is completely different from the way you write it for a computer.
</BODY>
</HTML>
