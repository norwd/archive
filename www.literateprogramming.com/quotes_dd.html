<!DOCTYPE html>

<html>
<head>
<title>Literate Programming - Design Documentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="title" content="Literate Programming - Design Documentation<" />
<meta name="robots" content="index,follow" />
<meta name="description" content="Learn about literate programming using the CWEB tool for software development. Download a free CWEB distribution for Microsoft Windows" />
<meta name="keywords" content="literate programming, programming, CWEB, literate, software documentation, documentation, source code, comments, C++ refactoring, public domain; freeware, software development, software, tools, languages, tex, typesetting, ctan, pdftex, postscript, metapost, pdf, desktop publishing" />
<link rel="shortcut icon" href="http://literateprogramming.com/favicon.ico" />
<link href="zerogrid.css" rel="stylesheet" />
<link href="futura.css" rel="stylesheet" />
</head>

<body>

<div class="zerogrid">

<div style="background-color:rgb(188,223,187);border-radius: 5px">
<div class="row">
<div class="col-1-4"><div class="wrap-col">
<ul style="list-style-type:none">
<li><mi><a href="index.html">Literate Programming</a></mi></li>
<li><mi><a href="quotes_sd.html">Software Documentation</a></mi></li>
<li><mi><a href="quotes_dd.html">Design Documentation</a></mi></li>
<li><mi><a href="quotes_ad.html">Agile Documentation</a></mi></li>
<li><mi><a href="quotes_sc.html">Source Code Comments</a></mi></li>
<li><mi><a href="quotes_sa.html">Software Aging</a></mi></li>
</ul>
</div></div>

<div class="col-1-4"><div class="wrap-col">
<ul style="list-style-type:none">
<li><mi><a href="cweb_download.html">CWEB Tool</a></mi></li>
<li><mi><a href="articles.html">PDF Articles</a></mi></li>
<li><mi><a href="tools.html">More Tools</a></mi></li>
<li><mi><a href="links.html">External Links</a></mi></li>
<li><mi><small><a href="lpquotes.html">Quotes - Printer Friendly</a></small></mi></li>
<li><mi><a href="feedback.html">Leave Feedback</a></mi></li>
</ul>
</div></div>

<div class="col-2-4"><div class="wrap-col">
<img src="cweave.jpg" height="83" width="450" alt="CWEAVE and CTANGLE"\>
</div></div>
</div></div>

<div class="row">
<div class="col-1-2"><div class="wrap-col">
<h3>David Parnas and Paul Clements. "A Rational Design Process: How and Why to Fake It" in
Software State-of-the-Art: Selected Papers. Dorset House, 1990, pg. 353-355.</h3>
<p>It should be clear that documentation plays a major role in the design process that we
are describing. Most programmers regard documentation as necessary evil, written as an
afterthought only because some bureaucrat requires it. They do not expect it to be
useful.</p>
<p>This is a self-fulfilling prophesy; documentation that has not been used before it is
published, documentation that is not important to its author, will always be poor
documentation.</p>
<p>Most of that documentation is incomplete and inaccurate, but those are not the main
problems. If those were the main problems, the documents could be easily corrected by
adding or correcting information. In fact, there are underlying organizational problems
that lead to incompleteness and incorrectness and those problems, which are listed below,
are not easily repaired.</p>
<p>1) Poor Organization: Most documentation today can be characterized as "stream of
consciousness" and "stream of execution." "Stream of consciousness" writing puts
information at the point in the text that the author was writing when the thought
occurred to him. "Stream of execution" writing describes the system in the order things
will happen when it runs. The problem with both of these documentation styles is that
subsequent readers cannot find the information they seek. It will therefore not be easy
to determine that facts are missing, or to correct them when they are wrong. It will not
be easy to find all the parts of the document that should be changed when the software is
changed. The documentation will be expensive to maintain and, in most cases, will not be
maintained.</p>
<p>2) Boring Prose: Lots of words are used to say what could be said by a single
programming language statement, a formula, or a diagram. Certain facts are repeated in
many different sections. This increases the cost of the documentation and its
maintenance. More importantly it leads to inattentive reading and undiscovered errors.</p>
<p>3) Confusing and Inconsistent Terminology: Any complex system requires the invention
and definition of new terminology. Without it the documentation would be far too long.
However, the writers of software documentation often fail to provide precise definitions
for the terms they use. As a result, there are many terms used for the same concept and
many similar but distinct concepts described with the same term.</p>
<p>4) Myopia: Documentation that is written when the project is nearing completion is
written by people ho have lived with the system for so long that they take major
decisions for granted. They document the small details that they think they will forget.
Unfortunately, the result is a document useful to people who know the system well, but
impenetrable for newcomers.</p>
<p>Documentation in the ideal design process meets the needs of the initial developers
as well as the needs of the programmers who come later. Each of the documents mentioned
above records requirements or design decisions and is used as a reference document for
the rest of the design. However, they also provide the information that the maintainers
will need. Because the documents are used as reference manuals throughout the building of
the software, they will be mature and ready to use in later work. The documentation in
this design process is not an afterthought; it is viewed as one of the primary products
of the project. Some systematic checks can be applied to increase completeness and
consistency. [...]</p>
<p>"Stream of consciousness" and "stream of execution" documentation is avoided by
designing the structure of each document. Each document is designed by stating the
questions that it must answer and refining the questions until each defines the content
of an individual section. There must be one, and only one, place for every fact that will
be in the document. The questions are answered, i.e., the document is written, only after
the structure of the document has been defined. When there are several documents of a 
certain kind, a standard organization is written for those documents. Every document is
designed in accordance with the same principle that guides our software design:
separation of concerns. Each aspect of the system is described in exactly one section and
nothing else is described in that section. When documents are reviewed, they are reviewed
for adherence to the documentation rules as well as for accuracy.</p>
<p>The resulting documentation is not easy or relaxing reading, but it is not boring. It
makes use of tables, formulas, and other formal notation to increase the density of
information. The organizational rules prevent the duplication of information. The result
is documentation that must be read very attentively, but rewards its reader with detailed
and precise information. [...]</p>
<p>No matter how often we stumble on our way, the final documentation will be rational
and accurate. Even mathematics, the discipline that many of us regard as the most
rational of all follows this procedure. [...] Analogous reasoning applies to software.
Those who read the software documentation want to understand the programs, not relive
their discovery. By presenting rationalized documentation we provide what they need.</p>
<p>Our documentation differs from the ideal documentation in one important way. We make a
policy of recording all of the design alternatives that we considered and rejected. For
each, we explain why it was considered and why it was finally rejected. Months, weeks, or
even hours later, when we wonder why we did what we did, we can find out. Years from now,
the maintainer will have many of the same questions and will find his answers in our
documents.</p>

<h3>David Parnas. "Why Software Jewels Are Rare". Computer, February 1996, pg. 57-60.</h3>
<p>For much of my life, I have been a software voyeur, peeking furtively at other
people's dirty code. Occasionally, I find a real jewel, a well-structured program written
in a consistent style, free of kludges, developed so that each component is simple and
organized, and designed so that the product is easy to change. Why, since we have been
studying software construction for more than 30 years, don't we find more such jewels?
How often is it possible to produce such a jewel of a system? Seldom? Frequently? Always?</p>
<p>Often, software has grown large and its structure degraded because designers have
repeatedly modified it to integrate new systems or add new features. ... Wirth suggests
that we keep our software lean by sticking to essentials, omitting "bells and whistles".
Besides, lean software is likely to be smaller and even faster.</p>
<p>However, it isn't always necessary to choose between function and elegance. Perhaps,
I'm too optimistic, but I don't think a designer must omit features to build what Wirth
calls "lean software". What is necessary is to design the product so that newly added
features do not eliminate useful capabilities, make good use of capabilities already
present for other purposes, and can be ignored or deleted by people who don't want them.
... Given a choice between tool and jewel, we will choose tool; but with a little more
thought, we can often have both. Studying the jewels can show us how.</p>
<p>One of the weaknesses of technological society is that we sometimes place far too much
emphasis on originality. Creativity and originality are obviously valuable wherever there
is room for improvement, and they are essential when dealing with problems for which we
have no adequate solution.</p>
<p>Nevertheless, we have an unfortunate tendency to value creativity as an end in itself
and use it as an excuse for ignorance. I have known both researchers and developers who
refused to look at previous work because they wanted to use their own ideas. Managers
often do not allow their designers time to study the way things have been done in the
past. It seems obvious that we should use our own ideas only if they are better than
previous ones. Successful innovators usually know previous work and have managed to
understand the fundamental weakness in earlier approaches. Too many software products show
evidence of "ignorant originality." They make the same mistakes others made before them
and ignore solutions that others have found.</p>
<p>Sometimes new languages are used in the design of jewels, and authors may attribute a
product's success to the use of a particular language or type of language. Here, I have
grave doubts. ... My experience does not support the view that the programming language
used determines the quality of the software. I have seen beautiful, lean software written
only using assembler (Dijkstra offers an example), good software written in Fortran, and
even good software written in C. I have also seen programs in which each of these tools
was used badly. ... Focusing on the programming language is a red herring that will
distract us from real solutions to the problem of poor software. The jewels I've found
owe their elegance to: the use of good decomposition principles, the use of good
hierarchical structures, and the design of interfaces.</p>
<p>There is much to learn from jewel-like systems. ... The most important lesson is
"up-front investment." In each of the jewels I've seen, the designers had obviously spent
a lot of time thinking about the structure of the system before writing code. The system
structure could be accurately described and documented without reference to the code.
Programs were not just written; they had been planned, often in some pseudocode or a
language other than the actual programming language. ... My engineering teachers laid
down some basic rules:</p>
<ul>
<li>Design before implementing.</li>
<li>Document your design.</li>
<li>Review and analyze the documented design.</li>
<li>Review implementation for consistency with the design.</li>
</ul>
<p>These rules apply to software at least as much as they do to circuits or machines.</p>

</div></div>

<div class="col-1-2"><div class="wrap-col">
<h3>Bjarne Stroustrup. The C++ Programming Language, Addison Wesley, 2000, pg. 694.</h3>
<p>The purpose of professional programming is to deliver a product that satisfies its
users. The primary means of doing so is to produce software with a clean internal
structure and to grow a group of designers and programmers skilled enough and motivated
enough to respond quickly and effectively to change and opportunities.</p>
<p>Why? The internal structure of the program and the process by which it was created are
ideally of no concern to the end user. Stronger: if the end user has to worry about how
the program was written, then there is something wrong with the program. Given that, what
is the importance of the structure of a program and of the people who create the program?
A program needs a clean internal structure to ease: testing, porting, maintenance,
extension, reorganization, and understanding.</p>
<p>The main point is that every successful piece of software has an extended life in
which it is worked on by a succession of programmers and designers, ported to new
hardware, adapted to unanticipated uses, and repeatedly reorganized. Throughout the
software's life, new versions of it must be produced with acceptable error rates and on
time.</p>

<h3>Paul Clements, Felix Bachmann, Len Bass, David Garlan, James Ivers, Reed Little,
Robert Nord, and Judith Stafford. Documenting Software Architectures: Views and Beyond,
Addison-Wesley, 2003, pg 9, 13, 24.</h3>
<p>Documentation connotes the creation of an artifact: namely, a document, which may, of
course, be electronic files, Web pages, or paper. Thus, documenting a software
architecture becomes a concrete task: producing a software architecture document. Viewing
the activity as creating a tangible product has advantages. We can describe good
architecture documents and bad ones. We can use completeness criteria to judge how much
work is left in producing this artifact and determining when the task is done. Planning
or tracking a project's progress around the creation of artifacts, or documents, is an
excellent way to manage. Making the architecture information available to its consumers
and keeping it up-to-date reduces to a solved problem of configuration control.
Documentation can be formal or not, as appropriate. Documents may describe, or they may
specify. Hence, the term is appropriately general.</p>
<p>Finally, documentation is a longstanding software engineering tradition. Documentation
is the task that you are supposed to do because it's good for you. It's what your
software engineering teachers taught you to do, your customers contracted you to do, your
managers nagged you to do, and what you always found a way not to do. So if documentation
brings up too many pangs of professional guilt, use any term you like that's more
palatable. The essence of the activity is writing down--and keeping current--the results
of architectural decisions so that the stakeholders of the architecture--people who need
to know what it is to do their job--have the information in accessible, nonambiguous
form.</p>
<p>Perhaps the most important concept associated with software architecture documentation
is that of the view. A software architecture is a complex entity that cannot be described
in a single one-dimensional fashion. Our analogy with the bird wing proves illuminating.
There is no single rendition of a bird wing. Instead there are many: feathers, skeleton,
circulation, muscular views, and many others. Which one of these views is the
"architecture" of the wing? None of them. Which views convey the architecture? All of
them.</p>
<p>We use the concept of views to give us the most fundamental principle of architecture
documentation: Documenting an architecture is a matter of documenting the relevant views
and then adding documentation that applies to more than one view.</p>
<p>What are relevant views? It depends on your goals. As we saw previously, architecture
documentation can serve many purposes: a mission statement for implementers, a basis for
analysis, the specification for automatic code generation, the starting point for system
understanding and asset recovery, or the blueprint for project planning. The views you
document depend on the uses you expect to make of the documentation.</p>
<p>It may be disconcerting that no single view can fully represent an architecture.
Additionally, it feels somehow inadequate to see the system only through discrete,
multiple views, that may or may not relate to one another in a straightforward way. The
essence of architecture is the suppression of information not necessary to the task at
hand, and so it is somehow fitting that the very nature of architecture is such that it
never presents its whole self to us but only a facet or two at a time. This is its
strength: Each view emphasizes certain aspects of the system while deemphasizing or
ignoring other aspects, all in the interest of making the problem at hand tractable.
Nevertheless, no one of these individual views adequately documents the software
architecture for the system. That is accomplished by the complete set of views along with
information that transcends them.</p>
<p>Seven rules for sound documentation: 1) Write documentation from the reader's point of
view. 2) Avoid unnecessary repetition. 3) Avoid ambiguity. 4) Use a standard
organization. 5) Record rationale. 6) Keep documentation current but not too current. 7)
Review documentation for fitness of purpose.</p>

<h3>Paul Dilascia. "What Makes Good Code Good?". MSDN Magazine, July 2004, pg. 144.</h3>
<p>A good program works flawlessly and has no bugs. But what internal qualities produce
such perfection? It's no mystery, we just need some occasional reminding. Whether you
code in C/C++, C#, Java, Basic, Perl, COBOL, ASM, all good programming exhibits the same
time-honored qualities: simplicity, readability, modularity, layering, design,
efficiency, elegance, and clarity.</p>
<p>Simplicity means you don't do in ten lines what you can do in five. It means you make
extra effort to be concise, but not to the point of obfuscation. It means you abhor open
coding and functions that span pages. Simplicity--of organization, implementation,
design--makes your code more reliable and bug free. There's less to go wrong.</p>
<p>Readability means what it says: that others can read your code. Readability means you
bother to write comments, to follow conventions, and pause to name your variables wisely.</p>
<p>Modularity means your program is built like the universe. The world is made of
molecules, which are made of atoms, electrons, nucleons, and quarks. Likewise good
programs erect large systems from smaller ones, which are built from even smaller
building blocks. And just as atoms combine in novel ways, software components should be
reusable.</p>
<p>Layering means that internally, your program resembles a layer cake. The app sits on
the framework sits on the OS sits on the hardware. Even within your app, you need layers,
like file-document-view-frame. Higher layers call ones below, which raise events back up.
(Calls go down; events go up.) Lower layers should never know what higher ones are up to.
The essence of an event/callback is to provide blind upward notification. If your doc
calls the frame directly, something stinks. Modules and layers are defined by APIs, which
delineate their boundaries. Thus, design is critical.</p>
<p>Design means you take the time to plan your program before you build it. Thoughts are
cheaper than debugging. A good rule of thumb is to spend half your time on design. You
need a functional spec (what the program does) and an internal blueprint. APIs should be
codified in writing.</p>
<p>Efficiency means your program is fast and economical. It doesn't hog files, data
connections, or anything else. It does what it should, but no more. It loads and departs
without fuss. At the function level, you can always optimize later, during testing. But
at high levels, you must plan for performance. If the design requires a million trips to
the server, expect a dog.</p>
<p>Elegance is like beauty: hard to describe but easy to recognize. Elegance combines
simplicity, efficiency, and brilliance, and produces a feeling of pride. Elegance is when
you replace a procedure with a table, or realize that you can use recursion--which is
almost always elegant.</p>
<p>Clarity is the granddaddy of good programming, the platinum quality all the others
serve. Computers make it possible to create systems that are vastly more complex than
physical machines. The fundamental challenge of programming is managing complexity.
Simplicity, readability, modularity, layering, design, efficiency, and elegance are all
time-honored ways to achieve clarity, which is the antidote to complexity.</p>
<p>Clarity of code. Clarity of design. Clarity of purpose. You must understand--really
understand--what you're doing at every level. Otherwise you're lost. Bad programs are
less often a failure of coding skill than of having a clear goal. That's why design is
key. It keeps you honest. If you can't write it down, if you can't explain it to others,
you don't really know what you're doing.</p>

</div></div>
</div>
</div>

</body>
</html>