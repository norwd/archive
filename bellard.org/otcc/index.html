<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title> OTCC : Obfuscated Tiny C Compiler</title>
</head>
<body>

<center>
<h1>
Obfuscated Tiny C Compiler
</h1>
</center>

<h2>What is it ?</h2>

The Obfuscated Tiny C Compiler (OTCC) is a very small C compiler I
wrote in order to win the <A HREF="http://www.ioccc.org">International
Obfuscated C Code Contest</a> (IOCCC) in 2002.
<p>
My goal was to write the smallest C compiler which is able to compile
itself. I choose a subset of C which was general enough to write a
small C compiler. Then I extended the C subset until I reached the
maximum size authorized by the contest: 2048 bytes of C source
excluding the ';', '{', '}' and space characters.
<p>

I choose to generate i386 code. The original OTCC code could only run
on i386 Linux because it relied on endianness and unaligned access. It
generated the program in memory and launched it directly. External
symbols were resolved with <tt>dlsym()</tt>.
<p>
In order to have a portable version of OTCC, I made a variant called
OTCCELF. It is only a little larger than OTCC, but it generates
directly a <i>dynamically linked i386 ELF executable</i> from a C
source without relying on any binutils tools! OTCCELF was tested
succesfully on i386 Linux and on Sparc Solaris.
<p>
NOTE: My other project <a href="https://bellard.org/tcc/">TinyCC</a> which is a fully
featured ISOC99 C compiler was written by starting from the source
code of OTCC !

<h2>Download</h2>

<ul>
<li> Original OTCC version (runs <i>only</i> on i386 Linux): <a
href="otcc.c">otcc.c</a>.
<li> OTCC with i386 ELF output (should be portable): <a href="otccelf.c">otccelf.c</a>.
<li> Example of C program that can be compiled: <a href="otccex.c">otccex.c</a>.

<li> <b>[New]</b> The non-obfuscated versions are finally available:
<a href="otccn.c">otccn.c</a> and <a
href="otccelfn.c">otccelfn.c</a>. These non-obfuscated
versions do not self compile. They are provided for documentation
purpose.  </ul>

Compilation:
<pre>
gcc -m32 -O2 -Wl,-z,execstack -no-pie otcc.c -o otcc -ldl
gcc -m32 -O2 otccelf.c -o otccelf 
</pre>
Self-compilation:
<pre>
./otccelf otccelf.c otccelf1
</pre>

As a test, here are the executables generated by OTCCELF: <a
href="otcc1">otcc1</a>, <a href="otccelf1">otccelf1</a>, <a
href="otccex1">otccex1</a>.
<p>
  Notes:
<ul>
  <li><code>-Wl,-z,execstack</code> is needed on today's Linux systems
    to force executable data.</li>
  <li><code>-no-pie</code> is needed on some Linux systems to disable
  position independent executable (otcc relies on the fact that the C
  allocated data is at an address &lt; 0x80000000. otccelf does not
  have this limitation).</li>
</ul>

<h2>C Subset Definition</h2>

    Read joint example <a HREF="otccex.c"</a>otccex.c</a> to have
    an example of C program.
<ul>                          
    <li> Expressions: 
     <ul>                          
        <li> binary operators, by decreasing priority order: '*' '/' '%',
          '+' '-', '>>' '<<', '<' '<=' '>' '>=', '==' '!=', '&',
          '^', '|', '=', '&&', '||'.

        <li> '&&' and '||' have the same semantics as C : left to right
          evaluation and early exit.

        <li> Parenthesis are supported.

        <li> Unary operators: '&', '*' (pointer indirection), '-'
          (negation), '+', '!', '~', post fixed '++' and '--'.
        
        <li> Pointer indirection ('*') only works with explicit cast to
          'char *', 'int *' or 'int (*)()' (function pointer).

        <li> '++', '--', and unary '&' can only be used with variable
          lvalue (left value).

        <li> '=' can only be used with variable or '*' (pointer
          indirection) lvalue.

        <li> Function calls are supported with standard i386 calling
          convention. Function pointers are supported with explicit
          cast. Functions can be used before being declared.
     </ul>
    <li> Types: only signed integer ('int') variables and functions can
      be declared. Variables cannot be initialized in
      declarations. Only old K&R function declarations are parsed
      (implicit integer return value and no types on arguments).

    <li> Any function or variable from the libc can be used because OTCC
      uses the libc dynamic linker to resolve undefined symbols.

    <li> Instructions: blocks ('{' '}') are supported as in C. 'if' and
      'else' can be used for tests. The 'while' and 'for' C constructs
      are supported for loops. 'break' can be used to exit
      loops. 'return' is used for the return value of a function.

    <li> Identifiers are parsed the same way as C. Local variables are
      handled, but there is no local name space (not a problem if
      different names are used for local and global variables).

    <li> Numbers can be entered in decimal, hexadecimal ('0x' or '0X'
      prefix), or octal ('0' prefix).
    
    <li> '#define' is supported without function like arguments. No macro
      recursion is tolerated. Other preprocessor directives are
      ignored.

    <li> C Strings and C character constants are supported. Only '\n',
      '\"', '\'' and '\\' escapes are recognized.

    <li> C Comments can be used (but no C++ comments).

    <li> No error is displayed if an incorrect program is given.

    <li> Memory: the code, data, and symbol sizes are limited to 100KB
      (it can be changed in the source code).
</ul>

<h2> OTCC Invocation </h2>
    You can use OTCC by typing: 

<pre>
otcc prog.c [args]...
</pre>

    or by giving the C source to its standard input. 'args' are given
    to the 'main' function of prog.c (argv[0] is prog.c).
<p>
    Examples: 
    <ul>
     <li> Sample compilation and execution:
<pre>
otcc otccex.c 10
</pre>
     <li> Self compilation:
<pre>
otcc otcc.c otccex.c 10
</pre>

     <li> Self compilation iterated...
<pre>
otcc otcc.c otcc.c otccex.c 10
</pre>
    </ul>
    An alternate syntax is to use it as a script interpreter: you can
    put 
<pre>
#!/usr/local/bin/otcc
</pre>
at the beginning of your C source if
    you installed otcc at this place.

<h2> OTCCELF Invocation </h2>

You can use OTCCELF by typing: 

<pre>
otccelf prog.c prog
chmod 755 prog
</pre>
'prog' is the name of the ELF file you want to generate.
<p>

Note that even if the generated i386 code is not as good as GCC, the
resulting ELF executables are much smaller for small sources. Try this program:
<pre>
#include &lt;stdio.h&gt;

main() 
{
    printf("Hello World\n");
    return 0;
}
</pre>

Results:
<table border=1>
<tr><th>Compiler<th>Executable size (in bytes)
<tr><td>OTCCELF<td align=center><i>424</i>
<tr><td>GCC (stripped)<td align=center><i>2448</i>
</table>

<h2>Links</h2>
<ul>
<li><a href="https://bellard.org/tcc/">TinyCC</a>, a tiny but complete C compiler.
<li><a href="http://www.muppetlabs.com/~breadbox/software/tiny/">Tiny ELF programs</a> from Brian Raiter.
<li><a href="http://asm.sourceforge.net/resources.html">Linux assembly projects</a>.
</ul>

<h2>License</h2>

The obfuscated OTCC and OTCCELF are public domain. The <i>non-obfuscated</i>
versions are released under a BSD-like license (read the license at
the start of the source code).

<hr>
This page is Copyright (c) 2002 Fabrice Bellard <hr>

Fabrice Bellard - <A
HREF="http://bellard.org/">
http://bellard.org/ </A> - <A
HREF="http://www.tinycc.org/"> http://www.tinycc.org/ </A>

</body>
</html>
