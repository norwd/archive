<html><head>
<link rel="made" rev="made" href="mailto:jutta@cs.tu-berlin.de">
<title>ANSI</title></head>
<body>
<a href="c-4.html"><img SRC="prev.xbm" ALT="[prev]"></a>
<a href="index.html#comp-lang-c-faq"><img SRC="up.xbm" ALT="[up]"></a>
<a href="c-faq-toc.html#c-5"><img SRC="overview.xbm" alt="[overview]"></a>
<a href="c-6.html"><img SRC="next.xbm" ALT="[next]"></a>
<hr>

<h2>Section 5. ANSI C</h2>
<p>
<h3>
<a name="5-1">
5.1:	What is the &quot;</a>ANSI C Standard?&quot;
</h3><p>
  	In 1983, the American National Standards Institute (ANSI) commissioned
	a committee, X3J11, to standardize the C language.&#160;<tt> </tt>After a
	long, arduous process, including several widespread public
	reviews, the committee's work was finally ratified as
	ANS X3.159-1989, on December 14, 1989,
	and published in the spring of
	1990.&#160;<tt> </tt>For the most part, ANSI C
	standardizes existing practice, with a few additions from C++
	(most notably function prototypes) and support for multinational
	character sets (including the much-lambasted trigraph
	sequences).&#160;<tt> </tt>The ANSI C standard also formalizes
	the C run-time
	library support routines.
<p>
	The published Standard includes a
	&quot;<a href="../rat/title.html">Rationale</a>,&quot; which explains
	many of its decisions, and discusses a number of subtle points,
	including several of those covered here.&#160;<tt> </tt>(The Rationale
	is &quot;not part of
	ANSI Standard X3.159-1989, but is
	included for information only.&quot;)
<p>
	The Standard has been adopted as an international standard,
	<a href="http://www.iso.ch/cate/d17782.html">ISO/IEC 9899:1990</a>,
	although the sections are numbered
	differently (briefly, ANSI sections 2 through 4 correspond
	roughly to ISO sections 5 through 7), and the Rationale is
	currently not included.
<p>

<h3><a name="5-2">5.2:	How can I get a copy of the Standard?</a></h3>
<p>
  	ANSI X3.159 has been officially superseded by ISO 9899.
	Copies are available in the United States from
<blockquote>
		<a href="http://www.iso.ch/addresse/ANSI.html"
                        >American National Standards Institute</a><br>
		11 W. 42nd St., 13th floor<br>
		New York, NY&#160;<tt> </tt>10036  USA<br>
		(+1) 212 642 4900<br>
</blockquote>
	or
<blockquote>
		Global Engineering Documents<br>
		2805 McGaw Avenue<br>
		Irvine, CA&#160;<tt> </tt>92714  USA<br>
		(+1) 714 261 1455<br>
		(800) 854 7179&#160;<tt> </tt>(U.S. &amp; Canada)<br>
</blockquote>
        In other countries, contact the appropriate national standards
        body, or ISO in Geneva at:
<p>
<blockquote>
                ISO Sales<br>
                Case Postale 56<br>
                CH-1211&#160;<tt> </tt>Geneve 20<br>
                Switzerland<br>
</blockquote>
<p>
	The cost is $130.00 from ANSI or $162.50 from Global.&#160;<tt> </tt>Copies of
	the original X3.159 (including the
	<a href="../rat/title.html">Rationale</a>) are still
	available at $205.00 from ANSI or $200.50 from Global.&#160;<tt> </tt>
	Note that ANSI derives revenues to support its operations from the
	sale of printed standards, so electronic copies are <em>not</em>
	available.
<p>
        The mistitled <em>Annotated ANSI C Standard</em>, with annotations by
        Herbert Schildt, contains all but a few pages of ISO 9899; it is
        published by Osborne/McGraw-Hill, ISBN 0-07-881952-0, and sells
        in the U.S. for approximately $40.&#160;<tt> </tt>(It has been
	suggested that
        the price differential between this work and the official
        standard reflects the value of the annotations.)
<p>
<a name="Rationale">
	The text of the <a href="../rat/title.html">Rationale</a> (not the
	full Standard) is now available for anonymous ftp from
	<a href="ftp://ftp.uu.net/doc/standards/ansi/X3.159-1989">ftp.uu.net</a>
	(see <a href="c-17.html#17-12">question 17.12</a>)
	in directory doc/standards/ansi/X3.159-1989 .&#160;<tt> </tt>The
	Rationale has also been printed by Silicon Press, ISBN 0-929306-07-4.

<p>
<h3>
<a name="5-3">
5.3:	Does anyone have a tool for converting old-style C programs to
	</a>ANSI C, or vice versa, or for automatically generating
	prototypes?
</h3><p>
  	Two programs, protoize and unprotoize, convert back and forth
	between prototyped and &quot;old style&quot; function definitions and
	declarations.&#160;<tt> </tt>(These programs do <em>not</em> handle full-blown
	translation between &quot;Classic&quot; C and ANSI C.)&#160;<tt> </tt>These programs
        were once patches to the FSF GNU C compiler, gcc, but are now
        part of the main gcc distribution; look in <a href="ftp://prep.ai.mit.edu/pub/gnu">pub/gnu at
        prep.ai.mit.edu (18.71.0.38)</a>, or at several other FSF archive
        sites.
<p>
	The unproto program (<a href="ftp://ftp.win.tue.nl/pub/unix/unproto5.shar.Z">/pub/unix/unproto5.shar.Z on
	ftp.win.tue.nl</a>) is a filter which sits between the preprocessor
	and the next compiler pass, converting most of ANSI C to
	traditional C on-the-fly.
<p>
	The GNU GhostScript package comes with a little program called
	ansi2knr.
<p>
	Several prototype generators exist, many as modifications to
	lint.&#160;<tt> </tt>Version 3 of CPROTO was posted to comp.sources.misc in
	March, 1992.&#160;<tt> </tt>There is another program called "cextract."&#160;<tt> </tt>See also <a href="c-17.html#17-12">question 17.12</a>.
<p>
	Finally, are you sure you really need to convert lots of old
	code to ANSI C?&#160;<tt> </tt>The old-style function syntax is still
	acceptable.
<p>

<h3>
<a name="5-4">
5.4:	I'm trying to use the </a>ANSI &quot;stringizing&quot; preprocessing operator
	<code>#</code> to insert the value of a symbolic constant into a message, but
	it keeps stringizing the macro's name rather than its value.
</h3><p>
  	You must use something like the following two-step procedure to
	force the macro to be expanded as well as stringized:
<p>
<pre>
	#define str(x) #x
	#define xstr(x) str(x)
	#define OP plus
	char *opname = xstr(OP);
</pre>
<p>
	This sets opname to &quot;<code>plus</code>&quot; rather than &quot;<code>OP</code>&quot;.
<p>
	An equivalent circumlocution is necessary with the token-pasting
	operator <code>##</code> when the values (rather than the names) of two
	macros are to be concatenated.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.8.3.2, Sec. 3.8.3.5 example p. 93.
<p>
<h3><a name="5-5">5.5:  I don't understand why I can't use</a><code> const </code>values in initializers
        and array dimensions, as in
</h3><pre>
                const int n = 5;
                int a[n];
</pre><p>
        The<code> const </code>qualifier really means "read-only;" an object so
        qualified is a normal run-time object which cannot (normally) be
        assigned to.&#160;<tt> </tt>The value of a const-qualified object is therefore
        <em>not</em> a constant expression in the full sense of the term.&#160;<tt> </tt>(C
        is unlike C++ in this regard.)  When you need a true compile-
        time constant, use a preprocessor<code> #define </code>.
<p>
        References: <a href="index.html#ANSI">ANSI</a> Sec. 3.4 .
<p> 
<h3>
<a name="5-6">
5.6:	What's the difference between &quot;</a><code>char</code> <code>const</code> <code>*p</code>&quot; and
	&quot;<code>char</code> <code>*</code> <code>const</code> <code>p</code>&quot;?
</h3><p>
  	&quot;<code>char const</code> <code>*p</code>&quot; is a pointer to a constant character (you can't
	change the character); &quot;<code>char</code> <code>* const p</code>&quot; is a constant pointer to
	a (variable) character (i.e. you can't change the pointer).
	(Read these &quot;inside out&quot; to understand them.&#160;<tt> </tt>See <a href="c-10.html#10-4">question
	10.4</a>.)
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.5.4.1 .
<p>

<h3>
<a name="5-7">
5.7:	Why can't I pass a </a><code>char</code> <code>**</code> to a function which expects a
	<code>const char</code> <code>**</code>?
</h3><p>
  	You can use a pointer-to-T (for any type T) where a pointer-to-
	const-T is expected, but the rule (an explicit exception) which
	permits slight mismatches in qualified pointer types is not
	applied recursively, but only at the top level.
<p>
	You must use explicit casts (e.g. <code>(const char</code> <code>**)</code> in this case)
	when assigning (or passing) pointers which have qualifier
	mismatches at other than the first level of indirection.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.1.2.6 p. 26, Sec. 3.3.16.1 p. 54,
	Sec. 3.5.3 p. 65.
<p>

<h3>
<a name="5-8">
5.8:	My </a><a href="index.html#ANSI">ANSI</a> compiler complains about a mismatch when it sees</h3>
<p>
<pre>
	extern int func(float);

	int func(x)
	float x;
	{...
</pre>
<p>
  	You have mixed the new-style prototype declaration
	&quot;<code>extern int func(float);</code>&quot; with the old-style definition
	&quot;<code>int func(x) float x;</code>&quot;.&#160;<tt> </tt>
	It is usually safe to mix the two
        styles (see question 5.9), but not in this case.&#160;<tt> </tt>Old C (and
	ANSI C,  in the absence of prototypes, and in variable-length
        argument lists) &quot;widens&quot; certain arguments when
	they are passed to functions.&#160;<tt> </tt><code>floats</code> are
	promoted to <code>double</code>, and characters and short integers are
	promoted to <code>int</code>s.&#160;<tt> </tt>(For old-style function
        definitions, the values are automatically converted back
	to the corresponding narrower types within the body of the
	called function, if they are declared that way there.)
<p>
	This problem can be fixed either by using new-style syntax
	consistently in the definition:
<p>
<pre>
	int func(float x) { ... }
</pre>
<p>
	or by changing the new-style prototype declaration to match the
	old-style definition:
<p>
<pre>
	extern int func(double);
</pre>
<p>
	(In this case, it would be clearest to change the old-style
	definition to use double as well, as long as the address of that
	parameter is not taken.)
<p>
	It may also be safer to avoid &quot;narrow&quot; (<code>char</code>, <code>short int</code>, and
	<code>float</code>) function arguments and return types.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.3.2.2 .
<p>
<h3><a name="5-9">5.9:    Can you mix old-style and new-style function syntax?
</a></h3><p>
        Doing so is perfectly legal, as long as you're careful (see
        especially <a href="c-5.html#5-8">question 5.8</a>).&#160;<tt> </tt>Note however that old-style syntax is
        marked as obsolescent, and support for it may be removed some
        day.
<p>
        References: <a href="index.html#ANSI">ANSI</a> Secs. 3.7.1, 3.9.5 .
<p>

<h3>
<a name="5-10">
5.10:	Why does the declaration
</a></h3><p>
<pre>
	extern f(struct x {int s;} *p);
</pre>
<p><h3>
	give me an obscure warning message about &quot;struct x introduced in
	prototype scope&quot;?
</h3><p>
  	In a quirk of C's normal block scoping rules, a struct declared
	only within a prototype cannot be compatible with other structs
	declared in the same source file, nor can the struct tag be used
	later as you'd expect (it goes out of scope at the end of the
	prototype).
<p>
	To resolve the problem, precede the prototype with the vacuous-
	looking declaration
<p>
<pre>
	struct x;
</pre>
<p>
	, which will reserve a place at file scope for <code>struct x</code>'s
	definition, which will be completed by the struct declaration
	within the prototype.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.1.2.1 p. 21, Sec. 3.1.2.6 p. 26,
	Sec. 3.5.2.3 p. 63.
<p>

<h3>
<a name="5-11">
5.11:	I'm getting strange syntax errors inside code which I've
	#ifdeffed out.
</a></h3><p>
  	Under ANSI C, the text inside a &quot;turned off&quot; <code>#if</code>, <code>#ifdef</code>, or
	<code>#ifndef</code> must still consist of &quot;valid preprocessing tokens.&quot;
	This means that there must be no unterminated comments or quotes
	(note particularly that an apostrophe within a contracted word
	could look like the beginning of a character constant), and no
	newlines inside quotes.&#160;<tt> </tt>Therefore, natural-language comments
	and pseudocode should always be written between the &quot;official&quot;
	comment delimiters <code>/*</code> and <code>*/</code>.&#160;<tt> </tt>(But see also <a href="c-17.html#17-14">question 17.14</a>, and
	<a href="c-6.html#6-7">6.7</a>.)
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 2.1.1.2 p. 6, Sec. 3.1 p. 19 line 37.

<p>
<h3>
<a name="5-12">
5.12:	Can I declare </a><code>main</code> as <code>void</code>, to shut off these annoying &quot;main
	returns no value&quot; messages?&#160;<tt> </tt>(I'm calling <code>exit()</code>, so <code>main</code>
	doesn't return.)
</h3><p>
  	No.&#160;<tt> </tt><code>main</code> must be declared as returning an <code>int</code>, and as taking
	either zero or two arguments (of the appropriate type).&#160;<tt> </tt>If
	you're calling <code>exit()</code> but still getting warnings, you'll have to
	insert a redundant <code>return</code> statement (or use some kind of
	&quot;notreached&quot; directive, if available).
<p>
        Declaring a function as<code> void </code>does not merely silence warnings;
        it may also result in a different function call/return sequence,
        incompatible with what the caller (in<code> main</code>'s case, the C run-
        time startup code) expects.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 2.1.2.2.1 pp. 7-8.
<p>

<h3>
<a name="5-13">
5.13:	Is </a><code>exit(status)</code> truly equivalent to returning status from <code>main</code>?
</h3><p>
	Formally, yes, although discrepancies arise under a few older,
        nonconforming systems, or if data local to<code> main()</code> might be needed
        during cleanup (due perhaps to a <code>setbuf</code> or
	<code>atexit</code> call), or if<code> main() </code>is
	called recursively.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 2.1.2.2.3 p. 8.
<p>

<h3>
<a name="5-14">
5.14:	Why does the </a>ANSI Standard not guarantee more than six monocase
	characters of external identifier significance?
</h3><p>
  	The problem is older linkers which are neither under the control
	of the ANSI standard nor the C compiler developers on the
	systems which have them.&#160;<tt> </tt>The limitation is only that
	identifiers be <em>significant</em> in the first six characters, not
	that they be restricted to six characters in length.&#160;<tt> </tt>This
	limitation is annoying, but certainly not unbearable, and is
	marked in the Standard as &quot;obsolescent,&quot; i.e. a future revision
	will likely relax it.
<p>
	This concession to current, restrictive linkers really had to be
	made, no matter how vehemently some people oppose it.&#160;<tt> </tt>(The
	<a href="c-5.html#Rationale">Rationale</a> notes that its retention was
	&quot;most painful.&quot;)&#160;<tt> </tt>If you
	disagree, or have thought of a trick by which a compiler
	burdened with a restrictive linker could present the C
	programmer with the appearance of more significance in external
	identifiers, read the
	excellently-worded <a href="../rat/c1.html#3-1-2">section 3.1.2</a>
	in the X3.159 <a href="c-5.html#Rationale">Rationale</a> (see
	<a href="c-5.html#5-1">question 5.1</a>), which discusses several
	such schemes and explains why they could not be mandated.
<p>
	References:
	<a href="index.html#ANSI">ANSI</a> Sec. 3.1.2 p. 21, Sec. 3.9.1 p. 96,
	<a href="../rat/c1.html#3-1-2">Rationale</a> Sec. 3.1.2 pp. 19-21.
<p>

<h3>
<a name="5-15">
5.15:	What is the difference between </a><code>memcpy</code> and <code>memmove</code>?
</h3><p>
  	<code>memmove</code> offers guaranteed behavior if the source and destination
	arguments overlap.&#160;<tt> </tt><code>memcpy</code> makes no such guarantee, and may
	therefore be more efficiently implementable.&#160;<tt> </tt>When in doubt,
	it's safer to use <code>memmove</code>.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Secs. 4.11.2.1, 4.11.2.2,
	<a href="../rat/d11.html#4-11-2">Rationale Sec. 4.11.2</a>.
<p>

<h3>
<a name="5-16">
5.16:	My compiler is rejecting the simplest possible test programs,
	with all kinds of syntax errors.
</a></h3><p>
  	Perhaps it is a pre-ANSI compiler, unable to accept function
	prototypes and the like.&#160;<tt> </tt>See also questions <a href="c-5.html#5-17">5.17</a> and <a href="c-17.html#17-2">17.2</a>.
<p>
<h3><a name="5-17">
5.17:   Why are some ANSI/ISO Standard library routines showing up as
        undefined, even though I've got an ANSI compiler?</a>
</h3><p>
        It's not unusual to have a compiler available which accepts ANSI
        syntax, but not to have ANSI-compatible header files or run-time
        libraries installed.&#160;<tt> </tt>See also questions <a href="c-5.html#5-16">5.16</a> and <a href="c-17.html#17-2">17.2</a>.
<p>
<h3><a name="5-18">
5.18:	Why won't the Frobozz Magic C Compiler, which claims to be </a>ANSI
	compliant, accept this code?&#160;<tt> </tt>I know that the code is ANSI,
	because gcc accepts it.
</h3><p>
  	Most compilers support a few non-Standard extensions, gcc more
	so than most.&#160;<tt> </tt>Are you sure that the code being rejected doesn't
	rely on such an extension?&#160;<tt> </tt>It is usually a bad idea to perform
	experiments with a particular compiler to determine properties
	of a language; the applicable standard may permit variations, or
	the compiler may be wrong.&#160;<tt> </tt>See also <a href="c-4.html#4-4">question 4.4</a>.
<p><h3><a name="5-19">
5.19:   Why can't I perform arithmetic on a</a><code> void</code> <code>* </code>pointer?</h3>
<p>
        The compiler doesn't know the size of the pointed-to objects.
        Before performing arithmetic, cast the pointer either to<code> char</code> <code>* </code>
        or to the type you're trying to manipulate (but see <a href="c-2.html#2-18">question 2.18</a>).
<p>
<h3>
<a name="5-20">
5.20:	Is </a><code>char a[3] = &quot;abc&quot;;</code> legal?&#160;<tt> </tt>What does it mean?
</h3><p>
  	It is legal in ANSI C (and perhaps in a few pre-ANSI systems), though questionably useful.&#160;<tt> </tt>It declares an array
	of size three, initialized with the three characters <code>'a'</code>, <code>'b',</code>
	and <code>'c'</code>, without the usual terminating <code>'\0'</code> character; the array
	is therefore not a true C string and cannot be used with <code>strcpy</code>,
	<code>printf</code> <code>%s</code>, etc.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.5.7 pp. 72-3.
<p>

<h3>
<a name="5-21">
5.21:	What are </a><code>#pragmas</code> and what are they good for?
</h3><p>
  	The <code>#pragma</code> directive provides a single, well-defined &quot;escape
	hatch&quot; which can be used for all sorts of implementation-
	specific controls and extensions: source listing control,
	structure packing, warning suppression (like the old lint
	<code>/*</code> <code>NOTREACHED</code> <code>*/</code> comments), etc.
<p>
	References: <a href="index.html#ANSI">ANSI</a> Sec. 3.8.6 .
<p><h3><a name="5-22">
5.22:   What does</a> "<code>#pragma once</code>" mean?&#160;<tt> </tt>I found it in some header files.</h3>
<p>
        It is an extension implemented by some preprocessors to help
        make header files idempotent; it is essentially equivalent to
        the #ifndef trick mentioned in question 6.4.
<p>
<h3><a name="5-23">5.23:   People seem to make a point of distinguishing between
        implementation-defined, unspecified, and undefined behavior.
        What's the difference?</a></h3>
<p>
        Briefly: implementation-defined means that an implementation
        must choose some behavior and document it.&#160;<tt> </tt>Unspecified means
        that an implementation should choose some behavior, but need not
        document it.&#160;<tt> </tt>Undefined means that absolutely anything might
        happen.&#160;<tt> </tt>In no case does the Standard impose requirements; in
        the first two cases it occasionally suggests (and may require a
        choice from among) a small set of likely behaviors.
<p>
        If you're interested in writing portable code, you can ignore
        the distinctions, as you'll want to avoid code that depends on
        any of the three behaviors.
<p>
        References: <a href="index.html#ANSI">ANSI</a> Sec. 1.6,
  especially the <a href="../rat/a.html#unspecified-behavior">Rationale</a>.
<hr>
<a href="c-4.html"><img SRC="prev.xbm" ALT="[prev]"></a>
<a href="index.html#comp-lang-c-faq"><img SRC="up.xbm" ALT="[up]"></a>
<a href="c-faq-toc.html#c-5"><img SRC="overview.xbm" alt="[overview]"></a>
<a href="c-6.html"><img SRC="next.xbm" ALT="[next]"></a></body></html>
