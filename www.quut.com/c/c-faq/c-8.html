<html><head>
<link rel="made" rev="made" href="mailto:jutta@cs.tu-berlin.de">
<title>Boolean Expressions and Variables</title></head>
<body>
<a href="c-7.html"><img SRC="prev.xbm" ALT="[prev]"></a>
<a href="index.html#comp-lang-c-faq"><img SRC="up.xbm" ALT="[up]"></a>
<a href="c-faq-toc.html#c-8"><img SRC="overview.xbm" alt="[overview]"></a>
<a href="c-9.html"><img SRC="next.xbm" ALT="[next]"></a>
<hr>

<h2>Section 8. Boolean Expressions and Variables</h2>
<p>
<h3>
<a name="8-1">
8.1:	What is the right type to use for boolean values in C?</a>&#160;<tt> </tt>Why
	isn't it a standard type?&#160;<tt> </tt>Should #defines or enums be used for
	the true and false values?
</h3><p>
  	C does not provide a standard boolean type, because picking one
	involves a space/time tradeoff which is best decided by the
	programmer.&#160;<tt> </tt>(Using an <code>int</code> for a boolean may be faster, while
	using <code>char</code> may save data space.)
<p>
	The choice between #defines and enums is arbitrary and not
	terribly interesting (see also <a href="c-9.html#9-1">question 9.1</a>).&#160;<tt> </tt>Use any of
<p>
<pre>
	#define TRUE  1			#define YES 1
	#define FALSE 0			#define NO  0

	enum bool {false, true};	enum bool {no, yes};
</pre>
<p>
	or use raw 1 and 0, as long as you are consistent within one
	program or project.&#160;<tt> </tt>(An enum may be preferable if your debugger
	expands <code>enum</code> values when examining variables.)
<p>
	Some people prefer variants like
<p>
<pre>
	#define TRUE (1==1)
	#define FALSE (!TRUE)
</pre>
<p>
	or define &quot;helper&quot; macros such as
<p>
<pre>
	#define Istrue(e) ((e) != 0)
</pre>
<p>
	These don't buy anything (see <a href="c-8.html#8-2">question 8.2</a> below; see also
	<a href="c-1.html#1-6">question 1.6</a>).
<p>

<h3>
<a name="8-2">
8.2:	Isn't #defining </a><code>TRUE</code> to be 1 dangerous, since any nonzero value
	is considered &quot;true&quot; in C?&#160;<tt> </tt>What if a built-in boolean or
	relational operator &quot;returns&quot; something other than 1?
</h3><p>
  	It is true (sic) that any nonzero value is considered true in C,
	but this applies only &quot;on input&quot;, i.e. where a boolean value is
	expected.&#160;<tt> </tt>When a boolean value is generated by a built-in
	operator, it is guaranteed to be 1 or 0.&#160;<tt> </tt>Therefore, the test
<p>
<pre>
	if((a == b) == TRUE)
</pre>
<p>
	will work as expected (as long as <code>TRUE</code> is 1), but it is
	obviously silly.&#160;<tt> </tt>In general, explicit tests against <code>TRUE</code> and
	<code>FALSE</code> are undesirable, because some library functions (notably
	isupper, isalpha, etc.) return, on success, a nonzero value
	which is <em>not</em> necessarily 1.&#160;<tt> </tt>(Besides, if you believe that
	&quot;<code>if((a == b) == TRUE)</code>&quot; is an improvement over &quot;if(a == b)&quot;, why
	stop there?&#160;<tt> </tt>Why not use &quot;<code>if(((a == b) == TRUE) == TRUE)</code>&quot;?)&#160;<tt> </tt>A
	good rule of thumb is to use <code>TRUE</code> and <code>FALSE</code> (or the like) only
	for assignment to a Boolean variable or function parameter, or as the
	return value from a Boolean function, but never in a comparison.
<p>
	The preprocessor macros <code>TRUE</code> and <code>FALSE</code> are used for code
	readability, not because the underlying values might ever
	change.&#160;<tt> </tt>(See also questions <a href="c-1.html#1-7">1.7</a> and <a href="c-1.html#1-8">1.9</a>.)
<p>
	References: <a href="index.html#K-amp-RI">K&amp;R I</a> Sec. 2.7 p. 41; <a href="index.html#K-amp-RII">K&amp;R II</a> Sec. 2.6 p. 42,
	Sec. A7.4.7 p. 204, Sec. A7.9 p. 206; <a href="index.html#ANSI">ANSI</a> Secs. 3.3.3.3, 3.3.8,
	3.3.9, 3.3.13, 3.3.14, 3.3.15, 3.6.4.1, 3.6.5; Achilles and the
	Tortoise.

<p>
<hr>
<a href="c-7.html"><img SRC="prev.xbm" ALT="[prev]"></a>
<a href="index.html#comp-lang-c-faq"><img SRC="up.xbm" ALT="[up]"></a>
<a href="c-faq-toc.html#c-8"><img SRC="overview.xbm" alt="[overview]"></a>
<a href="c-9.html"><img SRC="next.xbm" ALT="[next]"></a></body></html>
